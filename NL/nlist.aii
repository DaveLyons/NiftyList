*********************************************************
myVersion	equ $8350
DebugSymbols	equ 1
*********************************************************
*
* NL -- Nifty List
*
* by David A. Lyons, 16-Jan-87
*
*********************************************************
*
* Modified  19-Mar-87  DL ==> v0.4
*   Added dereference on entry after Lock--duh!
*
* Modified 23-Jun-87   DL ==> v0.6
*   Fixed opcode $AE to disasm to LDX, not LDA
*   Real GETLN routine written
*   '/' command added + decent hex number parsing
*   Added ShareWare notice.
*
*   Gobs more commands added, for memoryish stuff.
*
* 24-Jun-87 DL ==> v1.0
*   Added '=' (cmd descriptions), '#', S)tatus
*   Gobs more stuff added.
*
* 26-Jun-87 DL ==> v1.1
*   Ctrl-y vector restored correctly after use.
*
* 27-Jun-87 DL ==> v1.2
*   Reads language card (set bank with 0>L or 1>L)
*   (") command added
*   Can use Q or 3D0G to return, not just Ctrl-Y
*   >S for printing
*
* 28-Jun-87 DL
*   PER/BRL operand corrected; was too large by 1.
*   Text output is now to BASIC devices; can redirect
*   to slots with n>S.
*   Opcodes $01 and $37 corrected (addr modes were bad).
*
* 27-Aug-87 DL ==> v2.0
*   Made into a CDA with a 'shutdown' routine to load
*   the data file.  (Was a permanent init file before.)
*   >u, >a, >x, >m
*   p command
*
* 14-Oct-87 DL ==> v2.1x
*   P prints 'u' flag
*   'P' documented in main help screen
*
* 18-Oct-87 DL ==> v2.1
*   ~m, ~s (dump MessageCenter, ScrapMgr info)
*
* 31-Dec-87 DL ==> v2.2p
*   =v fixed up
*   'xce' behaves like 'sep #$30'
*   Doesn't bomb under ProDOS 8 or when loader is not present
*   Doesn't print a pathname for ID=$0000
*
* 13-Jan-88 DL ==> v2.2
*   ';' command added
*   ^N, ^E
*
* 4-Feb-88  DL ==> v2.21
*   bank-wrap weirdness fixed on L, ;a, ;h
*   Long JMP instructions ($5C) behave like JSLs
*     (for E1 vectors, etc.)
*   Corrected which-tool-locator logic; was not working
*     for E10004 or E1000C.
*   E1 vectors are named when they are Listed.
*   T prints FPT address for function 0 of a toolset;
*     0T prints system and usr TPT and WAPT addresses.
*   (") works for E1 vectors and ProDOS calls (worked
*     only for tools before)
*
* 13-Feb-88 DL ==> v2.22
*   '#' command ANDs off highest (4th) byte of address,
*     because the 't' (or (") or whatever) cmd sometimes
*     leaves a $FF there, causing 'w' to act strangely.
*
* 15-May-88 DL ==> v2.3
*   --1 instruction added to correct the splicing of
*     two-byte ProDOS 16 command codes.  The high byte was
*     being ignored, so APW calls did not disassemble right.
*   --(") command is no longer case-sensitive.
*   --i tries calling GetPathname with ID&$F0FF
*
* 26-Jun-88 DL ==> v2.4p
*   --~h lists HeartBeat queue tasks
*   --~s works with new ScrapManager versions
*   --upcase routines fixed: weren't working with 'Z'!
*   --nonzero Aux IDs on 'i' cmd are significant
*     ('a0bc' matches 'axbc', but nonzero aux id must
*      match)
*   --zero in low byte of ID matches anything!
*
* 30-Jun-88..13-Jul-88 DL (still 2.4p)
*   [x] any 0 part of an ID is wild:  x/y/zz
*   [x] PEA $abcd; JSL $E100B0 --> P16 call
*   [x] E0 vector support?
*   [x] ~w lists windows
*   [x] ;W displays a window
*   [x] ;P displays a port
*   [x] ;r = rectangle
*   [x] ;R = region
*   [x] ~p lists fun ports
*   [x] Chains into SysDeath vector to shut down the
*       Event Manager (while EM is on, Apple-Ctrl-ESC
*       works only during GetNextEvent/etc)
*
* 23-Aug-88..25-Aug-88 ==> v2.4
*   [x] cleaned up '?' text (added menu)
*   [x] xxxx.yyyyC -- ranges for L, ;h, ;a
*   [x] nT displays FPT address
*   [x] nT for non-loaded tool displays all names
*   [x] ;C prints address & knows ListMgr record
*   [x] Apple-H dumps screen to slot 1
*   [x] Apple-Opt-H dumps pre-CDA scrn (shift=80col)
*
* 29-Aug-88 ==> v2.41
*   fixed ~m to not skip first message
*
* 27-Sep-88 ==> v2.42p
*   fixed ;P to show Points correctly, including PenSize.
*   Separated ? into '?' and '$'
*
* 04-Oct-88 ==> v2.50
*   added ;M to disassemble menu structures
*
* 15-Feb-89 ==> v2.60p
*   changed ';' command to default to previous option
*     when at end of line or followed by space or another
*     semicolon
*   fixed screen dumping not to print control characters
*     for inverse, flashing, MouseText
*   S now shows ROM version; if GS/OS available, shows
*     SESSION_STATUS, SET_SYS_PREFS; GET_LEVEL if
*     available; shows all available nonempty prefixes
*     from 0 to 31
*
* 26-Feb-89 ==> v2.60
*   ROM Version prints a byte, not a word.
*   Released.
*
* 21-Apr-89 ==> v2.61
*   Tries LGetPathname2 for i cmd.
*
* 23-Apr-89 DAL
*   now builds under MPW--byte-for-byte compares okay
*
* 24-Apr-89 DAL
*   LGetPathname2 is working; have not tested when not
*   available.
*
* 26-Apr-89 DAL ==> v2.70p
*   Address changed in $ screen.  Not released yet.
*
* 27-Apr-89 DAL ==> v2.70p
*   R command lists open resource files.  W, H, and I cmds
*   show resource type/id for blocks that were loaded by
*   the resource manager.
*
*   ~w dereferences window title handles when necessary.
*
*   For release at AppleFest Boston by Jim Mensch.
*
* 15-Jun-89 DAL
*   Expanded infoBuff to 256 characters, since GET_PREFIX
*   returns long things even in class 0.
*
* 16-Jun-89 DAL
*   MatchResourceByHandle--now we always set the current
*   resource application ID to the ID of the handle we
*   are trying to identify (and restore it right after the
*   MatchResource).
*
* 11-Jul-89 DAL
*   Working on ;C for super controls.
*   Fixed 0/0;W to display info on frontmost window.
*   Changed R to take a memory ID and show the specified
*   application's open resource files.
*   Began framework for module support.
*
* 12-Jul-89 DAL
*   Changes in screen dumping:  Apple-H is hardcopy of
*   the current 80-col screen.  Apple-4 and Apple-8 print
*   40- and 80-column pre-CDA screens.  CapsLock enables
*   ImageWriter II MouseText dumping.  >p sets printer slot
*   for screen dumping.  p now prints prints printer slot.
*   Apple-blank linefeeds printer; Apple-Return formfeeds.
*
*   Now uses ALL.MACROS file for toolbox macros and PushLong,
*   etc.
*
* 13-Jul-89 DAL
*   Loads modules (no useful functionality yet).
*
* 4-Oct-89 DAL
*   "Super control" references changed to "extended control".
*   Modules now have an assigned filetype/auxtype.
*
* 8-Oct-89 DAL
*   Updated "AppleLinkPE" to "America Online".
*   Current printer slot appears in "$" message.
*
* 14-Oct-89 DAL
*   Saves keyboard buffer ($0002xx) during Visit Monitor.
*
* 24-Nov-89 DAL ==> v2.90p
*   Loads modules with InitialLoad2, so the loader knows their
*   pathnames.
*   Added chrget and chrgot, with module access.
*   Added resource names to i command.
*   Added free-space display to i command.
*
* 25-Nov-89 DAL
*   Tolerates bit 7 being set in NLIST.DATA.
*   Adding ;S for stack dump.
*   Added F8 and Softswitch support.
*   Added  attr.id syntax to i command.
*   Pathname on handle info is truncated, and a generic
*     description is provided when the loader doesn't
*     have a path.
*
* 17-Dec-89 DAL
*   Option to disable softswitch/ROM tags for 2-byte-operand
*     instructions (0>r).
*   Added >d--data file flags. 1=load NLIST.DATA at boot,
*     2=data file is purgable.
*   Made 0/0;C display content controls of front window.
*   Z saves settings; loaded automatically at boot time
*     (*/System/Desk.Accs/NList.Settings).
*
* 7-Jan-90 DAL
*   Added bank $01 vectors.
*   Apple-4 and Apple-8 dump the E0/E1 pre-CDA screen,
*     not the 00/01 copy (so now you can dump the GSBug
*     screen if you feel like it).
*   Fixed crash when NL entered under P8 and NLIST.DATA had
*     been purged (it tried to Close the file even though
*     GS/OS was not available).
*
* 10-Jan-90 DAL
*   Fixed copyright date (1988-90).
*   JSL $E1000x without an LDX# before it now prints vector
*     name instead of printing nothing.
*   Added look-ahead for complicated toolbox calls (replaced
*     old code entirely).  $E10004/C calls show ">" before
*     name.  Miniature interpreter for JSL, JMP, JMP>, LDX
*     (interpreting begins with a JSL, JMP, or JMP>).
*
* 12-Jan-90 DAL
*   Disassembly lookahead code looks for calls to the
*     NLService entry and shows them (new data-file section
*     added for NLService vectors; support in (") added).
*   "=\" prints the "about" help for all loaded modules.
*
* 13-Jan-90 DAL
*   ;h has a blank after the 8th hex value on each line.
*   ;h omits repeated lines and shows a line of apostrophes
*     for each group of one or more lines that is identical
*     to the line above.
*   Pressing ESC when there are some characters on the input
*     line is like pressing Ctrl-X.
*   If data file is loaded on entry to NL, the title box
*     appears before the disk access.
*   Disasm lookahead code interprets BRA and BRL, and ookahead
*     can begin with a BRA or BRL.
*   ~m explains message types it knows about.  For type>$7fff,
*     it displays the p-string name at the beginning of the
*     message.
*   Implementing real service vectors.
*   Can abort ~s scan (hit a key).
*
* 14-Jan-90 DAL
*   Forgot to document resource stuff in S command; be sure to
*     put it in the release notes.
*   MattD notes crash shortly after Apple-Return: doPrinterChar
*     was pushing an extra byte on the stack (missing SEP).
*   Dumping a rectangle or region at 00/0000 prints "NIL!"
*     instead of showing data.
*   >c parameter to enable compression for ;h.  Compression
*     is limited to range-specified ;h commands--it never
*     happens with just a starting address.
*   Resource Types section added to data file (support in (")
*     command, and used by PrintResInfo)
*   Space single-steps screen output instead of toggling the
*     pause.
*   Status shows the "@" prefix.
*
* 15-Jan-90 DAL
*   MattD and JeffD found the data file was getting trashed in
*     memory.  Turns out NL was dealing improperly with data
*     files having fewer than the expected number of sections.
*     Fixed.
*   Now dispatches control to module commands.
*   Special Apple- keys work whenever CheckKey is called
*     (including when output is paused).
*   Implemented nlLookup, nlSpout, nlCrout, nlGetAGlobal,
*     nlSetAGlobal.  Redefined service calls so that you
*     don't need to push space for the result when it isn't
*     going to be used anyway.  Changes to FindPrint.
*   Bank register set to bank of module's info table whenever
*     the module is called.
*
* 16-Jan-90 DAL
*   Implemented nlIndLookup, nlGetInfo, nlAbortToCmd, and
*     gBusyCount (means the user is "in" Nifty List, not
*     just that NLService is doing something).
*   Rearranged OneTool output so the addresses line up
*     on the left.
*   The tool 0000 entries now display TPT addresses.
*   Moved copyright message (title screen image) to near
*     the beginning of the object code.
*
* 30-Jan-90 DAL
*   Fixed Apple-. to abort again (broke while adding
*     special Apple-space, -return, -H features that work
*     during single-stepping).
*
* 18-Feb-90 DAL
*   Added >v parameter for Voice synthesizer users.  1>v
*     inhibits output of annoying things like lines of dashes.
*
* 20-Feb-90 DAL
*   Fixed S so it doesn't crash when the Resource Manager isn't
*     available (was leaving crud on stack).
*   Fixed entry to NL so it doesn't hang if it can't allocate
*     memory to store NLIST.DATA (wasn't pulling NewHandle
*     result on failure).
*
* 25-Feb-90 DAL
*   Status shows NL's memory ID.
*   Adding real dumping for extended controls.
*
* 4-Mar-90 DAL
*   Fixed userData size on dumping a TE record.
*
* 8-Mar-90 DAL --> v2.90
*   Adjusted spacing on 'p' output.
*   Fixed ffT to not crash.
*   Fixed dump-TE-record to start single-stepping output
*     automatically.
*   Fixed ctlData dumping to check for NIL & put blanks
*     around the string.
*   Optimized some lda #' '/jsr cout sequences into jsr spout.
*   Made version number really be 2.90.
*
* 17-Mar-90 DAL --> v2.91
*   Fixed ;C to work with ROM 3 List Controls at $FC/F0E9.
*   A standard list control no longer accidentally dumps the
*     extra fields from the previously-dumped control.
*   Disassembles JSL to service vector (doesn't need a JMP).
*   Replaced some _WriteString calls with nlShowStr calls.
*   S shows nlService vector.
*   ;M tries to notice when a titleName is not a pointer.
*
* 23-Mar-90 DAL --> v2.92
*   Ctrl-T toggles super-hires on and off.
*   When a name can't be found for a JSL/JMP to a given
*     operand in banks E0/E1/01, now we go ahead and check
*     the address & display a name if there is one.
*   Fixed control dumping for custom controls (displays a
*     description, and dumps any bytes beyond the standard
*     record sizes).
*
* 25-Mar-90 DAL --> v3.00p
*   Improved speed of I command by special-casing some memory
*     IDs not to call LGetPathname2.
*
* 31-Mar-90 DAL
*   When installed, NL now tries to remove the old copy of NL
*     by getting its service vector from the Message Center
*     and calling nlRemoveNL, RemoveCDA, UserShutDown.
*   Adding expression evaluator.
*   Changed chrget to advance before fetching, not after (old
*     routine is called chrgotAdvance).
*   nlEnter forces text mode (and restores super-hires state).
*
* 1-Apr-90 DAL
*   Shrunk stack from 4K to 2K.
*   Added ":" command to store expressions into memory.
*   Added "_" command (just like "`" for now).
*   When shutting down, we now UserShutDown any loaded modules.
*
* 2-Apr-90 DAL
*   Added code in intMenu to set ctlKind and ctlProc (UNTESTED)
*     to avoid "custom control" menu for pop-ups.
*
* 29-Apr-90 DAL
*   Changed hard-coded pathnames from */SYSTEM/DESK.ACCS to
*     call LGetPathname and strip off the filename.
*
* 6-Jul-90 DAL
*   Changed stack-handle ID from $5Fxx to $52xx.
*   Changed 'q' to require that it's the last character on the
*     command line.
*   Changed "could not load NList.Data" to display error code.
*   Changed ";" to not care about case (;c and ;r check whether
*     the supplied value is a handle or not).
*   In window dumps/etc, a region shows up with its handle.
*
* 7..8-Jul-90 DAL
*   Implemented the nlGetRange service call.
*   Added nlHandleInfo service call.
*   Fixed stupid stack bug:  was still setting stack pointer to
*     handle+4K even though the stack is now only 2K.  The
*     screwy version was not distributed beyond DTS.
*   Added ^Z command for debugging commands--it causes a BRK $42
*     right before the dispatch to the command (any "\" command,
*     or any internal command other than "\" or " ").
*   Here's a tip for using ("):  If you want an "exact match"
*     for a toolbox call, sometimes you can include the open
*     paren.  Example:   "NewControl(   vs.  "NewControl
*   Added support for Errors section, including (") cmd.
*   Implemented version checking on modules--now we ignore
*     them if they need a later version of NL.
*
* 11..12-Jul-90 DAL
*   Added "_" evaluation for calling system tools by name
*     with parameters (can't nest the calls yet).
*
* 12..13-Jul-90 DAL
*   Improved "_" code:  added user toolset support,
*     implemented nesting.  No longer need "()" if calls
*     with no parameters.  Now tolerates blanks among the
*     parameters.
*   Changed nlGetRange service to return 16 bytes (start
*     and end of range, with and without default bank
*     handling).
*
* 14-Jul-90 DAL (released as 3.0)
*   Changed "#" inside expressions to take #123 or #identifier
*     (identifiers can be system or user toolbox names).  This
*     was already here for decimal numbers, but it wasn't in
*     the release notes.
*   Make "_" toolbox calls paranoid--put direct-page at $0400.
*   Z prints error code name when there's a problem.
*   Changed command-module aux-id to 0.
*   Added service nlGetDirectory.
*   New services:  nlWriteNoVoice, nlShowWString.
*   Made "#" constants work with: GS/OS calls and resource
*     type names.
*
* 24-Jul-90 DAL --> v3.1p
*   Fixed ID=$0000 when breaking into NL before the ShutDown
*     routine gets called for the first time.  (Entry calls
*     shutdown now.)
*   Adding real command-line editing and history.
*
* 25-Jul-90 DAL
*   Prints a warning on entry if the stack is only one page.
*   CDA/NDA header dumps print "(RTL)" after addresses that
*     just RTL.
*
* 28-Jul-90 DAL
*   Fiddled with Ctrl-T twiddling.  Now it makes the border
*     white while you're looking at SHR but not really in
*     the app (if your border -was- white, it makes it black).
*     If QD isn't on, Ctrl-T still twiddles but also chirps.
*   Working on getln editing.
*
* 30-Jul-90 DAL
*   Fixed Ctrl-D in getln.
*
* 7-Aug-90 DAL
*   Adding Nifty List sessions and callbacks.
*
* 10..11-Aug-90 DAL
*   Added 0/0;p (dump the current port).
*   Fixed some getln-editing problems (Ctrl-Y, Ctrl-D).
*   Added "FunWindow" and "Death" callbacks.
*
* 12-Aug-90 DAL
*   Fixed "*" to work only when you're "really" in Nifty List.
*
* 5-Sep-90 DAL
*   Moved save-stack-and-direct-page code so coming back from
*   the Monitor doesn't mess up the stack.
*
* 20-Oct-90 DAL
*   Added call to DebugSetHook so that GSBug "n" takes you
*   into Nifty List.
*
* 24-Oct-90 DAL
*   Finished History!  New getln command: Ctrl-Z cancels
*     command but writes it to history anyway.  Up and down
*     arrows walk through the history list.  When you press
*     return or Ctrl-X or Ctrl-Z, you pop down to the bottom
*     of the list again.
*   Calls _DebugGetInfo when you enter from GSBug, to get
*     a default address.
*   Fixed nlExecCmdLine to work with single-character lines.
*
* 25-Oct-90 DAL
*   Added a couple more doFlush calls.
*   "v" always shows GSBug version (toolset $FF).
*
* 30-Oct-90 DAL
*   Fixed nlExecCmdLine service to properly dereference
*     and lock DataHandle.
*
* 1-Nov-90 DAL
*   Made  "===  always show zeroes for nonexistent FPTs.
*   Added UndoDebugHook to call DebugSetHook(nil) when
*     Nifty List gets unloaded.
*
* 2-Nov-90 DAL
*   Now sets Bank regsiter in debug hook.
*
* 30-Nov-90 DAL
*   Adding 'name' macro to imbed debugging info.
*   Changed error check from tool Version to be BCC instead
*     of cmp #0.
*   Disabled interrupts in StoreExpr.
*   Check debugger version before calling DebugSetHook.
*
* 1-Dec-90 DAL
*   Took out the Chirp on passing the end of the history (was
*     getting false triggers).
*   Added a blank after '[debug]' for debug versions.
*   Made the initial history string the right length.
*   Now shows imbedded procedure names in disassembly
*     (at actual location [BRL] and as JSR/JSL refs).
*
* 2-Dec-90 DAL
*   Added service call nlGetProcName to get the symbolic
*     name associated with a given address.
*   ;s displays symbolic procedure names.  ;s calls
*     DisasmEntry so you get all the usual Special
*     stuff in the margin, like vector names.
*
* 7-Jan-91 DAL
*   Made ;s notice JSR ($zzzz,X) just like JSR.
*   Made windowptr;C dump content controls for the specified
*     window.
*   Ctrl-S now writes input line to history without executing
*     it (was Ctrl-Z).
*   Added Apple- commands to GetLn.  Apple-<, Apple->, Apple-F,
*     Apple-Y, Apple-E (toggle insert).
*   Return bops now you to the end of the input before returning.
*   "_" now shows the names of result parameters.
*
* ?-Dec-90:
*   Changed "`" command to display the result in decimal if it's
*     4 bytes or less.
*
* === 3.1 final ===
*
* 13-Jan-91 DAL ==> 3.2p
*    Added fast text I/O routines, called from the standard
*      session's callbacks.  (New file TextIO.aii.)  Output
*      is around 3.5 times faster now.
*    Added caching for the last ID/result for LGetPathname2.
*    PrInfoID2 used to try LGetPathname if it got an error
*      back from LGetPathname2.  Now it doesn't.
*    Changed a number of "ds" directives into "ds.b".
*    Added HyperCard IIgs vector support in Quote, "#"
*      constants, "_" expressions, and the List command.
*
* 19-Jan-91 DAL
*   Now attempts to load NList.AppleData instead of NList.Data.
*     If there is no NList.Data to open, it loads NList.Data
*     just like before.
*
* 27-Jan-91 DAL
*   Fixed GetKey in TextIO.aii to return correct Apple key status
*     even when Event Manager is inactive.
*   Fixed InitOutput to make the standard bottlenecks go through
*     the text tools when we're trying to redirect to a slot.
*
*
* 2-Feb-91 DAL
*   (x) Make =\ pause after each module's help.
*   (x) Make 0r explicitly use the current resource app
*   (x) Make R display whose search path it's dumping.
*   (x) Show cool scrap types.
*   (x) addr1,length (like addr1.addr2)
*   (x) Plug "_" addresses into current address.
*
* 5-Feb-91 DAL
*   (x) Implemented NLDisasm1 entry (input=address, output=new address)
*   (x) Don't put duplicate lines into history.
*
* === Released 3.2 ===
*
* 10-Feb-91 DAL ==> v3.3p
*   Made backslash command names case insensitive.
*
* 22-Feb-91 DAL
*   Removed extra carriage returns from ~s display.
*
* 26-May-91 DAL
*   Changed in-memory data file copy so that each section
*     can be 64K--section offset table now has 4-byte values.
*   Option-return now twiddles SHR screen on, and it gets
*     twiddled off automatically when you return to the
*     command line.
*
* 30-May-91 DAL
*   Adding nlClassifyAddr service to map from an input address
*     into a code and character indicating ROM, system patch,
*     other patch, invalid address.  Global SystemPatchID is
*     computed at init time.  "T" command uses this to mark
*     tool calls as patched/etc.
*   Stack dump now continues with caller's stack after dumping
*     the GS/OS stack.
*   Adding services nlGetTextState and nlSetTextState.
*
* 31-May-91 DAL
*   Changed ClassifyAddr to mask off AuxID when checking for TSx,
*     and to check handle's attributes for sanity.
*   Uses GetIndScrap when available, for speed.
*
* 1-Jun-91 DAL
*   If available, install an AcceptRequests procedure to handle
*     NLService calls.
*   New selector nlgInfoTable to nlGetAGlobal returns address
*     of the nlGetInfo table (some fields always valid).
*   Added System Patch ID and Service address to info table.
*
* 8-Jun-91 DAL
*   Added missing RTS that made us crash under 5.0.4
*
* 14-Jul-91 DAL
*   Call it 3.3 final.
*
* === Released 3.3 ===
*
* 21-Aug-91 DAL ==> 3.4p
*   Version 3.4 prototype.
*   Grew expression buffers from 64 to 160 characters.
*   Added some support for a new "reqproc" section of data file.
*
* 26-Aug-91 DAL
*   Finished updating versions to 3.4p.
*   Made "#" (constant) support RequestCodes.
*
* 17-Oct-91 DAL
*   Entering from GSBug with 'n' now sets CurBank.
*   i command and others now always properly show the resource
*     file a handle came from, when running under 6.0 (uses new
*     field in MatchResourceHandle).
*
* 6-Nov-91 DAL
*   Ctrl-W deletes a word.
*   Tool display doesn't mark user tools with ClassifyAddr.
*   ~m shows the ID and address for request procedures.
*   Control dumping knows about Themometer and Rectnagle controls.
*
* 9-Nov-91 DAL
*   Added infix operators "+" and "-" (for 1..4-byte operands).
*
* 9..11-Nov-91 DAL
*   Make "+" overflow a byte into a word, word into longword.
*   Added infix operator "*".
*
* 25-Nov-91 DAL
*   ~m shows name for message $0011 (wstring paths to Open/Print).
*
* 12-Dec-91 DAL
*   ~s shows $8003 scrap type (resource reference).
*
* 10-Feb-92 DAL
*   Copyright includes 1992.
*   Stack crawl tops out at $C000 if the stack is not in
*     page one and is not allocated.
*
* 1-Mar-92 DAL
*   "i" command no longer messes up CurResourceApp if you
*     abort.
*
* === Released 3.4 ===
*
* 5-Mar-92 DAL --> v3.5d1
*   Changed version.
*
* 26-Jul-92 DAL --> v3.5d2
*   Implemented "@" operator (allocates 132 bytes of RAM
*     in $56xx ID on each use).
*   Strings in expressions can start with \p for Pascal,
*     \w or \g for GS/OS string, \c for C string.
*
* 9-Aug-92 DAL
*   Finished making @ operator work.
*   Adding new callback nlAddressInfo--finds symbolic
*     name for an address ("ThisCoolRoutine+1234").
*
* 28-Aug-92 DAL --> v3.5d3
*   =\ no longer crashes if there are no modules present.
*
* 3-Oct-92 DAL --> 3.5d4
*   cstring/pstring/etc work even if you leave off the closing
*     quote (simply removed an RTS).
*   Plain strings don't accidentally store csting/pstring stuff
*     (a backslash in a comment was eating a line of source!)
*
* 25-Jan-93 DAL --> 3.5d5
*   Use GetPrefixGS for S.
*
*********************************************************
	include 'all.macros'
;;;	include 'm16.debug'
	include '::E16.NList'

;	macro
;	_DebugSetHook
;	ldx #$0bff
;	jsl $e10000
;	mend
;
;	macro
;	_DebugGetInfo
;	ldx #$0cff
;	jsl $e10000
;	mend
;
;	macro
;	_DebugVersion
;	ldx #$04ff
;	jsl $e10000
;	mend
;
;	macro
;&lab	_AcceptRequests
;&lab	ldx #$1b01
;	jsl $e10000
;	mend


E1CompactFlag	equ $E100CB

	MACRO
&lab	_WriteCS
&lab	pea cbWriteC
	jsl doCallBack
	MEND

rwp	equ 0
BuffSize	equ 160
ExprBuffSize	equ 160

StackSize	equ $0800	;2K stack
StackAuxID	equ $0200	;stack handle gets $5_xx ID
HistSize	equ $0400	;1K history
HistAuxID	equ $0300	;history handle gets $5_xx ID
GoodiesAuxID	equ $0500	;Goodies module uses this
DynamicAuxID	equ $0600	;expression temp-memory uses this (26-Jul-92)

SecP8	equ 0	;ProDOS 8 section
SecP16	equ 1	;P16,GS/OS,Shell section
SecSysTool	equ 2	;System Tools section
SecUserTool	equ 3	;User Tools section
SecE1vec	equ 4	;E1xxxx vector section
SecE0vec	equ 5	;E0xxxx vector section
SecF8andSS	equ 6	;softswitch & F8 ROM section
Sec01vec	equ 7	;01xxxx vector section
SecNLService	equ 8	;Nifty List service calls section
SecResTypes	equ 9	;resource type names
SecErrors	equ 10	;OS and toolbox error codes
SecHyperCard	equ 11	;HyperCardIIgs callbacks
SecReqCode	equ 12	;SendRequest codes (for 3.4)
SecNUMBER	equ 13	;---total number of sections---
HeaderSize	equ SecNUMBER*4
*
* states for DisasmState
*
StateNorm	equ 0	;disasm one line
StateP8a	equ 1	;P8 command byte
StateP8b	equ 2	;P8 parm ptr (word)
StateP16a	equ 3	;P16 command word
StateP16b	equ 4	;P16 parm ptr (long)
;StateNameA	equ 5	;procname signature word
;StateNameB	equ 6	;procname pString
*
* data structures for command modules
*
modFileType	equ $BC	;Module filetype and auxtype
modAuxType	equ $4001	;(assigned by AIIDTS Sept 89)
cfgFileType	equ $5A	;Nifty List configuration filetype
cfgAuxType	equ $8006	;and auxtype (assigned Sept 89)
*
* module table field offsets:
*
oModPtr	equ 0	;pointer to module's header
oModTable	equ 4	;info table returned by Open routine
ModEntSize	equ 8	;bytes in table entry
MaxModules	equ 32	;maximum num of command modules
*
* module info table field offsets:
*
mtSize	equ 0	;size of info table (bytes)
mtFormat	equ 2	;table version (0)
mtPatchType	equ 4	;type of service patch (0)
mtPatchAddr	equ 6	;address to patch for nlService
mtCmdEntSize	equ 10	;bytes per command entry (12)
mtCommandTbl	equ 12	;ptr to table of cmd entries
*
* mcmd table field offsets:
*
mcName	equ 0	;ptr to pascal string (cmd name)
mcEntry	equ 4	;command entry point
mcHelp	equ 8	;show-help entry point
*
* Nifty List Session tables
*
MaxSessions	equ 16
ssnCallBack	equ 0
ssnSize	equ 4
*
* assorted tool stuff
*
tool	equ $E10000
UserTool	equ $E10008
SystemTPT	equ $E103C0
UserTPT	equ $E103C4
*
* Memory Manager stuff
*
FirstHandle	equ $E11600	;addr of first handle
hFlags	equ 4	;offsets into master pointer record
hID	equ 6
hLength	equ 8
hPrev	equ 12
hNext	equ 16
*
* ProDOS 16 stuff
*
P16	equ $E100A8
*
* hardware definitions
*
modifiers	equ $E0C025
key	equ $E0C000
strobe	equ $E0C010
*
* key definitions
*
cBlank	equ $20
cLeft	equ $08
cRight	equ $15
cDown	equ $0A
cUp	equ $0B
lf	equ $0a	;line-feed
cr	equ $0d	;return
SPACE	equ $20
BACKSP	equ $08
DELETE	equ $7f
ESC	equ $1b
CANCEL	equ $18
TextScreen	equ $E00400
*PreCDAscreen	equ $E00C00	;copy of the bank 0/1 screen
PreCDAscreen	equ $E01400	;copy of the bank E0/E1 screen

NL	PROC
	PRINT NOSYM
	Case off

	import DescrTbl
	import desSemi
	import desTilde

	import TxtOutCString
	import TxtOutText
	import TxtReadChar
	import TxtGetCursorV
	import TxtGetState
	import TxtSetState

*********************************************
*
* Classic Desk Accessory header
*
*********************************************
NiftyCDA	str 'Nifty List 3.5d5'
	dc.l start
	dc.l shutdown
*********************************************
	dc.b 13,13,'If you can read this, you''re too close!',13,13
*********************************************
TitleMsg	DC.B cr,$8C
TheTitle	DC.B '      ___________________________________________________________________' ,cr
	DC.B '     |                                                                   |',cr
*vers *date
	DC.B '     |   Nifty List v3.5d5         SHAREWARE                 25-Jan-93   |',cr
	dc.b '     |                                                                   |',cr
	DC.B '     |                  Copyright 1988-93 David A. Lyons                 |',cr
	DC.B '     |___________________________________________________________________|',cr
	DC.B 0
*
Welcome	DC.B cr,'(Type ? for help, $ for Shareware notice.)',cr,0
*
	export TermsMsg
TermsMsg	DC.B cr
	DC.B 'Nifty List used to be Shareware, but now it's free.',cr
	DC.b cr,0

msgSmallStack	dc.b cr,'[Stack is one page: be careful with complex expressions and tool calls]',cr,0
*********************************************
suicide2		;nlRemoveNL stores a BRK here
shutdown	name
	lda >FirstSh
	beq NoShutdn
	phb
	phk
	plb
	stz FirstSh
	jsr init
	plb
NoShutdn	rtl
FirstSh	dc.w 1
*********************************************
CheckP16	name
	lda $e100ba
	bne noP16z
	lda $e100bc
	and #$00ff
	cmp #$01
	bne noP16z
	clc
	rts
noP16z	sec
	rts
*********************************************
quit	name
	jsr UnTwiddle

	lda #actExitNL
	jsr NotifyModules	;8-Jul-90
*
* unlock data file handle
*
	pushlong DataHandle
	_HUnlock
	stz DataPtr+2
	stz DataPtr
*
* restore TextTools status
*
	_SetInGlobals
	_SetInputDevice
	_SetOutGlobals
	_SetOutputDevice
*
	pea nlSetSession	;restore old session
	jsl NLService
	pla
	pla	;discard result (our own session #)
*
	lda OldD
	pha
	pld
	lda OldB
	pha
	plb
	plb
	rtl
*
InitOutput	name
	pha	;save slot
	pea 0	;BASIC
	pea 0
	pea 3	;always input from slot 3?
	_SetInputDevice
	pla	;get slot
	cmp #8
	bcs use3
	cmp #0
	bne useSlotA
use3	lda #3
useSlotA	jsr SetUseTTFlag
	pea 0	;BASIC
	pea 0
	pha	;output slot #
	_SetOutputDevice
* init the devices
	pea 0	;input
	_InitTextDev
	pea 1	;output
	_InitTextDev
* set in/out globals
	pea $ff	;and
	pea $80	;or
	_SetOutGlobals
	pea $7f	;and
	pea 0	;or
	_SetInGlobals
	rts

SetUseTTFlag	stz UseTTFlag	;27-Jan-91 DAL
	cmp #3
	beq @is3
	inc UseTTFlag
@is3	rts

*********************************************
*********************************************
*
* stdCallBack(LongIn,code):LongOut
*
stdCallBack	name
	lda 4,s
	tax
	cpx #stdCallEnd-stdCalls
	bcs @bad
	jsr (stdCalls,x)
@bad	lda 2,s
	sta 8,s
	lda 1,s
	sta 7,s
	pla
	pla
	pla
	rtl

stdCalls	dc.w stdOutput,stdOutC,stdFlush,stdGetKey,stdChkAbort
	dc.w stdAbort,stdGetLine
stdCallEnd

stdOutput	phd
	tsc
	tcd

	lda >useTTFlag	;need to use text tools?
	bne ttOutput

	lda [$A]
	tax
	lda $C
	ldy $A
	iny
	bne @1
	inc a
@1	iny
	bne @2
	inc a
@2	jsl TxtOutText

	pld
stdFlush	rts

ttOutput	pei $C
	pei $A
	pea 2	;offset into text
	lda [$A]
	pha
	_TextWriteBlock
	pld
	rts


stdOutC	lda >useTTFlag
	bne ttOutC

	lda 8,s
	tay
	lda 10,s
	jsl TxtOutCString
	rts

ttOutC	lda 10,s
	pha
	lda 10,s
	pha
	_WriteCString
	rts


stdGetKey	phd
	tsc
	tcd
	jsl TxtReadChar
	sta [$A]
	pld
	rts

;	pha	;wordspace
;	pea 0	;no echo
;	_ReadChar
;	pla
;	and #$00ff

stdChkAbort	jsr Pause
	rts

stdAbort	brl Command

stdGetLine	brk $56
	rts

useTTFlag	dc.w 0

*********************************************
*********************************************
suicide1		;nlRemoveNL stores a BRK here
start	name
	phd
	phb
	phk
	plb

	inc gBusyCount

	pha	;Space for NewHandle result
	pha
	PushLong #StackSize
	pha
	_MMStartUp
	pla
	ora #StackAuxID
	pha
	PushWord #$C001	;fixed, locked, use specified bank
	PushLong #0	;(specify bank 0)
	_NewHandle
	tsc
	sta theOldStack
	tcd
	bcs  NoStackSpace
	lda  [1]
;	clc
	adc #StackSize-1
NoStackSpace
	pha
	ldx #$fe
keepStack	lda >$000100,x
	sta stackImage,x
	dex
	dex
	bpl keepStack
	pla
	tcs
	jsl start2
	php
	php
	pla
	sta pRegister
	sei
	ldx #$fe
restoreStack	lda stackImage,x
	sta >$000100,x
	dex
	dex
	bpl restoreStack
	lda theOldStack
	tcs
	lda pRegister
	pha
	plp
	plp
	_DisposeHandle

	dec gBusyCount

	plb
	pld

	rtl

pRegister	ds.b 2
theOldStack	ds.b 2
*********************************************

start2	name
	phd
	pla
	sta >OldD	;force 3-byte store; B invalid
	phb
	phb
	pla
	sta >OldB	;ditto
	phk
	plb	;OK, NOW the Bank reg is OK
*
* call the ShutDown routine in case it hasn't been called yet
* (user breaks into NL during boot, for example)
*
	jsl shutdown

	pha
	pha	;space for RESTORING session on exit
	pha	;set session #0 & leave old one on stack
	pha
	pea $5555
	pea 0
	pea nlSetSession
	jsl NLService
*
* Init text tools
*
* preserve TextTools status (leave stuff on stack)
*
	pha
	pha
	pha
	_GetOutputDevice
	pha
	pha
	_GetOutGlobals
	pha
	pha
	pha
	_GetInputDevice
	pha
	pha
	_GetInGlobals
*
* Save the stack and direct-page for aborting to the command line or
* returning from the Monitor
*
	tsc
	sta MainStack
	tdc
	sta MainDP

*
* choose I/O devices
*
reinit	name
	lda #3	;slot # for output
	jsr InitOutput
*
* 'welcome' msg
*
	pushlong #TitleMsg
	_WriteCS
*
* try to load data file if it isn't available (it may not be
* loaded yet, or it may have been purged)
*
	jsl Deref
	lda DataPtr+2
	bne haveDat
	jsr SetNLPrefix0
	bcs @x
	jsr ReadData
	jsr FixPrefix0
@x
haveDat
*
	pushlong #Welcome
	_WriteCS
*
* lock our DataHandle
*
	lda DataHandle+2
	beq @datatrouble
	pushlong DataHandle
	_HLock
	jsl deref	;deref into DataPtr
	lda DataPtr+2
	bne GotData
*
* handle nil or purged; must not have a good copy of
* data file
*
@datatrouble
	pushlong #FileMsg
	_WriteCS
	lda ErrorCode
	jsr prword
	lda #')'
	jsr cout
	jsr crout
*
GotData	name
*
* MAIN COMMAND LOOP
*
;	tsc	;removed 5-sep-90 DAL (moved to before reinit)
;	sta MainStack
;	tdc
;	sta MainDP

	tsc
	cmp #$200
	bcs @bigStack
	pushlong #msgSmallStack
	_WriteCS
@bigStack
	lda #actEnterNL
	jsr NotifyModules	;8-Jul-90

	jsr DoDebugHook	;20-Oct-90

Command	name
	lda MainStack	;can JMP here to abort stuff
	tcs
	lda MainDP
	tcd
*
	lda untoggleScrnFlag
	beq @1
	jsr TwiddleSHR
	stz untoggleScrnFlag
@1
*
	pushlong #Prompt
	_WriteCS
	jsr GetLn
*
* if the string isn't null or 'q', write it to the History
*
	tay
	beq @dontKeep
	lda PascBuffer	;length byte + first character
	cmp #$7101	;'q'
	beq @dontKeep
	lda #^pascBuffer
	ldy #pascBuffer
	jsr HistoryWrite
@dontKeep
*
* Execute the command line
*
	jsr DoCommandLine
	brl Command

DoAbort	name
	jsr doFlush
	pea cbAbort
	jsl doCallBack
	brk $ff	;should never get here!

DoCommandLine	name
	stz DescrFlag	;not "=" command yet
	stz RangeFlag	;no "." pending
	stz CommaFlag	;no "," pending
	stz SteppingFlag	;not single-stepping output
	stz DebugBreak	;no Ctrl-Z command found yet
	stz index
	jsr InvalidatePathCache
NxCmd	name
	ldy index
	jsr ScanNum
	bcc @cont
	rts
@cont	sty index
* dispatch command
	ldx #CmdsEnd-CmdChars
	sep #$30
	sta CmdChars
@cSrch	dex
	cmp CmdChars,x
	bne @cSrch
	rep #$30
	txa
	asl a
	ldy DescrFlag
	bne DescThis
	tax
	lda CmdChars
	and #$00ff
	cmp #' '
	beq @go
	cmp #'\'
	beq @go
	lda DebugBreak
	beq @go
	stz DebugBreak
	BRK $42	;executes on a Ctrl-Z cmd
@go	jsr (CmdAddrs,x)
	brl NxCmd

@theChar	dc.w 0
*
DescThis	name
	stz DescrFlag	;table of 4-byte entries
	asl a
	tax

	lda CmdChars
	and #$00ff
	cmp #'\'
	beq @isBksl

	lda DescrTbl+2,x
	pha
	lda DescrTbl,x
	pha
	_WriteCS
	brl NxCmd

@isBksl	jsr chrgot
	bcs @allOfIt
	jsr isBackslHelp
	brl NxCmd
@allOfIt	lda DescrTbl+2,x
	pha
	lda DescrTbl,x
	pha
	_WriteCS
	jsr PrintAllModHelp
	brl NxCmd
*
Prompt	DC.B cr
	if DebugSymbols<>0 then
	dc.b '[names] '
	endif
	dc.b 'NL> ',0

****************************************************************************
*
* Main Command Table
*
* Available cmd chars:
*
*  %&'()-,+<[]{|}gjknouy
*
****************************************************************************
CmdChars	dc.b '# =/LQMXVT?$HIW*#S@^>"P~;.,R\'
	dc.b $0E,$05,$12,$1A
	dc.b 'Z`_:!'
CmdsEnd
CmdAddrs	dc.w Error,Ignore,isDescribe,isBank,isList
	dc.w isQuit,isM,isX,isVersion,isTool
	dc.w isHelp,isDollar,isHandle,isIDInfo
	dc.w isWhatHand,isMonitor
	dc.w isPrevNum,isStatus
	dc.w isAt,isCaret,isSetvar,isQuote
	dc.w isParam,isTilde,isSemi,isPeriod,isComma
	dc.w isResources,isBackslash
	dc.w isCtrlN,isCtrlE,isCtrlE,isCtrlZ	;Ctrl-R = Ctrl-E
	dc.w SaveConfig
	dc.w isEvalExpr,isUnderscore,isColon
	dc.w isComment

*****************************************************************************
*
* Ignore -- null command
*
****************************************************************************
Ignore	name
	rts

*
* ! -- comment (ignore rest of command line)
*
isComment	name
	jsr chrget
	bne isComment
	rts

*
* ^Z -- debugging (break on next command dispatch)
*
isCtrlZ	name
	inc DebugBreak
	rts
DebugBreak	dc.w 0

*
* ^N -- set m and x to 0
*
isCtrlN	name
	stz mflag
	stz xflag
	rts

*
* ^E or ^R -- set m and x to 1
*
isCtrlE	name
	lda #$8000
	sta mflag
	sta xflag
	rts

*
* = -- describe next command
*
isDescribe	name
	inc DescrFlag
	rts

*
* isAt -- do 2-byte indirection
*
isAt	name
	lda Num1+2
	sta addr+2
	lda Num1
	sta addr
	jsr getword
	sta Num1
	rts

*
* isCaret -- do 3-byte indirection
*
isCaret	name
	lda Num1+2
	sta addr+2
	lda Num1
	sta addr
	jsr getword
	pha
	ldy #2
	jsr getwordY
	sta CurBank
	pla
	sta Num1
	rts

*
* > -- set variable
*
svErr	name
	pushlong #svError
	_WriteCS
	rts
svError	dc.b 'variable name should follow ">"',cr,0
*
isSetvar	name
	jsr chrgotAdvance
	bcs svErr
	jsr upcase
	cmp #'L'
	bne vNotB
* >L
	lda Num1
	sta WhichLCBank
	rts
*
vNotB	cmp #'S'
	bne vNotS
* >S -- set output slot
	lda Num1
	jsr InitOutput
	rts
*
vNotS	cmp #'U'
	bne vNotU
* n>U (user tools)
	lda Num1
	beq useSysTools
	lda #$8000
	sta WhoseTools
	lda #secUserTool
	sta WhoseSec
	rts
useSysTools
	stz WhoseTools
	lda #secSysTool
	sta WhoseSec
	rts
*
vNotU	cmp #'X'
	bne vNotX
	jsr YesNoOpt
	sta xflag
	rts
*
vNotX	cmp #'M'
	bne vNotM
	jsr YesNoOpt
	sta mflag
	rts
*
vNotM	cmp #'A'
	bne vNotA
	jsr YesNoOpt
	sta AutoTrk
	rts
*
vNotA	cmp #'H'
	bne vNotH
	lda Num1
	cmp #3
	bcc @ok
	lda #2
@ok	sta WhichHList
	rts
*
vNotH	cmp #'P'
	bne vNotP
	lda Num1
	beq setDefPS
	cmp #8
	bcc setpSlot
setDefPS	lda #1
setpSlot	sta PrinterSlot
	rts
*
vNotP	cmp #'R'
	bne vNotR
	jsr YesNoOpt
	sta enableF8ss
	rts

vNotR	cmp #'D'
	bne vNotD
	lda Num1
	and #3
	sta DataFlags
	and #2	;set purge level to 0 or 2
	ldx DataHandle+2
	beq dDun
	pha
	pushlong DataHandle
	_SetPurge
dDun	rts

vNotD	cmp #'C'
	bne vNotC
	jsr YesNoOpt
	sta enableAbbrH
	rts

vNotC	cmp #'V'
	bne vNotV
	jsr YesNoOpt
	sta voiceFlag
	rts

vNotV
	brl svErr
*
YesNoOpt	name
	lda Num1
	beq noOpt
	lda #$ffff
noOpt	rts
*********************************************
isParam	name
	pushlong #CurrSettings
	_WriteCS
	ldx #'m'
	lda mflag
	jsr dispYN
	ldx #'x'
	lda xflag
	jsr dispYN
	ldx #'L'
	lda WhichLCBank
;;;	jsr dispYN
	jsr disp1p	;28-Aug-92 DAL
	ldx #'a'
	lda AutoTrk
	jsr dispYN
	ldx #'h'
	lda WhichHList
	jsr disp1p
	ldx #'u'
	lda WhoseTools
	jsr dispYN
	ldx #'p'
	lda PrinterSlot
	jsr disp1p
	ldx #'r'
	lda enableF8ss
	jsr dispYN
	ldx #'d'
	lda DataFlags
	jsr disp1p
	jsr crout
	ldx #29
	jsr PrintXBlanks
	ldx #'c'
	lda enableAbbrH
	jsr dispYN
	ldx #'v'
	lda voiceFlag
	jsr dispYN
	brl crout
*
dispYN	name
	phx
	and #$8000
	bne dispY1
	lda #'0'
	jsr cout
	bra disp2
dispY1	lda #'1'
	jsr cout
	bra disp2
*
disp1p	phx
	ora #'0'
	jsr cout
disp2	lda #'>'
	jsr cout
	pla
	jsr cout
	brl spout2
*
CurrSettings	dc.b 'Parameters (use ''>'' to set): ',0
*********************************************
CondTool	name
	lda WhoseTools
	bne @uCall
	jmp Tool
@uCall	jmp UserTool

*********************************************
*
* S)tatus command
*
*********************************************
isStatus	name
	jsr CheckP16
	bcs noP16
	jsr prP16info
noP16	brl mmInfo
*
prP16info	_GET_NAME infoparms
	bcs prNameErr
	pushlong #P16appl
	_WriteCS
	jsr PrInfoBuff
prNameErr
*
	_GET_VERSION infobuff
	bcs prVerErr
	pushlong #P16vers
	_WriteCS
	lda infobuff+1
	and #$000f
	ora #'0'
	jsr cout
	lda #'.'
	jsr cout
	lda infobuff
	and #$000f
	ora #'0'
	jsr cout
	lda infobuff
	bpl notProto
	lda #'P'
	jsr cout
notProto	jsr crout
prVerErr
*
	_GET_LEVEL levelparms
	bcs PrLevErr
	pushlong #LevelStr
	_WriteCS
	lda levelparms
	jsr prword
PrLevErr
*
	_GetSysPrefsGS prefsparms
	bcs PrefsErr
	pushlong #PrefsStr
	_WriteCS
	lda prefsparms+2
	jsr prword
PrefsErr
*
	_SessionStatusGS sessnparms
	bcs SessnErr
	pushlong #SessnStr
	_WriteCS
	lda sessnparms+2
	jsr prword
	jsr crout
SessnErr

* is the Resource Manager here?

	pea 0
	_ResourceStatus
	pla
	beq noResMgr

	pushlong #curResApp
	_WriteCS
	pea 0
	_GetCurResourceApp
	pla
	jsr prword
*
	pushlong #curResFile
	_WriteCS
	pea 0
	_GetCurResourceFile
	pla
	jsr prword
*
	pushlong #curResDepth
	_WriteCS
	pea 0
	pea 0
	_SetResourceFileDepth
	pla
	jsr prword
noResMgr	jsr crout
* show "@" prefix if possible
	lda #$fd
	sta InfoBuff
	_ExpandPathGS atPfxParms
	bcs @atPfxEr
	pushlong #AtPfxMsg
	_WriteCS
	lda InfoBuff+2
	sta atShowP
	pushlong #atShowP
	pea nlShowText
	jsl NLService
	jsr crout
@atPfxEr
*
	_GET_BOOT_VOL infoparms
	bcs gbvErr
	pushlong #P16bv
	_WriteCS
	jsr PrInfoBuff
gbvErr
*
	lda #0
PrNxtPfx	pha
	jsr PrintOnePfx
	pla
	inc a
	bcc PrNxtPfx
prP16err	rts
*
PrintOnePfx	name
	sta P16pfxNum
	cmp #32
	bcs did1pfx
*
	pha
	pushlong #P16Pfx+2
	pea 2		; --> 2 characters
	pea 0		;unsigned
	_Int2Dec
*
	stz InfoBuff
*** 25-Jan-93 DAL -- change from GET_PREFIX to GetPrefixGS
;	_GET_PREFIX P16pfxNum
;	bcs did1pfx
;	lda InfoBuff
;	and #$00ff
;	beq did1pfx

	lda #514
	sta ibLength
	_GetPrefixGS getPfxGSParms
	bcs did1pfx
	lda InfoBuff
	beq did1pfx

	pushlong #P16pfx
	_WriteCS

;	jsr PrInfoBuff
	jsr PrInfoBuffW
*** end 25-Jan-93

	clc
did1pfx	rts
*
atPfxParms	dc.w 3
	dc.l atPfx, InfoBuff
	dc.w 0	;upcase flag
atPfx	dc.b 2,0,'@:'
atShowP	dc.w 0
	dc.l InfoBuff+4
*
getPfxGSParms	dc.w 2
P16pfxNum	DC.W 0
	DC.L ibLength
*
P16appl	dc.b '      GET_NAME: ',0
P16vers	dc.b 'P16|GS/OS vers: ',0
LevelStr	dc.b '     GET_LEVEL: $',0
PrefsStr	dc.b '     GET_SYS_PREFS: $',0
SessnStr	dc.b '    SESSION_STATUS: $',0
curResFile	dc.b '    Resource file:  $',0
curResApp	dc.b 'Resource appl:  $',0
curResDepth	dc.b '    Resource depth: $',0
atPfxMsg	dc.b '   @: = ',0
P16bv	dc.b '   *: = ',0
P16pfx	dc.b '  __: = ',0
*
RomVStr	dc.b '   ROM Version:     $',0
mmkFree	dc.b '      Free RAM: ',0
mmkRfree	dc.b ' Real free RAM: ',0
mmkMaxb	dc.b ' Largest block: ',0
mmkTotal	dc.b '     Total RAM: ',0
msgMyID	dc.b ' Nifty List ID:    ',0
msgNLSrv	dc.b '   nlService: ',0
*
levelparms	ds.b 2
prefsparms	dc.w 1
	ds.b 2
sessnparms	dc.w 1
	ds.b 2
*
mmInfo	name
	jsr crout
	pushlong #RomVStr
	_WriteCS
	jsr GetRomV
	jsr prbyte
	jsr crout
*
	pushlong #mmkFree
	_WriteCS
	pha
	pha
	_FreeMem
	plx
	pla
	jsr PrintK
*
	pha
	_MMVersion
	pla
	and #$0fff	;was $7fff 7-Jan-91 DAL
	cmp #$0202
	bcc rfmNO
	pushlong #mmkRfree
	_WriteCS
	pha
	pha
	_RealFreeMem
	plx
	pla
	jsr PrintK
rfmNO
*
	pushlong #mmkMaxb
	_WriteCS
	pha
	pha
	_MaxBlock
	plx
	pla
	jsr PrintK
*
	pushlong #mmkTotal
	_WriteCS
	pha
	pha
	_TotalMem
	plx
	pla
	jsr PrintK
*
	pushlong #msgMyID
	_WriteCS
	lda MyID
	and #$f0ff
	jsr prword
	pushlong #msgNLSrv
	_WriteCS
	lda JumpService+3
	jsr prbyte
	lda JumpService+1
	jsr prword
	jmp crout
*
NumK	DC.L 0
*
PrintK	name
	sta NumK+2
	stx NumK
	ldx #10
div1024	lsr NumK+2
	ror NumK
	dex
	bne div1024
	lda NumK+2
	pha
	lda NumK
	pha
	pushlong #InfoBuff
	pea 6		;length
	pea 0		;unsigned
	_Long2Dec
	lda #6
	sta ibLength
	pushlong #ibLength
	pea cbWrite
	jsl doCallBack
	lda #'K'
	jsr cout
	brl crout
*
PrInfoBuffW	name
	pushlong #InfoBuff
	pea nlShowWString
	bra toService

PrInfoBuff	name
	pushlong #InfoBuff
	pea nlShowStr
toService	jsl NLService
	brl crout
*
infoparms	DC.L InfoBuff
ibLength	dc.w 0
InfoBuff	DS.B 512	;long enough for a prefix (was 256, 25-Jan-93 DAL)
tempsave	equ InfoBuff	;used by Visit Monitor cmd
*
* get ROM version
*
GetRomV	name
	pha
	pha
	pha
	pha
	pha
	pha
	pha
	pea $FE1F
	_FWEntry
	pla
	ply
	ply
	ply
	rts

*
* # -- set default addr to HandyAddr
*
isPrevNum	name
	lda HandyAddr+2
	and #$00ff
	ldx HandyAddr
	sta CurBank
	sta Num1+2
	stx Num1
	rts

*
* * -- enter monitor; Ctrl-Y to return
*
monS	DC.W 0
oldctrlY	DS.B 3
old3d0	DS.B 3
*
isMonitor	name
	jsr CheckPrimarySess
	beq @ok
	brl PrintEhMsg
@ok	pushlong #MonMsg
	_WriteCS
*
	jsr TxtGetCursorV
	sep #$20
	sta >$000025
	rep #$20
*
	ldx #$fe
mSave	lda >$200,x
	sta tempsave,x
	dex
	dex
	bpl mSave
	ldx #14
mSave2	lda MonCode,x
	sta >$2f0,x
	dex
	dex
	bpl mSave2
	lda >$3f8
	sta oldctrly
	lda >$3f9
	sta oldctrly+1
	lda >$3d0
	sta old3d0
	lda >$3d1
	sta old3d0+1
	lda #$4c		;JMP opcode
	sta >$3f8
	sta >$3d0
	lda #$2f8
	sta >$3f9
	sta >$3d1
*
	phd
	phb
	tsc
	sta monS
	lda #0
	tcd
	pha
	plb
	plb
	jmp >$2f0

MonReturn	name
	rep #$30
	lda >monS
	tcs
	plb
	pld
*
	ldx #$fe
mFix	lda tempsave,x
	sta >$200,x
	dex
	dex
	bpl mFix
	lda oldctrly
	sta >$3f8
	lda oldctrly+1
	sta >$3f9
	lda old3d0
	sta >$3d0
	lda old3d0+1
	sta >$3d1
*
	pla		;return addr for '*' command
	brl reinit
*
MonCode	sec
	xce
	jmp $ff69
	nop
	nop
	nop
	clc
	xce
	jmp >MonReturn
*
* M (toggle M flag for List)
*
isM	name
	lda mflag
	eor #$8000
	sta mflag
	rts
*
* X (toggle X flag for List)
*
isX	name
	lda xflag
	eor #$8000
	sta xflag
	rts

*********************************************************
*
* (") command -- print info on all tools with names containing
*                a given string
*
*********************************************************
QuoteIdx	dc.w 0
QuoteLen	dc.w 0
UnderscoreFlag	dc.w 0
srchTarget	dc.l 0
*
isQuote	name
	lsr UnderscoreFlag
	lda #Buffer>>16
	ldy #Buffer
	sta srchTarget+2
	sty srchTarget
	lda index
	sta QuoteIdx
	lda NumChars
	sta index
	sec
	sbc QuoteIdx
	sta QuoteLen
* upcase the quoted characters  --15-May-88 DL for v2.3
	ldy index
	sep #$20
upc1	lda buffer,y
	jsr upcase8
	sta buffer,y
	dey
	cpy QuoteIdx
	bpl upc1
	rep #$20
*
	lda #SecP8
	jsr QtSecA
	lda #SecP16
	jsr QtSecA
	lda #Sec01vec
	jsr QtSecA
	lda #SecE0vec
	jsr QtSecA
	lda #SecE1vec
	jsr QtSecA
	lda WhoseSec	;system or user tools
	jsr QtSecA
	lda #SecF8andSS
	jsr QtSecA
	lda #SecNLService
	jsr QtSecA
	lda #SecResTypes
	jsr QtSecA
	lda #SecErrors
	jsr QtSecA
	lda #SecHyperCard	;13-Jan-91 DAL
	jsr QtSecA
	lda #SecReqCode	;21-Aug-91 DAL
*	jsr QtSecA
*	rts
*  |||	     |||
*  vvv   fall thru  vvv
*
* (UnderscoreFlag has already been set or cleared)
* QuoteIdx, QuoteLen, and srchTarget are set, too.
*
QtSecA	name
	lsr uAbort
	sta QuoteSec
	asl a	;double sec #
	asl a	;quadruple section # (27-May-91 DAL)
	tay
* If we have no data, do nothing
	lda DataPtr+2
	ora DataPtr
	bne SomeQData
	rts

SomeQData	phd 	;store dirpage
	pha 	;will be dp 11
	pha 	;will be dp 9
	pha 	;will be dp 7
	pha 	;will be dp 5
	pushlong DataPtr
	tsc
	tcd	;dir page now on stk

***	lda [1],y	;head of linked list for sec
***	tay
*** 27-May-91 DAL
	iny
	iny
	lda [1],y
	tax
	dey
	dey
	lda [1],y
	clc
	adc <1
	sta <1
	txa
	adc <3
	sta <3
	ldy #0
*** end of 27-May-91 DAL

	jsr isQuote2
	pla	;get rid of DataPtr
	pla	;get rid of DataPtr+2
	pla	;was dp 5
	pla	;was dp 7
	pla	;was dp 9
	pla	;was dp 11
	pld	;restore dir page
	rts
*
isQuote2	name
iq2loop	phy
	jsr iqMaybeThis
	ply
	bit uAbort
	bmi @x
	iny
	iny
	lda [1],y
	tay
	bne iq2loop
@x	rts
*
* search for string at Buffer[QuoteIdx;QuoteLen] in [1],y+5
*
iqY	DC.W 0

iqMaybeThis	name
	sty iqY
	clc
	lda srchTarget
	adc QuoteIdx
	sta 5
	lda srchTarget+2
	adc #0
	sta 7
*
	clc
	tya
	adc 1
	sta 9
	lda 3
	adc #0
	sta 11
	clc
	lda 9
	adc #5
	sta 9
	bcc @a
	inc 11
@a
	jsr find5in9
	bcc iqThis
	rts
*
iqThis	name
	ldy iqY
	lda [1],y
	bit UnderscoreFlag
	bmi @undersc
	jsr QtDescribe
	brl crout
@undersc	sta uFoundValue
	clc
	tya
	adc 1
	sta uFoundAddr
	lda 3
	adc #0
	sta uFoundAddr+2
	sec
	ror uAbort
	rts

uAbort	dc.w 0

*
* QtDescribe--print description of an entry found by the (") command
* (multi-way dispatch based on the section number)
*
QtDT	brl OneTool
QtDescribe	name
	ldx QuoteSec
	cpx #SecSysTool
	beq QtDT
	cpx #SecUserTool
	beq QtDT
	cpx #SecHyperCard	;13-Jan-91 DAL
	beq QtHCGS	;13-Jan-91 DAL/MD
	cpx #Sec01Vec
	beq Qt01
	cpx #SecE1Vec
	beq QtE1
	cpx #SecE0Vec
	beq QtE0
	cpx #SecP8
	beq QtPro
	cpx #SecP16
	beq QtPro
	cpx #SecF8andSS
	beq QtF8SS
	cpx #SecNLService
	beq QtNLService
	cpx #SecResTypes
	beq QtResTypes
	cpx #SecErrors
	beq QtErrors
	cpx #SecReqCode
	beq QtReqCode
* should never get here
@NeverGetHere	rts
*
QtE1	ldy #$E1
	bra QtYY
QtE0	ldy #$E0
	bra QtYY
Qt01	ldy #$01
QtYY	pha
	tya
	jsr prbyte
	lda 1,s
	bra QtPrW
*
QtHCGS
QtErrors
QtReqCode
QtF8SS
QtNLService
QtResTypes
QtPro	pha
QtPrW	jsr prword
	plx
FndPrntB	lda QuoteSec
	brl FindPrint
*
* find5in9 -- find string at [5]/len=QuoteLen in string
*             at [9], 0-terminated.  Return CLC=found
*
find5in9	name
	sep #$30
	longa off
	longi off
	ldx QuoteLen
	beq f59yes
f59again	lda [9]
	beq f59no
	ldy #0
	ldx QuoteLen
f59L1	lda [9],y
	beq f59failTest
	cmp #'a'		;made inline 1-Apr-90 DL
	bcc @isUp
	cmp #'z'+1
	bcs @isUp
	and #$5f
@isUp	cmp [5],y
	bne f59fail1
	iny
	dex
	bne f59L1
	bra f59yes
*
f59failTest	lda [5],y
	beq f59yes	;if we hit a $00 on both strings, we found it
f59fail1	rep #$30
	bit UnderscoreFlag
	bmi f59no	;for "_", must begin at beginning
	inc 9
	bne ok9
	inc 11
ok9	sep #$30
	bra f59again
*
f59no	sec
	rep #$30
	rts
f59yes	clc
	rep #$30
	rts
	longa on
	longi on

***********************************************************************
*
* Tool command -- print info about a particular tool call
*
* If high byte is $00, print info about ALL tools in the specified
* toolset.
*
* If whole word is 0, prints system/user tool table/WAPT ptrs
*
***********************************************************************
AnchorsMsg	dc.b '    Sys  TPT    User TPT    Sys WAPT   User WAPT',cr,0
AnchMsg2	dc.b '    --------    --------    --------   ---------',cr,0
*
isTool	name
	lda Num1
	bne isTnz
*
* 0t --> print system/user tool table/WAPT ptr
*
	pushlong #AnchorsMsg
	_WriteCS
	pushlong #AnchMsg2
	jsr WriteNoVoice
	ldx #0
Anch1	phx
	lda >$E103C0,x
	pha
	lda >$E103C2,x
	pha
	ldx #4
	jsr PrintXBlanks
	pla
	jsr prword
	pla
	jsr prword
	plx
	inx
	inx
	inx
	inx
	cpx #16
	bcc Anch1
	brl crout
*
isTnz	and #$ff00
	bne just1
	brl AllTools
just1	lda Num1
	jsr OneTool
	jsr crout
	pushlong #tsetmsg
	_WriteCS
	lda Num1
	and #$00ff
	tax
	lda WhoseSec	;system/user data section
	jsr FindPrint
	brl crout
tsetmsg	dc.b '     Toolset:',0

*
OneTool	name
	sta ThisTool
	jsr prword
	jsr spout2
	jsr ParenToolAddr
	lda WhoseSec	;system or user data section
	ldx ThisTool
	jsr FindPrint
	lda #' '
	sta fpPadChar2
	rts
*
ParenToolAddr	name
	lda #'('
	jsr cout
* find the tool's address
	lda ThisTool
	beq @useTPT

	lda #-1
	pha	;space
	pha	;for long (GetTSPtr)
	lda WhoseTools	;system/user tools
	pha
	lda ThisTool
	pha	;desired func
	and #$ff00
	bne gToolPt
	jsr myGetTSPtr	;func 0 --> FPT
	bra tNoInc

@useTPT	lda >SystemTPT
	tax
	lda >SystemTPT+2
	ldy WhoseTools
	bpl @thisTPT
	lda >UserTPT
	tax
	lda >UserTPT+2
@thisTPT	pha
	phx
	bra tNoInc

gToolPt	_GetFuncPtr
	lda 1,s
	clc
	adc #1
	sta 1,s
	lda 3,s
	adc #0
	sta 3,s
tNoInc	lda 1,s
	sta HandyAddr
	lda 3,s
	sta HandyAddr+2
	jsr prbyte
	pla
	jsr prword
	pla
	lda #')'
	jsr cout
*** added 6-Nov-91 DAL -- no pad character for user tool sets
	lda #' '
	bit WhoseTools
	bmi @noPad
*** end 6-Nov-91 DAL
*** added 30-May-91 DAL -- display a character for the tool address
	pha
	pha
	pushlong HandyAddr
	pea nlClassifyAddr
	jsl NLService
	pla	;throw away class code
	pla	;class character
@noPad	sta fpPadChar2
*** end of 30-May-91 DAL
	rts

ThisTool	DC.W 0
CurFunc	DC.W 0
NumFuncs	DC.W 0

*
* myGetTSPtr
*
* In:  WhoseTools, stack=WhoseTools,Toolset#
* Out: stack=pointer (nil if invalid toolset)
*
myGetTSPtr	name
	plx
	stx @rts
	jsr CountToolsets
	cmp 1,s	;toolset #
	php
	php
	pla
	sta @flags
	_GetTSPtr
	lda @flags
	pha
	plp
	plp
	bcc @outrange
	beq @outrange
@out	ldx @rts
	phx
	rts

@outrange	lda #0
	sta 1,s
	sta 3,s
	bra @out

@rts	dc.w 0
@flags	dc.w 0
*
* CountToolsets
*
* In:  WhoseTools (system or user)
* Out: A=number of toolsets + 1
*
CountToolsets	name
	phd
	lda >$E103C0
	tax
	lda >$E103C2
	bit WhoseTools
	bpl @cntSysT
	lda >$E103C4
	tax
	lda >$E103C6
@cntSysT	pha
	phx
	tsc
	tcd
	lda [1]
	plx
	plx
	pld
	rts

*
* AllTools
*
AllTools	name
*
* If the toolset not loaded, pretend there are a lot of functions,
* so we can see all the names.
*
	jsr CountToolsets
	cmp Num1
	bcc wasZeroF
	beq wasZeroF
*
	lda #0
	pha
	pha
	lda WhoseTools	;system/user
	pha
	lda Num1
	and #$00ff	;which toolset?
	pha
	jsr myGetTSPtr	;2-Dec-90 DAL
	phd
	tsc
	tcd
	lda [3]
	pld	;8-Mar-90 DAL  was down below,
	ply	;8-Mar-90 DAL  misplaced
	ply	;8-Mar-90 DAL
	tay	;8-Mar-90 DAL
	bne notZeroF
wasZeroF	lda #$ff
notZeroF	dec a
*	dec a
	sta NumFuncs
	lda Num1
*	ora #$0100
	sta CurFunc
AllT1	lda NumFuncs
	bmi AllTdone
	lda CurFunc
	jsr OneTool
	jsr crout
	lda CurFunc
	clc
	adc #$0100
	sta CurFunc
	dec NumFuncs
	bra AllT1
AllTdone	rts
*
* Version command -- print names/versions of all locatable toolsets
*
isVersion	name
	lda #0
verLoop	inc a
	pha
	jsr ToolVers
	pla
	bcc verLoop
	lda #$00ff	;25-Oct-90 DAL
	jsr ToolVers	;25-Oct-90 DAL
	rts
*
* ToolVers -- print version line for toolset (# in A)
* (Return SEC if tool locator says there aren't that many toolsets)
*
ToolVers	name
	sta vTemp
	jsr GetTVer
	cmp #1		;past last toolset
	beq tvDun
	cmp #2		;no 'version' call
	beq tvSkip
	phx		;save version
	lda vTemp
	jsr prbyte
	jsr spout2
	lda vTemp
	jsr chkStatus
	jsr spout
	lda #'v'
	jsr cout
	pla	;version
	jsr prword

	lda vTemp
	cmp #$00ff
	bne @notToolFF

	ldx #28	;for Debugger, just print FF/version/name
	jsr PrintXBlanks
	bra tsName

@notToolFF	jsr spout
	lda vTemp
	jsr CountRamRom
	jsr spout
	jsr PrintWAP
	jsr spout
tsName	ldx vTemp
	lda WhoseSec	;system/user data section
	jsr FindPrint
	jsr crout
	clc
tvDun	rts
*
tvSkip	lda vTemp	;2-Dec-90: for missing toolsets, show number/name
	jsr prbyte
	ldx #28+9
	jsr PrintXBlanks
	bra tsName
*
vTemp	dc.w 0
*
PrintWAP	name
	pushlong #WapMsg
	_WriteCS
	lda #0
	pha
	pha
	lda WhoseTools
	pha
	lda vTemp	;toolset
	pha
	_GetWAP
	lda 3,s
	jsr prword
	pla
	jsr prword
	pla
	rts
*
WapMsg	dc.b 'WAP=',0
*
* GetTVer--return A=error, X=version
*
GetTVer	name
	ora #$0400	;Version
	tax
	phy	;be paranoid about bad toolsets
	pea 0
	jsl CondTool
	plx
	ply	;finish being paranoid
	rts
*
* chkStatus -- print a character indicating whether
*              ts # A is active, inactive, or what
*
chkStatus	name
	ora #$0600	;status
	tax
	phy	;be paranoid
	pha	;space
	jsl CondTool
	plx	;x=status
	ply
	bcc stNoErr	;30-Nov-90 DAL
***	cmp #0
***	beq stNoErr
	cmp #$10
	bcc stDead
	lda #'?'
	bra cout00
stNoErr	cpx #0
	beq stOff
	lda #'+'	;nonzero=active
	bra cout00
stOff	lda #'-'
	bra cout00
stDead	lda #'*'
cout00	brl cout
*
* CountRamRom -- print number of tool functions in
*                RAM and in ROM for toolset A
*
*    RAM=xx ROM=xx
*
CountRamRom	name
	tax
	pha	;space for
	pha	; long result
	lda WhoseTools
	pha
	phx	;desired set
	_GetTSPtr
	phd
	tsc
	tcd	;TS ptr is now 3 on DP
	jsr CountRR
	pld
	pla	;pull
	pla	;long
	clc
	rts
*
rrRAM	DC.W 0
rrROM	DC.W 0
CountRR	stz rrRAM
	stz rrROM
	lda [3]	;num funcs + 1
	beq rrNone
	dec a
	beq rrNone
	asl a
	asl a
	tay
	iny	;looking at high word only
	iny
CntRRlp	lda [3],y
	and #$00ff
	cmp #$00f0	;in ROM?
	inc rrRAM
	bcc cntRam
	inc rrROM
	dec rrRAM
cntRam	dey
	dey
	dey
	dey
	cpy #3
	bpl CntRRlp
rrNone	pushlong #msgRAM
	_WriteCS
	lda rrRAM
	jsr prbyte
	pushlong #msgROM
	_WriteCS
	lda rrROM
	brl prbyte
*
msgRAM	DC.B 'RAM=',0
msgROM	DC.B ' ROM=',0

***********************************************************
*
* isIDInfo -- print info on specified memory ID
*
*********************************************************
TargetID	dc.w 0
TargetAttr	dc.w 0
AttrFlag	dc.w 0
*
isIDInfo	name
	jsr PrintHeader
	lda Num1
	sta TargetID

	lda RangeFlag
	sta AttrFlag
	lda RangeSt
	sta TargetAttr

	lda WhichHList
	asl a
	asl a
	tax
	lda FirstHandle,x
	tay
	lda FirstHandle+2,x
	pha
	phy
	tsc
	phd
	tcd
*
MemID1	lda 1
	ora 3
	beq MemIDdone
	ldy #hID
	lda [1],y
	jsr CompareToTarg
	bcs MemNext
	ldy #hFlags
	lda [1],y
	jsr CompareAttr
	bcs MemNext
	lda 3
	ldx 1
	jsr PrHandInfo
* print free space if target id=0
	lda TargetID
	bne MemNext
	lda AttrFlag
	bne MemNext
	lda WhichHList
	bne MemNext
	jsr prFreeSpace
MemNext	jsr NextHand
	brl MemID1
*
MemIDdone	pld
	pla
	pla
	rts
*
* show size of gap between two handles
*
prFreeSpace	name
	lda [1]
	clc
	ldy #hLength
	adc [1],y
	sta gapAddr
	ldy #2
	lda [1],y
	ldy #hLength+2
	adc [1],y
	sta gapAddr+2
	pei 3
	pei 1
	jsr NextHand
	lda 2
	beq noNextHand
	sec
	lda [1]
	sbc gapAddr
	sta gapSize
	ldy #2
	lda [1],y
	sbc gapAddr+2
	sta gapSize+2
	pla
	sta 1
	pla
	sta 3
	lda gapSize+2
	ora gapSize
	bne someFreeSp
	rts

noNextHand	pla
	sta 1
	pla
	sta 3
	rts

someFreeSp	ldx #7
	jsr PrintXBlanks
	lda gapAddr+2
	jsr prbyte
	lda gapAddr
	jsr prwordSpout
	lda gapSize+2
	jsr prbyte
	lda gapSize
	jsr prword
	pushlong #freeSpMsg
	_WriteCS
	jmp crout

gapSize	dc.l 0
gapAddr	dc.l 0
freeSpMsg	dc.b ' --free--',0
*
* advance <1 to next handle in chain
*
NextHand	name
	ldy #hNext+2
	lda [1],y
	tax
	dey
	dey
	lda [1],y
	sta 1
	stx 3
	rts

CompareToTarg	name
	sta ThisID
	lda #$f000
	jsr CompSect
	bcs DidCmpID
	lda #$0f00
	jsr CompSect
	bcs DidCmpID
	lda #$00ff
	jsr CompSect
DidCmpID	rts

CompSect	sta cmpMask
	and TargetID
	beq csOK
	sta tempID
	lda ThisID
	and cmpMask
	cmp tempID
	beq csOK
	sec
	rts
csOK	clc
	rts
*
CompareAttr	name
	bit AttrFlag
	bpl csOK
	cmp TargetAttr
	beq csOK
	sec
	rts
*
ThisID	DC.W 0
cmpMask	DC.W 0
tempID	DC.W 0

***********************************************************
*
* isWhatHand -- find handle and print info on it
*
*********************************************************
isWhatHand	name
	pha
	pha
	lda Num1+2
	ldx Num1
	pha
	phx
	_FindHandle
	bcs isWhatErr
	lda 1,s
	bne whNotNil
	lda 3,s
	bne whNotNil
	pla
	pla
NotAllocated	pushlong #NotAlloc
	_WriteCS
	rts
whNotNil	jsr PrintHeader
	plx
	pla
	brl PrHandInfo
*
isWhatErr	pla
	pla
	brl isHerr
*
* isHandle -- print info on specified handle
*
isHandle	name
	lda Num1+2
	ldx Num1
	pha
	phx
	_CheckHandle
	bcs isHerr
*
	jsr PrintHeader
	lda Num1+2
	ldx Num1
	brl PrHandInfo
*
isHerr	pushlong #BadHand
	_WriteCS
	rts
*
BadHand	dc.b 'not handle',cr,0
***********************************************************
*
* PrHandInfo -- print a line of info on handle at A,X
*
*********************************************************
PrHandInfo	name
	pha
	phx
	tsc
	phd
	tcd
*
	lda 3	;print handle addr
	jsr prbyte
	lda 1
	jsr prwordSpout
*
	ldy #2	;print data addr
	lda [1],y
	sta HandyAddr+2
	jsr prbyte
	lda [1]
	sta HandyAddr
	jsr prwordSpout
*
	ldy #hLength+2	;print data size
	lda [1],y
	jsr prbyte
	ldy #hLength
	lda [1],y
	jsr prwordSpout
*
	ldy #hFlags
	lda [1],y
	jsr prwordSpout
*
	ldy #hID	;print owner ID
	lda [1],y
	jsr prwordSpout
*
	ldy #hID
	lda [1],y
	jsr PrintIDinfo
	bcc @gotPath
	jsr ScroungeInfo
@gotPath	lda 3
	ldy 1
	jsr PrintResInfo
*
	pld
	pla
	pla
	rts
*
* PrintIDinfo -- print the owner of an ID (A)
*
infoid	dc.w 0

PrintIDinfo	name
	sta infoid
	tax
	beq @zero
* just return with SEC if we don't think the loader
* knows the pathname anyway
	and #$f000
	beq @zero	;$0xxx
	cmp #$7000	;$7xxx
	beq @zero
	cmp #$9000	;$9xxx
	beq @zero
	lda infoid
*
	tax
	jsr PrIdInfo2
	bcc @done

	lda infoid	;if it fails, try ID&$F0FF if NOT $4xxx
	and #$f000
	cmp #$4000
	beq @zero

	lda infoid
	tax
	and #$f0ff
	sta infoid
	jsr PrIdInfo2
	bcc @done
@zero	sec
	rts
@done	jsr crout
	clc
	rts
*
* Print pathname for ID in A (use LGetPathname2).
* Return BCC if we printed something.
* Don't print a CR.
*
* If we're called with the same value we were called
* with last time, don't bother calling LGetPathname2.
*
PrIdInfo2	name
	stx theIDToCache
	jsr ReadPathCache
	bcs @1
	pha
	phy
	bra WriteOwner2

@1	pha
	pha
	pha	;MemID
	pea 1
	_LGetPathname2
	bcc CacheWriteOwner2
	cmp #$10
	bcs @didCall
	pla
	pla	;remove input parameters
@didCall	pla
	pla
	sec
	rts

CacheWriteOwner2	name
	lda 1,s
	tay
	lda 3,s
	ldx theIDToCache
	jsr SetPathCache

WriteOwner2	name
	phd
	tsc
	tcd
* strip off until last segment of pathname
	lda [3]
	beq @nulfail
	tay
	iny
	iny
@srchCol	dey
	cpy #2
	beq @dun
	lda [3],y
	and #$00ff
	cmp #':'
	bne @srchCol
	iny
@dun	tya
	dec a
	dec a
	eor #$ffff
	inc a
	clc
	adc [3]

	sta ownerBuff	;7-Aug-90 DAL
	clc
	tya
	adc 3
	sta ownerBuff+2
	lda 5
	adc #0
	sta ownerBuff+4
	pushlong #ownerBuff
	pea nlShowText
	jsl NLService	;buff --> length, pointer
	pld
	pla
	pla
	clc
	rts
*
@nulfail	pld
	pla
	pla
	sec
	rts

ownerBuff	ds.b 6

theIDToCache	dc.w 0

*
* X=id, AY=pointer
*
SetPathCache	name
	stx cachedID
	sta cachedPtr+2
	sty cachedPtr
	sec
	ror cacheValid
	rts
*
* ReadPathCache (A=id, output=Carry,A/Y)
*
ReadPathCache	name
	bit cacheValid
	bpl @nope
	cmp cachedID
	bne @nope
	lda cachedPtr+2
	ldy cachedPtr
	clc
	rts
@nope	sec
	rts

*
* InvalidatePathCache
*
InvalidatePathCache	name
	lsr cacheValid
	rts

cacheValid	dc.w 0
cachedID	dc.w 0
cachedPtr	dc.l 0

*********************************************************
*
* The loader doesn't know about this block--just print
* its generic type from its memory manager id.
*
* Handle at 1.
*
*********************************************************
ScroungeInfo	name
	ldy #hID
	lda [1],y
*
* special-case $41xx and $42xx
*
	and #$ff00
	ldx #$20
	cmp #$4100
	beq @GotIt
	ldx #$22
	cmp #$4200
	beq @GotIt
*
;	ldy #hID
	lda [1],y
	xba
	lsr a
	lsr a
	lsr a
	and #$001e
	tax
@GotIt	pea IDTable>>16
	lda IDTable,x
	pha
	_WriteCS
	brl crout

IDTable	dc.w id0,id1,id2,id3,id4,id5,id6,id7
	dc.w id8,id9,idA,idB,idC,idD,idE,idF
	dc.w id41,id42

id0	dc.b '(memory manager)',0
id1	dc.b '(application)',0
id2	dc.b '(control program)',0
id3	dc.b '(GS/OS)',0
id4	dc.b '(toolbox)',0
id5	dc.b '(desk accessory)',0
id6	dc.b '(runtime library)',0
id7	dc.b '(loader)',0
id8	dc.b '(firmware)',0
id9	dc.b '(tool locator)',0
idA	dc.b '(initialization file)',0
idB
idC
idD
idE
idF	dc.b '(?)',0
id41	dc.b '(misc tools)',0
id42	dc.b '(scrap manager)',0

*********************************************************
*
* PrintResInfo on handle in AY, setting the resource
* application to the handle's memory ID first.
*
*********************************************************
PrintResInfo	name
	sta matchHandle+2
	sty matchHandle

	pea 0
	_ResourceStatus
	pla
	beq @done

	pha
	_GetCurResourceApp
	pushlong matchHandle
	phd
	tsc
	tcd
	ldy #6
	lda [3],y
	pld
	plx
	plx
	pha
	_SetCurResourceApp
	jsr prResInfo2
	_SetCurResourceApp
@done	rts

matchHandle	dc.l 0

prResInfo2	stz resFile	;17-Oct-91 DAL
	pushlong #resType+$80000000  ;bit 31 for resFile, 17-Oct-91 DAL
	lda matchHandle+2
	ldy matchHandle
	pha
	phy
	_MatchResourceHandle
	bcc @didMRH
	rts

@didMRH	pushlong #resMsg
	_WriteCS
	lda resType
	jsr prword
	lda resType
	jsr prResTname
	pushlong #resMsg2
	_WriteCS
	lda resID+2
	jsr prword
	lda resID
	jsr prword
	pushlong #resMsg3
	_WriteCS

	lda resFile	;17-Oct-91 DAL
	bne @showFileNum	;17-Oct-91 DAL
	pea 0
	lda resType
	pha
	pushlong resID
	_HomeResourceFile
	pla
@showFileNum	jsr prword
*** 1-Mar-92 DAL -- don't let them abort while the CurResApp is futzed!
	lda #$0d
	jsr cout
*** end 1-Mar-92
	rts
;;;	brl crout

resType	dc.w 0
resID	dc.l 0
resFile	dc.w 0	;extra field defined in 6.0 (17-Oct-91)

resMsg	dc.b '  ResType=$',0
resMsg2	dc.b ', ID=$',0
resMsg3	dc.b ', ResFile=$',0

prResTname	tax
	lda #SecResTypes
	brl FindPrint0

*********************************************************
*
* R -- print list of resource file refnums, GS/OS refnums,
* and pathnames
*
*********************************************************
noRM	rts
isResources	name
	jsr CheckP16
	bcs noRM

;	pea 0
;	_ResourceVersion
;	pla
;	bcs @noRM
;	and #$0fff
;	cmp #$0100
;	beq ResVerOK
;
;	pushlong #resBad
;	_WriteCS
;	rts
;
;resBad	dc.b 'Need a newer Nifty List for this Resource Manager version.',cr,0
;
;ResVerOK
	pha
	_GetCurResourceApp
	lda Num1
	beq @noSet
	pha
	_SetCurResourceApp
@noSet	jsr ListResFiles2
	_SetCurResourceApp
	rts

ListResFiles2	name
	pushlong #rListHeader
	_WriteCS
	pha
	_GetCurResourceApp
	pla
	jsr prword
	jsr crout
	jsr crout

	pushlong #rList
	_WriteCS
	pushlong #rList2
	jsr WriteNoVoice
	phd
	pha
	pha
	tsc
	tcd
	pea 0
	_GetMapHandle
	bcs @done
@another	ldy #2
	lda [1],y
	tax
	lda [1]
	sta 1
	stx 3
	ldy #$12
	lda [1],y
	jsr Print1ResFile
	ldy #2
	lda [1],y
	tax
	lda [1]
	sta 1
	stx 3
	bne @another
	txa
	bne @another

@done	pla
	pla
	pld
	rts


Print1ResFile	name
	pha	;save res file id
	jsr prword
	jsr spout2
	pla
	pea 0
	pha
	_GetOpenFileRefNum
	lda 1,s
	jsr prword
	ldx #3
	jsr PrintXBlanks
	pla
	jsr PrintPathname
	brl crout

rListHeader	dc.b 'Resource files for ',0
rList	dc.b 'rFile RefNum pathname',cr,0
rList2	dc.b '----- ------ --------',cr,0

PrintPathname	name
	sta refInfoBlock+2
	jsl P16
	dc.w $2039		;get_ref_info
	dc.l refInfoBlock
	bcc @ok
	rts
@ok	pushlong #refPath+2		;7-aug-90 DAL
	pea nlShowWString
	jsl NLService
	rts

refInfoBlock	dc.w 3
	dc.w 0
	dc.w 0
	dc.l refPath

refPath	dc.w 128
	ds.b 128

*********************************************************
*
* isBackslash -- mutli-char command
*
*********************************************************
isBackslHelp	name
	sec
	bra bkCmdOrHelp
isBackslash	name
	clc
bkCmdOrHelp	ror bkHelpFlag
	ldy #32
	lda #BackCmd>>16
	ldx #BackCmd
	jsr parseIdent
	lda #BackCmd>>16
	ldx #BackCmd
	jsr UpcaseIdent
* find and execute the command
	jsr FirstModule
@nextMod	bcs @notFnd
	jsr cmdSrch1Mod
	bcc @done
	jsr NextModule
	bra @nextMod
@done	rts

@notFnd	pushlong #mcmdNotFnd
	_WriteCS
	pushlong #BackCmd
	pea nlShowStr
	jsl NLService
	jsr crout
	brl DoAbort
*
BackCmd	ds.b 33
mcmdNotFnd	dc.b 'No such command: \',0
bkHelpFlag	dc.w 0

*
* search one module for command at BackCmd, and
* execute command if found (clc=success)
*
cmdSrch1Mod	name
	phd
	phy		;space (7-8)
	phy		;space (5-6)
	jsr FindModCmdTbl
	sty @cmdTabSize
	pha
	phx
	tsc
	tcd

	bra @trynext		;skip over module's name

@next	ldy #mcName+2
	lda [1],y
	sec
	beq @done		;fail

	sta 7
	dey
	dey
	lda [1],y
	sta 5

	sep #$30
	longa off
	longi off
	lda [5]
	tay
@compare	lda [5],y
	jsr upcase8
	cmp BackCmd,y
	bne @trynext
	dey
	cpy #-1
	bne @compare
	bra @found
	longa on
	longi on

@trynext	rep #$30
	clc
	lda 1
	adc @cmdTabSize
	sta 1
	bcc @next
	inc 3
	bra @next

@found	rep #$30
	ldy #mcEntry+1
	bit bkHelpFlag
	bpl @a
	ldy #mcHelp+1
@a	lda [1],y
	tax
	dey
	lda [1],y
	phb
	jsl CallXA
	plb
	clc

@done	pla
	pla
	pla
	pla
	pld
	rts

@cmdTabSize	dc.w 0

*********************************************************
*
* PrintHeader -- print column headers for handles
*
PrintHeader	name
	pushlong #MemHdr
	_WriteCS
	pushlong #MemHdr2
	jsr WriteNoVoice
	rts

***********************************************************
*
* List (disassemble)
*
isList	name
	jsr BeginRange
	bcc ListRange
	brl doList
*
ListRange	name
	jsr List1Line
	jsr crout
	lda addr+2
	sta CurBank
	jsr CheckRange
	bcc ListRange
	rts
*
* isBank
*
IsBank	name
	lda Num1
	and #$00ff
	sta CurBank
	rts
*
* Quit (back to desk accs menu)
*
isQuit	name
	jsr chrgot
	bcs okQuit
PrintEhMsg	pushlong #msgBadQuit
	_WriteCS
	brl DoAbort

msgBadQuit	dc.b 'Eh?',cr,0

okQuit	pla		;kill return addr
	pla		;added 7-aug-90 DAL
	brl quit

*****************************************************
*****************************************************
*
* ` -- eval expression
*
* Display result as separate hex bytes, and as a string.
*
* If 4 bytes or shorter, display as hex/decimal longs,
* too.
*
isEvalExpr	name
	stz theExpr
	stz theExpr+2
	pha
	pha
	pushlong #ExprBuff
	pea nlEvalExpr
	jsl NLService
	pla
	pla
	pushlong #msgExpRes
	_WriteCS
	lda ExprSize
	jsr prword
	lda #':'
	jsr cout

	ldy #0
	ldx ExprSize
	beq @done
@next	lda theExpr,y
	and #$00ff
	jsr prbyte
	jsr spout
	iny
	dex
	bne @next
@done	pushlong #msgExpStr
	_WriteCS

	pushlong #ExprSize
	pea nlShowWString
	jsl NLService
	jsr crout

	lda ExprSize
	cmp #4+1
	bcs @skipHexDec	;longer than 4 bytes

	pushlong #msgHex	;display in hex
	_WriteCS
	lda theExpr+2
	jsr prword
	lda theExpr
	jsr prword

	pushlong #msgDec	;display in decimal
	_WriteCS

	lda theExpr+2
	pha
	lda theExpr
	pha
	pushlong #DecimalBuffer
	pea 10
	pea 0	;unsigned
	_Long2Dec
	ldy #-1
@findNotBlank	iny
	lda DecimalBuffer,y
	and #$00ff
	cmp #$0020
	beq @findNotBlank
	tya
	clc
	adc #DecimalBuffer
	pea DecimalBuffer>>16
	pha
	_WriteCS
	jsr crout
@skipHexDec	rts

ExprBuff	dc.w ExprBuffSize
ExprSize	dc.w 0
theExpr	ds.b ExprBuffSize


msgExpRes	dc.b    'Expression = ',0
msgExpStr	dc.b cr,'    String = ',0
msgHex	dc.b    '       Hex = $',0
msgDec	dc.b cr,'   Decimal = ',0

DecimalBuffer	ds.b 10	;space for 10 digits
	dc.b 0	;cstring terminator

*****************************************************
*
* _xxx -- evaluate toolbox-call/etc expression
*
isUnderscore	name
	dec index
	pha
	pha
	pushlong #ExprBuff
	pea nlEvalExpr
	jsl NLService
	pla
	pla

	ldy ExprSize	;no result expression?
	sty ResExprIndex
	beq @x

	jsr KeepTheResult	;2-Feb-91 DAL

	pushlong #resultMsg
	_WriteCS

	phd
	pushlong uFoundAddr
	tsc
	tcd
	ldy #2
@searchResults	iny
	lda [1],y
	cmp #$3a29	;"):"
	bne @searchResults
	iny
	iny
	sty ResParmIndex	;offset to name of first parameter to display
	bra @loop2
@loop	lda #','
	jsr cout
	jsr spout
@loop2	jsr Disp1ResParm
	inc uNumInParms
	dec uNumResParms
	bne @loop
	pla
	pla
	pld
	jsr crout
@x	rts

resultMsg	dc.b cr,'Results: ',0

*
* KeepTheResult--if it's 4 bytes or less, keep it in Num1,
*	RawNum, and CurBank.
*
* 2-Feb-91 DAL
*
KeepTheResult	lda ExprSize
	cmp #4+1
	bcs @x
	lda theExpr+2
	ldx theExpr
	sta Num1+2
	stx Num1
	sta RawNum+2
	stx RawNum
	and #$00ff
	sta CurBank
@x	rts

ResParmIndex	dc.w 0
ResExprIndex	dc.w 0
*
* Disp1ResParm
*
* Input:  uNumInParms = index of the parameter to display
*         uParmSizes = table of parameter sizes
*         [1],ResParmIndex = pointer to name of parameter (comma or
*                            null terminated)
*         ResExprIndex = index *past* the parameter to display
*
* Output: ResParmIndex is bumped forward to next parm name,
*         ResExprIndex is bumped backward one parameter
*
Disp1ResParm	ldy ResParmIndex
	lda [1],y
	and #$00ff
	beq @nameDone
	cmp #','
	beq @nameDone
	jsr cout
	inc ResParmIndex
	bra Disp1ResParm
@nameDone	inc ResParmIndex	;skip past the comma
	lda #'='
	jsr cout
	lda #'$'
	jsr cout

	ldy uNumInParms
	lda uParmSizes,y
	and #$00ff
	tax	;parm size in X
	ldy ResExprIndex	;past last byte of parm
@byteLoop	dey
	lda theExpr,y
	phx
	phy
	jsr prbyte
	ply
	plx
	dex
	bne @byteLoop
	sty ResExprIndex
	rts

*****************************************************
*
* ":" --   addr:expressions
*
*****************************************************
isColon	name
	lda Num1+2
	ldy Num1
	sta addr+2
	sty addr
@next	jsr eatblanks
	lda Index
	sta @oldIndex
	pha
	pha
	pushlong #ExprBuff
	pea nlEvalExpr
	jsl NLService
	pla
	ply
	lda Index
	cmp @oldIndex
	beq @dun
	jsr StoreExpr
	bra @next
@dun	rts
@oldIndex	dc.w 0
*
* Store expression in ExprBuff at [addr], advancing addr
*
StoreExpr	name
	php	;30-Nov-90 DAL
	sei	;30-Nov-90 DAL
	ldy #0
@cont	cpy ExprSize
	bcs @dun
	lda theExpr,y
	jsr StoreByteAdv
	iny
	bra @cont
@dun	plp	;30-Nov-90 DAL
	rts
*
* Store byte in A
*
StoreByteAdv	phy
	jsr PutByte
	ply
	inc addr
	bne @dun
	inc addr+2
@dun	rts

*****************************************************
*****************************************************
*
* Get a line of input into Buffer (size=BuffSize).
*
* Returns length in A
*
*****************************************************
curPos	dc.w 0	;0=beginning of line
insMode	dc.w $8000	;bmi = insert mode
histLevel	dc.w 0
*
GetLn	name
	lda #-1
	sta histLevel
	stz NumChars
	stz curPos
GetLn1	name
	jsr GetKey
	tax
	bpl @notApple
	brl GetLnApple
@notApple	cmp #SPACE
	bcs @notCtl
	brl GetLnCtrl
@notCtl	cmp #DELETE
	beq GetLnDel
StoreCh	ldx NumChars
	cpx #BuffSize-1
	bcs GetLn1

	sep #$20
	bit insMode+1
	bpl @insx
	cpx curPos
	beq @insx
	pha
@ins	lda Buffer,x
	sta Buffer+1,x
	dex
	bmi @xx
	cpx curPos
	bcs @ins
@xx	inx
	pla
@insx	bit insMode+1
	bmi @staBuff
	ldx curPos
@staBuff	sta Buffer,x
	rep #$20

	jsr CCout
	bit insMode
	bpl @overstrike	;7-Jan-91 DAL
	inc NumChars
@overstrike	inc curPos
	ldx curPos
	cpx NumChars
	bcc @ok
	stx NumChars	;7-Jan-91 DAL: force NumChars up for overstrike
@ok	jsr glFromX
	brl GetLn1
*
glFromX	phx
	dex
@adv	inx
	cpx NumChars
	bcs @a
	lda Buffer,x
	phx
	jsr CCout
	plx
	bra @adv
@a	txa
	cmp 1,s
	beq @x
	dex
	lda Buffer,x
	jsr CBack
	bra @a
@x	plx
	rts
*
GetLnDel	name
	jsr DelSubr
	brl GetLn1
*
GetLnApple	name
	and #$00ff
	jsr upcase
	sta glApple
	ldx #glAppleEnd-glApple
@search	dex
	dex
	dex
	dex
	cmp glApple,x
	bne @search
	lda glApple+2,x
	bra GetLnDispatch
*
* glApple--table of GetLn Apple keys & subroutines
*
glApple	dc.w 0,gIgnore		;didn't match--ignore
	dc.w ',',gCtlB
	dc.w '<',gCtlB
	dc.w '.',gEndOfLine
	dc.w '>',gEndOfLine
	dc.w 'E',gToggleInsert
	dc.w 'F',gCtlF
	dc.w 'Y',gCtlY
glAppleEnd
*
GetLnCtrl	name
	sta glTheChar
	and #$001f
	asl a
	tax
	lda glCtrl,x
GetLnDispatch	dec a
	per GetLn1-1
	pha
	lda glTheChar
	ldx curPos	;Z flag = cursor at left of line
	rts
glTheChar	dc.w 0

glCtrl	dc.w glX,glX,gCtlB,glX,gCtlD,glX,gCtlF,glX	;Ctrl-@ to G
	dc.w gCtlH,glX,gCtlJ,gCtlK,glX,gCtlM,glX,glX	;Ctrl-H to O
	dc.w glX,gCtlQ,glX,gCtlS,glX,gCtlU,glX,gCtlW	;Ctrl-P to W
	dc.w gCtlX,gCtlY,glX,gCtlESC,glX,glX,glX,glX	;Ctrl-X to _

glX	ply	;default--use ctrl character
	brl StoreCh

gCtlB	ldx curPos
	beq @z
	jsr gCtlH
	bra gCtlB
@z	rts

gEndOfLine	ldx curPos
	cpx NumChars
	bcs @z
	jsr gCtlU
	bra gEndOfLine
@z	rts

gToggleInsert	lda insMode
	eor #$8000
	sta insMode
gIgnore	rts

gCtlY	ldx curPos
	cpx NumChars
	beq @z
	jsr gCtlD
	bra gCtlY
@z	rts

** Ctrl-W -- delete a word (for Matt Ackeret)
gCtlW	ldx curPos
	beq @z
	jsr DelSubr
@more	ldx curPos
	beq @z
	lda Buffer-1,x
	and #$00ff
	cmp #' '
	beq @z
	jsr DelSubr
	bra @more
@z	rts

DelSubr	ldx NumChars
	beq @z
	ldx curPos
	beq @z
	jsr gCtlH
	bra gCtlD
@z	rts

dBonk	brl chirp

gCtlF		;Ctrl-F = Ctrl-D
gCtlD	ldx NumChars
	beq dBonk
	ldx curPos
	cpx NumChars
	beq dBonk
@d	lda Buffer+1,x
	sta Buffer,x
	inx
	cpx NumChars
	bcs @dd
	jsr CCout
	bra @d
@dd	jsr spout2
	lda #8
	jsr cout
	jsr cout
	dec NumChars
@bk	dex
	cpx curPos
	beq @x
	lda Buffer-1,x
	jsr CBack
	bra @bk
@x	rts

gCtlH	beq @x
	lda Buffer-1,x
	jsr CBack
	dec curPos
@x	rts

gCtlJ	dec histLevel	;down arrow (history)
	bpl ReEditLine	;fall into gCtlK
gCtlK	inc histLevel	;up arrow (history)
*
*  v v v v v   fall into ReEditLine
*
ReEditLine	jsr GetLnCan
	lda histLevel
	cmp #-1
	bne @1
	stz histLevel
@1	inc histLevel

@histTry	dec histLevel
	lda histLevel
	jsr HistoryRead
	bcc @gotLine
;	jsr chirp	;not working right (30-Nov-90 DAL)
	bra @histTry
@gotLine
	pha
	phy	;source string
	pushlong #pascBuffer
	phd
	tsc
	tcd
	lda [7]	;length of source string
	and #$00ff
	sta NumChars
	sta curPos
	inc a
	pld
	pea 0
	pha
	_BlockMove

	ldx #0
@display	lda Buffer,x
	jsr CCout
	inx
	cpx NumChars
	bcc @display
	rts

gCtlQ	jsr gCtlY
	bra glOuttaHere
gCtlM	jsr gEndOfLine
glOuttaHere	
*** 27-May-91 DAL -- if Option is down, twiddle screen on
	lda >$e0c025
	and #$0040
	beq @1
	jsr TwiddleSHR
	inc untoggleScrnFlag
@1
*** end of 27-May-91 DAL
	pla
	bra GetLnDone

gCtlU	cpx NumChars
	bcs @x
	lda Buffer,x
	jsr CCout
	inc curPos
@x	rts

*
* Ctrl-S -- write to history buffer & do a Ctrl-X
*
gCtlS	lda NumChars
	beq gCtlX
	sep #$20
	sta pascBuffer
	rep #$20
	lda #^pascBuffer
	ldy #pascBuffer
	jsr HistoryWrite
gCtlX	jsr GetLnCan
	stz histLevel
	dec histLevel	;7-Jan-91 DAL
	rts
*
GetLnCan	ldx NumChars
	jsr MoveToX
@kill	jsr DelSubr
	lda NumChars
	bne @kill
	rts

MoveToX	cpx curPos
	beq @x
	bcc @x
	phx
	ldx curPos
	lda Buffer,X
	jsr CCout
	inc curPos
	plx
	bra MoveToX
@x	rts
*
GetLnDone	name
	jsr crout
	lda NumChars
	sep #$20
	sta pascBuffer
	rep #$20
	rts
*
gCtlESC	lda NumChars
	bne gCtlX
	pla	;discard return address
	lda #'q'
	sta buffer
	lda #1
	sta NumChars
	sep #$20
	sta PascBuffer
	rep #$20
	rts


*****************************************************
*****************************************************
*
* History routines
*
*****************************************************
*
* HistoryInit
*
* HistHandle: block is a series of Pascal strings,
*             terminated by a null string
*
* HistHandle can be NIL.
*
*****************************************************
HistoryInit	name
	pha
	pha	;space for result
	pushlong #HistSize
	lda MyID
	and #$f0ff
	ora #HistAuxID
	pha
	pea 0	;attributes
	pha
	pha
	_NewHandle
	pla
	sta HistHandle
	pla
	sta HistHandle+2

	bcs @err
	phd
	pha
	pha
	tsc
	tcd
	jsr PointHistory
	lda #0
	sta [1]
	pla
	pla
	pld

	lda #^histSample
	ldy #histSample
	jsr HistoryWrite
@err	rts

histSample	str '!Andy, it still has history!'

*
* HistoryShutdown--dispose of the History handle
*
HistoryShutdown	name
	lda HistHandle+1
	beq @noHist
	pushlong HistHandle
	_DisposeHandle
	stz HistHandle+2
	stz HistHandle
@noHist	rts

*
* write Pascal string (AY) into history list
*
HistoryWrite	name
	ldx HistHandle+1
	bne @haveHist
	rts
@haveHist	phd
	pha
	phy	;source string at [5]
	pha
	pha	;space for history pointer at <1
	tsc
	tcd
	lda [5]
	and #$00ff
	sta @length

* see if this is a duplicate of the last string we added (5-Feb-91 DAL)
	lda #0
	jsr HistoryRead
	bcs @noDuplicate

	sta 3
	sty 1
	ldy @length
	beq @noWrite
	dey
@compare	lda [1],y
	cmp [5],y
	bne @noDuplicate
	dey
	bpl @compare
@noWrite	brl @exit

@noDuplicate

* make room for new string, if we're running out of room

@makeRoom	jsr HistCheckSize	;A=size used (not including terminator)
	tay
	sec	;add 1 for length byte
	adc @length
	inc a	;add 1 for null terminator after last string
	cmp #HistSize
	bcc @fits
	jsr ShiftHistory
	bra @makeRoom

@fits	sty @offset	;size used = where to put next string
	jsr PointHistory
	pei 7
	pei 5	;source string
	lda @offset
	clc
	adc 1
	tax
	lda 3
	adc #0
	pha
	phx	;destination = <1 + offset
	pea 0
	lda @length
	inc a
	pha	;size = length+1
	_BlockMove

	sec
	lda @length
	adc @offset
	tay
	lda #0
	sep #$20
	sta [1],y
	rep #$20

@exit	pla
	pla
	pla
	pla

	pld
	rts

@length	dc.w 0
@offset	dc.w 0

*
* HistCheckSize
*   (private--needs direct-page space set up)
*
*
* Returns A=offset to next free space in history buffer,
*         X=number of string in buffer
*
HistCheckSize	name
	jsr PointHistory
	ldy #0	;y = offset = 0
	tyx	;x = num strings = 0
@next	lda [1],y
	and #$00ff
	beq @done
	pha
	tya
	sec	;1 extra for length byte
	adc 1,s
	tay
	pla	;throw out temp value
	inx
	bra @next
@done	tya
	rts

ShiftHistory	name
	jsr PointHistory	;points <1 at the history
	lda [1]
	and #$00ff
	inc a
	sta @delta
	clc
	adc 1
	tax
	lda 3
	adc #0
	pha
	phx	;source (second string in buffer)
	pei 3
	pei 1	;dest (beginning of buffer)
	pea 0
	sec
	lda #HistSize
	sbc @delta
	pha	;amount to move
	_BlockMove
	rts

@delta	dc.w 0

*
* read the Ath string from the end of the
* history list (return clc, ptr in AY)
* or SEC = error
*
HistoryRead	name
	ldx HistHandle+1
	bne @haveHist
	sec
	rts
@haveHist	sta @index
	phd
	pha
	pha	;space for history pointer at <1
	tsc
	tcd
	jsr HistCheckSize	;x=num strings
	phx
	jsr PointHistory
	pla
	dec a	;num strings - 1
	sec
	sbc @index
	beq @first
	sta @index
@PointAtNext	lda [1]
	and #$00ff
	sec
	beq @exit	;error--ran out of strings
	sec
	adc 1
	sta 1
	bcc @1
	inc 3
@1	dec @index
	bne @PointAtNext
@first	lda 3
	ldy 1
	clc
@exit	plx
	plx
	pld
	rts
@index	dc.w 0

PointHistory	name
	lda HistHandle+2
	sta 3
	lda HistHandle
	sta 1
	lda [1]
	tax
	ldy #2
	lda [1],y
	sta 3
	stx 1
	rts

HistHandle	dc.l 0

*****************************************************
*****************************************************
*
* GetKey
*
* Returns A: bit 15=Apple key, bits 7-0 = key
*
*****************************************************
HardMods	dc.b 0
HardWidth	dc.w 0
HardPreCDA	dc.w 0
*
GetKey	name
	jsr UnPause
	jsr doGetKey
	cmp #$0014	;Ctrl-T
	bne @notCtlT
	jsr TwiddleSHR
	bra GetKey
@notCtlT	and #$00ff	;mask off Apple (bit 15) 13-Jan-91 DAL
	pha
	sep #$20
	lda >$E0C025
	sta HardMods
	rep #$20
	and #$0080
	bne AppleDown
	pla
	rts

AppleDown	plx
	phx
	jsr AppleSpecial
	pla
	bcc GetKey	;was BRA, 7-Jan-91 DAL (return keys to caller now)
	ora #$8000	;bit 15 = Apple key down
	rts

TwiddleSHR	name
	longa off
	sep #$30
	lda >$E0C029
	eor #$80
	sta >$E0C029
	longa on
	rep #$30

	pea 0
	_QDStatus
	pla
	bne @noChirp
	jsr chirp
@noChirp	lda twiddleFlag
	eor #$8000
	sta twiddleFlag

	sep #$20
	lda $e0c029
	rep #$20
	bmi @nowOn
* just turned off SHR
	pha
	pea $1c	;border color parameter
	_ReadBParam
	pla
	and #$000f
@setCol	sta @color
	sep #$20
	longa off
	lda $e0c034
	and #$f0
	ora @color
	sta $e0c034
	rep #$20
	longa on
@x	rts

@nowOn	lda $e0c034
	and #$000f
	eor #$000f
	beq @setCol	;if it was White, make it black
	lda #$000f	;otherwise make it white
	bra @setCol

@color	dc.w 0
twiddleFlag	dc.w 0

UnTwiddle	lda twiddleFlag
	bpl @x
	jsr TwiddleSHR
@x	rts

chirp	name
	sep #$20
	longa off
	lda $E0C036
	pha
	and #$7f
	sta $E0C036
	ldy #20
@1	ldx #$100
@2	dex
	bpl @2
	lda $E0C030
	dey
	bpl @1
	pla
	sta $E0C036
	rep #$20
	longa on
	rts

AppleSpecial	name
	cpx #'h'
	beq HardCopy0
	cpx #'H'
	beq HardCopy0
	cpx #'4'
	beq Old40Text
	cpx #'8'
	beq Old80Text
	cpx #' '
	beq doLinefeed
	cpx #$0d
	beq doFormfeed
	sec
	rts

HardCopy0	brl HardCopy

doLinefeed	lda #$8d
	bra doPrinterChar
doFormfeed	lda #$8c
doPrinterChar	name
	sta theCharacter
	sep #$20		;added 14-Jan-90 DAL
	lda >$57b
	pha
	rep #$20
	lda >$36
	pha
	lda >$38
	pha
	lda >$24
	pha
	jsr PrinterOn
	lda theCharacter
	pha
	_WriteChar
	pla
	sta >$24
	pla
	sta >$38
	pla
	sta >$36
	sep #$20
	pla
	sta >$57b
	rep #$20
	clc
	rts
theCharacter	dc.w 0

Old40Text	ldy #40
	bra dumpOldText
Old80Text	ldy #80
dumpOldText	sty HardWidth
	lda #PreCDAscreen>>16
	ldx #<PreCDAscreen
	sec
	bra dumpTheScreen

HardCopy	name
	ldy #80
	sty HardWidth
	lda #TextScreen>>16
	ldx #<TextScreen
	clc
dumpTheScreen	ror HardPreCDA
	sta ScreenPtr+2
	stx ScreenPtr
	sep #$20
	lda >$57b
	pha
	rep #$20
	lda >$36
	pha
	lda >$38
	pha
	lda >$24
	pha
	jsr PrinterOn
	ldx #0
NxtLine	phx
	jsr PrintOneLine		;line X of [1]
	plx
	inx
	cpx #24
	bcc NxtLine
	pla
	sta >$24
	pla
	sta >$38
	pla
	sta >$36
	sep #$20
	pla
	sta >$57b
	rep #$20
	clc
	rts
*
ScreenPtr	DC.L 0
*
PrinterOn	name
	lda #0
	pha
	pha
	lda PrinterSlot
	pha
	_SetOutputDevice
	pea 1		;output
	_InitTextDev
	rts
*
PrintOneLine	name
	phd
	lda ScreenPtr+2
	pha
	txa
	asl a
	tax
	lda ScrnOffsets,x
	clc
	adc ScreenPtr
	pha
	tsc
	tcd
	ldy #0
PrNxtChr	phy
	jsr FetchChar		; [1],y sort-of
	jsr FixupChar
	php
	pha
	_WriteChar
	plp
	jsr EndMouseText
	ply
	iny
	tya
	cmp HardWidth
	bcc PrNxtChr
	pla
	pla
	pld
	pea cr
	_WriteChar
	rts
*
FetchChar	lda HardPreCDA
	bpl fetchPlain
	lda HardWidth
	cmp #40
	beq fetch40
	tya
	lsr a
	tay
	bcs fetch1
	phy
	tya
	clc
	adc #$0400
	tay
	lda [1],y
	ply
	and #$00ff
	rts

fetchPlain	tya
	lsr a
	tay
	bcs fetch1
	inc 3
	lda [1],y
	dec 3
	and #$00ff
	rts
fetch1	lda [1],y
	and #$00ff
	rts
fetch40	lda [1],y
	and #$00ff
	rts
*
* Make a character lifted from the screen suitable for
* printing to the printer
*
FixupChar	pha
	and #$e0
	cmp #$40
	clc
	bne notMouseText
	lda hardMods
	and #4	;caps-lock allows mousetext
	beq notMouseText
	sec
	jsr beginMouseText
notMouseText	pla
	php
	and #$7f
	cmp #$20
	bcs fcOkay
	adc #$40	;carry was clear
fcOkay	plp
	rts
*
* enable ImageWriter II MouseText
*
BeginMouseText	name
	php
	phy
	phx
	pha
	pea $1b
	_WriteChar
	pea $26	;"ESC &" enables MT
	_WriteChar
	pla
	plx
	ply
	plp
	rts
*
* EndMouseText--preserve A; write end-mousetext commands to
* ImageWriter if carry set
*
EndMouseText	name
	bcc emtDone
	pea $1b
	_WriteChar
	pea $24		;"ESC $" disables MT
	_WriteChar
emtDone	rts
*
ScrnOffsets	DC.W $000,$080,$100,$180,$200,$280,$300,$380
	DC.W $028,$0A8,$128,$1A8,$228,$2A8,$328,$3A8
	DC.W $050,$0D0,$150,$1D0,$250,$2D0,$350,$3D0
*
CCout	name
	and #$007f
	cmp #' '
	bcs DoCout
	adc #$40
	pha
	lda #'^'
	jsr cout
	pla
DoCout	brl cout

CBack	and #$007f
	cmp #' '
	bcs @x
	jsr @x
@x	lda #8
	jmp cout

*****************************************************
*****************************************************
*
* Parsing subroutines
*
*****************************************************
chrgotAdvance	name
	lda #0
	ldy index
	cpy NumChars
	bcs @dun
	inc index
	lda Buffer,y
	and #$00ff
	clc
@dun	rts

chrget	name
	jsr chrgot
	bcs ChrGetDone
	inc index
chrgot	name
	lda #0
	ldy index
	cpy NumChars
	bcs @dun
	lda Buffer,y
	and #$00ff
	clc
@dun
ChrGetDone	rts
*
* digitValue(A):A  (sec=invalid character)
*
wcDigitValue	name
	stz wcDigitFlag
	cmp #'?'
	bne digitValue
	ror wcDigitFlag	;set flag
	lda #0	;value = 0
	clc
	rts

digitValue	name
	cmp #'0'
	bcc @bad
	cmp #'9'+1
	bcc @ok
	jsr upcase
	cmp #'A'
	bcc @bad
	cmp #'F'+1
	bcs @bad
	sbc #7-1
@ok	and #$000f
	clc
	rts
@bad	sec
	rts

wcDigitFlag	dc.w 0
*
* parse an identifier--buffer = AX, Y=max length
*
* Puts a pascal string into the buffer
*
parseIdent	name
	phd
	pha
	phx
	tsc
	tcd
	sty iMaxLen
	ldx #0
@idNext	cpx iMaxLen
	bcs @idDun
	jsr chrgot
	jsr isIdChar
	bcs @idDun
	inx
	txy
	sep #$20
	sta [1],y
	rep #$20
	jsr chrget
	bra @idNext
@idDun	txa
	sep #$20
	sta [1]
	rep #$20
	ply
	ply
	pld
	rts
iMaxLen	dc.w 0

isIdChar	name
	cmp #':'
	beq @idYes
	cmp #'/'
	beq @idYes
	cmp #'%'
	beq @idYes
	cmp #'0'
	bcc @idNo
	cmp #'9'+1
	bcc @idYes
	cmp #'A'
	bcc @idNo
	cmp #'Z'+1
	bcc @idYes
	cmp #'_'
	beq @idYes
	cmp #'a'
	bcc @idNo
	cmp #'z'+1
	bcc @idYes
@idNo	sec
	rts
@idYes	clc
	rts

*
* UpcaseIdent -- uppercase the Pascal string at AX
*
UpcaseIdent	name
	phd
	pha
	phx
	tsc
	tcd
	sep #$30
	longa off
	longi off
	lda [1]
	tay
	beq @done
@next	lda [1],y
	jsr upcase8
	sta [1],y
	dey
	bne @next
@done	rep #$30
	longa on
	longi on
	pla
	pla
	pld
	rts

*****************************************************
*
* EvalExpr   ay=buffer
*
* buffer:
*   +000: MaxExprSize/2
*   +002: ActExprSize/2
*   +004: Expr/n
*
* expr ::=
*   hex_number
*   # decimal_number
*   @ expr
*   - expr
*   \ ...
*   _ toolname/etc ...
*   " string "
*   [ expressions ]
*
*****************************************************
EvalExpr	name
*** added 9-Nov-91 DAL -- allow infix expressions
*** (old EvalExpr is now called EvalTerm)
	phd
	pha
	phy
	tsc
	tcd

	lda subExprBuff+6
	pha
	lda subExprBuff+4
	pha
	lda subExprBuff+2
	pha

	ldy #2	;anticipate 0-byte expression
	lda #0
	sta [1],y

	lda 3
	ldy 1
	jsr EvalTerm

@moreInfix	jsr eatblanks
	cmp #'+'
	bne @notPlus
	jsr EvalSubExpr	;expressions are same length!
	ldy #4
	ldx subExprBuff+2	;length
	sep #$20
	longa off
	clc
@addLoop	lda [1],y
	adc subExprBuff,y
	sta [1],y
	iny
	dex
	bne @addLoop
	bcc @fits
	tyx	;extend result on overflow
	ldy #2
	lda [1],y
	cmp #4
	bcs @alreadyLong
	inc a
	sta [1],y
	txy
	lda #1
	sta [1],y
@alreadyLong
@fits	rep #$20
	longa on
	bra @moreInfix

@notPlus	cmp #'-'
	bne @notMinus
	jsr EvalSubExpr	;expressions are same length!
	ldy #4
	ldx subExprBuff+2	;length
	sep #$20
	sec
@subLoop	lda [1],y
	sbc subExprBuff,y
	sta [1],y
	iny
	dex
	bne @subLoop
	rep #$20
	bra @moreInfix

@notMinus	cmp #'*'
	beq @isMult
	brl notMultiply
@isMult	jsr EvalSubExpr	;expressions are same length!

*** zero out unused bytes of [1] (up to 4 bytes)
	sep #$30
	longa off
	longi off
	ldy #2
	lda [1],y
	cmp #4
	bcs @long
	tay
	iny
	iny
	iny
	iny
@keepZapping	lda #0
	sta [1],y
	iny
	cpy #8
	bcc @keepZapping
@long	rep #$30
	longa on
	longi on

*** do a long multiply
	pha
	pha
	pha
	pha
	lda subExprBuff+6
	pha	;high word of operand 2
	lda subExprBuff+4
	pha	;low word of operand 2
	ldy #6
	lda [1],y
	pha	;high word of operand 1
	dey
	dey
	lda [1],y
	pha	;low word of operand 1
	_LongMul
	pla
	ldy #4
	sta [1],y
	pla
	iny
	iny
	sta [1],y
	pla
	bne @tooLong
	pla
	bne @tooLong

*** compute new length (add input lengths, clip at 4)
	ldy #2
	lda [1],y
	clc
	adc subExprBuff+2
	cmp #4
	bcc @thisSize
	lda #4
@thisSize	sta [1],y
	brl @moreInfix

@tooLong	pushlong #multiplyOvfMsg
	_WriteCS
	brl doAbort
multiplyOvfMsg	dc.b cr,'*** multiply overflow',cr,0

*
* EvalSubExpr -- expression buffer pointer at <1 on direct page
*
EvalSubExpr	name
	ldy #2
	lda [1],y
	cmp #4+1
	bcs subExprLenError
	jsr chrget
	stz subExprBuff+4
	stz subExprBuff+6
	lda #^subExprBuff
	ldy #subExprBuff
	jsr EvalTerm

@adjustLen	ldy #2	;main expression length
	lda [1],y
	beq subExprLenError
	cmp #4+1
	bcs subExprLenError
	cmp subExprBuff+2
	beq @gotSubExpr
	bcc @extendMain
	ldy subExprBuff+2
	lda #0
	sep #$20
	sta subExprBuff+4,y
	rep #$20
	inc subExprBuff+2
	bra @adjustLen

@extendMain	inc a
	sta [1],y	;store new length
	inc a
	inc a
	inc a
	tay
	lda #0	;append a zero
	sep #$20
	sta [1],y
	rep #$20
	bra @adjustLen

@gotSubExpr	rts

subExprLenError	pushlong #addSubLenMsg
	_WriteCS
	brl doAbort
addSubLenMsg	dc.b cr,'*** +, -, * operands must be 1 to 4 bytes long',cr,0

subExprBuff	dc.w 4,0,0,0

notMultiply	pla
	sta subExprBuff+2
	pla
	sta subExprBuff+4
	pla
	sta subExprBuff+6
	ply
	ply
	pld
	rts
*** end 9-Nov-91


EvalTerm	name
	phd
	pha
	phy
	tsc
	tcd

	ldy #2	;anticipate 0-byte expression
	lda #0
	sta [1],y

	jsr eatblanks	;14-Jul-90 DAL
	tay
	beq @exprDone
	sep #$20
	ldx #evalSubr-exprChars
	sta exprChars
@srch	dex
	cmp exprChars,x
	bne @srch
	rep #$20
	txa
	asl a
	tax
	lda exprChars
	and #$00ff
	stz WorkNum
	stz WorkNum+2
	jsr (evalSubr,x)
@exprDone	ply
	ply
	pld
	rts

exprChars	dc.b '?#-_"['
	dc.b '@'
;	backslash
evalSubr	dc.w evalHex,evalPound,evalNegate
	dc.w evalTool,evalQuote,evalList
	dc.w evalAt
;	dc.w evalBacksl
WorkNum	dc.l 0

*
* evaluate a hex number into expression at [1]
*
evalHex	name
	stz @count
	jsr chrgot
	jsr wcDigitValue	;clc --> 0..15
	bcs @bad
@next	ldx #4
@shft	asl WorkNum
	rol WorkNum+2
	dex
	bne @shft
	clc
	adc WorkNum
	sta WorkNum	;overflow is impossible
	inc @count
	jsr chrget
	jsr digitValue
	bcc @next
	jsr StuffWorkNum
* decide whether this is a Byte, Word, or Long
	ldx @count
	lda #1
	cpx #3
	bcc @size
	asl a
	cpx #5
	bcc @size
	asl a
@size	ldy #2
	sta [1],y
@bad	rts
@count	dc.w 0

*
* evaluate a decimal number or constant into expression at [1]
*
* # digit {digit}
*
* # identifier
*
evalPound	name
	jsr chrget
	jsr digitValue
	bcs @notDecimal
	cmp #10
	bcs @notDecimal
@next	pha
	jsr Mult10Work
	pla
	clc
	adc WorkNum
	sta WorkNum
	bcc @ok
	inc WorkNum+2
@ok	jsr chrget
	jsr digitValue
	bcs @done
	cmp #10
	bcc @next
* stuff the result into the buffer
@done	jsr StuffWorkNum
	jsr TrimZeroes
* if it's 3 bytes long, make it 4
	ldy #2
	lda [1],y
	cmp #3
	bne @not3
	lda #0
	jsr Append1
@not3	rts

*
* # identifier -- look up a constant and put it into expression at [1]
*
@notDecimal	jsr prepEvalIdent

	lda #secSysTool
	jsr QtSecA
	lda uFoundAddr+2
	bne @got

	lda #secUserTool
	jsr QtSecA
	lda uFoundAddr+2
	bne @got

	lda #secP16
	jsr QtSecA
	lda uFoundAddr+2
	bne @got

	lda #secHyperCard	;added 13-Jan-91 DAL
	jsr QtSecA
	lda uFoundAddr+2
	bne @got

*** Now kill the "(" in the buffer so we can look for stuff
*** that doesn't have any parameters in the data file

	sep #$30
	longa off
	lda #0
	ldy undBuffer
	sta undBuffer,y
	rep #$30
	longa on

	lda #secResTypes
	jsr QtSecA
	lda uFoundAddr+2
	bne @got

	lda #secReqCode	;added 26-Aug-91 DAL
	jsr QtSecA
	lda uFoundAddr+2
	bne @got

	pushlong #badConstMsg
	_WriteCS
	brl DoAbort

@got	lda #2
	tay
	sta [1],y	;length=2
	iny
	iny
	lda uFoundValue
	sta [1],y
	rts
badConstMsg	dc.b cr,'*** unknown constant (#xxx)',cr,0

*
* StuffWorkNum--put 4-byte WorkNum into expr at [1]
*
StuffWorkNum	name
	ldy #2
	lda #4
	sta [1],y	;set length=4
	iny
	iny
	lda WorkNum
	sta [1],y
	iny
	iny
	lda WorkNum+2
	sta [1],y
	rts
*
* TrimZeroes--remove all high-order $00 bytes, leaving at least 1 byte
*
TrimZeroes	name
	ldy #2
	lda [1],y
	tay
	tax
	beq @dun
	iny
	iny
	iny
	jsr get1y
	bne @dun
	dex
	beq @dun
	txa
	ldy #2
	sta [1],y
	bra TrimZeroes
@dun	rts
*
* sign-extend expression at [1] to be at least A bytes
*
SignExtExpr	name
	sta @targetLen
	ldx #0
	ldy #2
	lda [1],y
	beq @gotByte
	tay
	iny
	iny
	iny
	lda [1],y
	and #$0080
	beq @gotByte
	dex
@gotByte	stx @byte
@more	ldy #2
	lda [1],y
	cmp @targetLen
	bcs @dun
	lda @byte
	jsr Append1
	bra @more
@dun	rts

@targetLen	dc.w 0
@byte	dc.w 0
*
* Multiply WorkNum by 10
*
Mult10Work	asl WorkNum
	rol WorkNum+2
	ldx WorkNum
	ldy WorkNum+2
	asl WorkNum
	rol WorkNum+2
	asl WorkNum
	rol WorkNum+2
	clc
	txa
	adc WorkNum
	sta WorkNum
	tya
	adc WorkNum+2
	sta WorkNum+2
	rts
*
* evalAt -- allocate a dynamic expression buffer, call evalExpr on it,
*           and return the address of the data as a 4-byte expression.
*
evalAt	name
	jsr chrget
	pei <3
	pei <1

	ldy #2
	lda #4
	sta [<1],y	;store expression size (ptr is 4 bytes)

	lda #132
	jsr allocDynBuffer	;returns ptr in XA
	pha	;keep low word of pointer
	ldy #4	;offset to 1st two expr bytes
	clc
	adc #4	;point to the expr data (does not cross bank)
	sta [1],y	;store low word of data pointer
	iny
	iny
	txa
	sta [1],y	;store high word of data pointer
	sta 3
	pla
	sta 1	;<1 = ptr to new expression buffer

	lda #128
	sta [<1]	;store expr buffer size

	lda <3
	ldy <1
	jsr EvalExpr

	pla
	sta <1
	pla
	sta <3
	rts

*
* allocDynBuffer
*
* Input:   A = size in bytes
*
* Output:  XA = pointer to new buffer
*          On error, does not return.
*
allocDynBuffer	name
	pha
	pha	;space for result
	pea 0	;size high
	pha	;size low
	pha
	_MMStartUp
	pla
	ora #DynamicAuxID
	pha	;mem id
	pea $c018	;attributes
	pha
	pha	;location (ignored)
	_NewHandle
	bcs @dbError
	phd
	tsc
	tcd
	ldy #2
	lda [3],y
	tax
	lda [3]
	pld
	ply
	ply
	rts	;return pointer in XA

@dbError	pushlong #badAtMsg
	pea nlWriteCStr
	jsl NLService
	brl DoAbort
badAtMsg	dc.b cr,'*** couldn''t get memory for "@"',cr,0

*
* evalNegate--handle unary negation operator
*
evalNegate	name
	jsr chrget
	lda 3
	ldy 1
	jsr EvalExpr
	lda #4
	jsr SignExtExpr	;extend to at least 4 bytes
	ldy #4
	lda [1],y
	eor #$ffff
	clc
	adc #1
	sta [1],y
	iny
	iny
	lda [1],y
	eor #$ffff
	adc #0
	sta [1],y
	rts
*
* evalBacksl -- unimplemented
*
evalBacksl	name
*###
	jsr chrget	;get char after the "\"
	rts

prepEvalIdent	name
	sec
	ror UnderscoreFlag
	lda #undBuffer>>16
	ldy #undBuffer+1	;point past the length byte
	sta srchTarget+2
	sty srchTarget

	ldy #32
	lda #undBuffer>>16
	ldx #undBuffer
	jsr parseIdent

	stz QuoteIdx
	inc undBuffer
	lda undBuffer
	and #$00ff
	sta QuoteLen
	tay
	lda #'('
	sep #$30
	sta undBuffer,y
	tya
	beq @x
@upc	lda undBuffer,y
	jsr upcase8
	sta undBuffer,y
	dey
	bne @upc
@x	rep #$30

	stz uFoundValue
	stz uFoundAddr
	stz uFoundAddr+2
	rts

*
* eval a "_xxx" expression
*
evalTool	name
	jsr chrget
	jsr prepEvalIdent

	stz undKind	;0=system tool
	lda #secSysTool
	jsr QtSecA
	lda uFoundAddr+2
	bne gotTool

	inc undKind	;1=user tool
	lda #secUserTool
	jsr QtSecA
	lda uFoundAddr+2
	bne gotTool

*** HyperCard callbacks -- 13-Jan-91 DAL
	inc undKind	;2=HyperCard callback
	lda #secHyperCard
	jsr QtSecA
	lda uFoundAddr+2
	bne gotTool

	pushlong #badToolMsg
	pea nlWriteCStr
	jsl NLService
	brl DoAbort
badToolMsg	dc.b cr,'*** unknown tool name (_xxx)',cr,0

gotTool	jsr ParseUndParms

	lda #$7777
	ldy uResultSize
	iny
	iny
@pushRes	dey
	dey
	beq @didSpace
	pha
	bra @pushRes
@didSpace
*** If it's a HyperCardIIGS call, then let's push a valid string
*** pointer for the result, instead of $77777777
	lda undKind
	cmp #2
	bne @hcgsDone
	lda uResultSize
	cmp #4
	bcc @hcgsDone
	lda #^InfoBuff
	sta 3,s
	lda #InfoBuff
	sta 1,s
@hcgsDone
***
	jsr eatblanks
	cmp #'('
	beq @ok0
	lda uInputSize
	bne @ick
	brl @doCall
@ick	brl neededOPerr
@ok0	jsr chrget
	stz inCount
@parseIn	lda inCount
	cmp uNumInParms
	bcs @didIn

	ldy #UND_RECUR_END-UND_RECURSION-2
@recPush	lda UND_RECURSION,y
	pha
	dey
	dey
	bpl @recPush

	stz tmpExprBuff+4
	stz tmpExprBuff+6	;pre-zero the 8-byte buffer
	stz tmpExprBuff+8
	stz tmpExprBuff+10
	jsr eatblanks
	pha
	pha
	pushlong #tmpExprBuff
	pea nlEvalExpr
	jsl NLService
	pla
	pla

	ldy #0
@recPop	pla
	sta UND_RECURSION,y
	iny
	iny
	cpy #UND_RECUR_END-UND_RECURSION
	bcc @recPop

	ldx inCount
	lda uParmSizes,x
	and #$00ff
	tay
@pushInP	lda tmpExprBuff+2,y
	pha
	dey
	dey
	bne @pushInP
	inc inCount
	lda inCount
	cmp uNumInParms
	bcs @didIn
	jsr eatblanks
	cmp #','
	beq @ok
	brl neededCommaErr
@ok	jsr chrget
	bra @parseIn

@didIn	jsr eatblanks
	cmp #')'
	beq @ok2
	brl neededCPerr
@ok2	jsr chrget

@doCall	tdc
	sta @myDirPage
	lda #$0400
	tcd
	ldx uFoundValue
	stx @cheat1+1
	stx @cheat2+1
	stx @cheat3+1
	lda undKind
	beq @doSysTool
	dec a
	beq @usrT
*** Do a HyperCard callback
@CallHCGS	jsr VerifyHCGS
@cheat3	ldx #$7777
	jsl $e10220	;call HyperCardIIgs
	clc
	bra @didT
*** Do a System Tool call
@doSysTool
@cheat1	ldx #$7777
	jsl tool	;call SYSTEM tool
	bra @didT
*** Do a User Tool call
@usrT
@cheat2	ldx #$7777
	jsl UserTool	;call USER tool
@didT	pha
	lda @myDirPage
	tcd
	pla
	bcc @noErr

	pha
	pushlong #msgToolErr
	_WriteCS
	lda 1,s
	jsr prword
	plx
	lda #secErrors
	jsr FindPrint
	jsr crout
	brl DoAbort

@noErr	lda uResultSize
	tax
	ldy #2
	sta [1],y
	ora #0
	beq @pulled
@pullR	iny
	iny
	pla
	sta [1],y
	dex
	dex
	bne @pullR
@pulled	rts

@myDirPage	dc.w 0

msgToolErr	dc.b cr,'Tool error = $',0

*
* VerifyHCGS -- make sure HyperCardIIgs callbacks
* are available.
*
* If this routine returns, they are available.
* Otherwise it prints an error and aborts.
*
VerifyHCGS	lda >$E10220
	and #$00ff
	cmp #$005c	;long jump?
	bne @notHere

	pha
	pha	;space for _FindHandle result
	lda >$E10220+3
	and #$00ff
	pha
	lda >$E10220+1
	pha
	_FindHandle
	bcs @notHere	;jumps to a valid handle?

	phd
	tsc
	tcd
	ldy #4
	lda [3],y
	tax	;attributes in X
	iny
	iny
	lda [3],y	;memory ID in A
	pld
	ply
	ply
	and #$f000
	cmp #$1000	;jumps to an ID=$1xxx handle?
	bne @notHere

	txa
	bmi @ok	;Locked?  Okay.
	and #$4300
	cmp #$4000	;Unlocked but fixed & Purge=0?  Okay.
	bne @notHere
@ok
	lda >$e10220+1
	sta @cheat+1
	lda >$e10220+2
	sta @cheat+2
@cheat	lda >$777777
	cmp #$C98A	;look for TXA, CMP#
	bne @notHere
	rts
@notHere	pushlong #msgHCGSErr
	_WriteCS
	brl DoAbort
msgHCGSErr	dc.b cr,'*** HyperCard callbacks seem unavailable',cr,0

*
* Expression parsing misc routines
*
neededCommaErr	lda #','
	bra needCharErr
neededCPerr	lda #')'
	bra needCharErr
neededOPerr	lda #'('
needCharErr	name
	pha
	pushlong #synErrMesg
	pea nlWriteCStr
	jsl NLService
	pla
	jsr cout
	jsr crout
	brl DoAbort
synErrMesg	dc.b cr,'*** expression syntax error: expected a ',0

undBuffer	ds.b 35	;holds pString following "_"
tmpExprBuff	dc.w 8,0,0,0,0,0	;holds an input parameter being parsed
*
* This stuff gets preserved across calls to the expression evaluator,
* so we can have nested calls, like  _NewHandle(_MaxBlock,_MMStartUp,0,0)
*
UND_RECURSION
undKind	dc.w 0	;0=system tool call
uFoundAddr	dc.l 0	;ptr to data file entry (Word,nxtLnk,rsvByt,cStr)
uFoundValue	dc.w 0	;word in data file
uInputSize	dc.w 0	;total size of input parms
uResultSize	dc.w 0	;total size of output parms
uNumResParms	dc.w 0	;number of result parameters
uNumInParms	dc.w 0	;number of input parameters
uParmSizes	ds.b 20	;table of parameter sizes (1 byte each)
inCount	dc.w 0	;number of input parms pushed so far
UND_RECUR_END
*
* ParseUndParms
*
*   Input: undKind (0=system tool, 1=user tool)
*          uFoundAddr
*  Output: uInputSize, uNumInParms, uResultSize, uNumResParms, uParmSizes
*
* Example: uFoundAddr points to
*   $0902 $link $xx "NewHandle(size/4,id,attr,@loc):H" $00
* Result:
*   uInputSize:   $0C
*   uResultSize:  $04
*   uNumInParms:  $04
*   uNumResParms: $01
*   uParmSizes:   $04 $02 $02 $04 $04 [15 undefined bytes]
*
ParseUndParms	name
	phd
	pushlong uFoundAddr	;at [1]
	tsc
	tcd
	stz uInputSize
	stz uResultSize
	stz uNumInParms
	stz uNumResParms
	ldy #4	;offset to first char of name
@scanOP	iny
	jsr get1y
	beq @x
	cmp #'('
	bne @scanOP
@inParm0	iny
@inParm	jsr get1y
	beq syntaxErr1
	cmp #')'
	beq @inDone
	jsr Scan1Parm
	ldx uNumInParms
	inc uNumInParms
	sep #$20
	sta uParmSizes,x
	rep #$20
	clc
	adc uInputSize
	sta uInputSize
	jsr get1y
	cmp #','
	beq @inparm0
	cmp #')'
	beq @inDone
	brl syntaxErr1
@inDone	iny	;skip past ")"
	jsr get1y
	beq @x
	cmp #':'
	bne @resParms	;skip past ":" if there is one
@resParms0	iny
@resParms	jsr get1y
	beq @x
	cmp #' '
	beq @x
	jsr Scan1Parm
	pha
	clc
	lda uNumInParms
	adc uNumResParms
	tax
	pla
	inc uNumResParms
	sep #$20
	sta uParmSizes,x
	rep #$20
	clc
	adc uResultSize
	sta uResultSize
	jsr get1y
	beq @x
	cmp #','
	beq @resParms0
	bra syntaxErr1
@x	pla
	pla
	pld
	rts
*
get1y	lda [1],y
	and #$00ff
	rts
*
syntaxErr1	name
	pushlong #CommaOrParen
	pea nlWriteCStr
	jsl NLService
	brl DoAbort
CommaOrParen	dc.b cr,'*** comma or ")" expected in data file',cr,0
*
* Scan1Parm--scans input in [1],y and returns A=parmsize
*   (advances Y past the scanned parameter)
*
* Input format is:
*    [@] {anthing but ")" or "," or blank} [/n] [H]
*
Scan1Parm	name
	stz @theSize
	stz @lastChar
	dey
@char	iny
	jsr get1y
	beq @done
	cmp #'@'
	bne @not4
	lda #4
	sta @theSize
	bra @char
@not4	cmp #','
	beq @done
	cmp #' '
	beq @done
	cmp #')'
	beq @done
	cmp #'/'
	beq @slash
	sta @lastChar
	bra @char
@slash	iny	;/n = n bytes
	lda [1],y
	and #$000f
	sta @theSize
	bra @char

@done	lda @theSize
	bne @retsz
	lda #2	;default size is 4 bytes
	ldx @lastChar
	cpx #'H'	;trailing "H" means Handle
	bne @retsz
	lda #4
@retsz	rts

@theSize	dc.w 0
@lastChar	dc.w 0
*
* evaluate a quoted string into an expression
*
evalQuote	name
	jsr chrget	;get char after the quote
*** added 26-Jul-92 DAL -- check for special string types (backslash-p, backslash-w)
	stz @stringType	;0=raw string
	cmp #$5c	;backslash
	bne @notSpecial
	jsr chrget
	cmp #$5c	;two backslashes?
	beq @next
	ldx #$0001	;anticipate 1=pstring
	cmp #'p'
	beq @special
	ldx #$0002	;anticipate 2=wstring
	cmp #'w'
	beq @special
	cmp #'g'
	beq @special
	ldx #$8000	;anticipate $8000=cstring
	cmp #'c'
	beq @special

	dec index	;back up and use the backslash
	lda #$5c
	bra @next

@special	stx @stringType
	txa
	and #$00ff
	beq @padded
@pad1	pha
	lda #0
	jsr Append1
	pla
	dec a
	bne @pad1
@padded
	jsr chrget
@notSpecial
*** end 26-Jul-92
@next	cmp #$22	;closing quote?
	beq @dun
	jsr Append1
	jsr chrget
	bcc @next
;;;	rts	;removed 3-Oct-92 DAL

@dun
*** added 26-Jul-92 DAL -- finish processing for special strings
***   @stringType = $0000 = raw, 1=pascal, 2=word-string, $8000=cstring
	lda @stringType
	beq @fixedUp
	bmi @cstring
	tax
	ldy #2
	lda [1],y	;get expression length
	dec a
	dec a	;anticipate minus two for wstring
	dex
	bne @notShort
	inc a	;length is only minus one for pstring
	sep #$20
@notShort	ldy #4
	sta [1],y	;store length in first byte or word of expr
	rep #$20
	bra @fixedUp

@cstring	lda #0
	jsr Append1
@fixedUp
*** end 26-Jul-92
	jmp chrget	;munch the closing quote (no-op if already munched)

@stringType	dc.w 0	;0=raw, 1=pstr, 2=wstr, 3=cstr
*
* support "[" {expression} "]" format (concatenate exprs)
*
evalList	name
	jsr chrget
@next	jsr eatblanks
	beq @dun
	cmp #']'
	beq @close

	lda index
	sta @oldIndex
	pha
	pha
	pushlong #tempExpr
	pea nlEvalExpr
	jsl NLService
	pla
	pla
	jsr AppendTemp1
	lda @oldIndex
	cmp Index	;munched any characters?
	beq BadListExpr
	bra @next
@close	jsr chrget
@dun	rts
@oldIndex	dc.w 0
*
* malformed List expression (element took no characters)
*
BadListExpr	name
	pushlong #msgBadList
	_WriteCS
	brl DoAbort
msgBadList	dc.b cr,'*** malformed list ***',cr,0
*
* temporary expression buffer for forming lists
*
tempExpr	dc.w ExprBuffSize
tempLen	dc.w 0
	ds.b ExprBuffSize
*
* AppendTemp1--append tempExpr to expr at [1]
*
AppendTemp1	name
	ldy #0
	ldx tempLen
	beq @dun
@app1	lda tempExpr+4,y
	jsr Append1
	iny
	dex
	bne @app1
@dun	rts
*
* Append1--append a byte (A) to expr at [1], preserving XY
*
Append1	phy
	pha
	ldy #2
	lda [1],y
	cmp [1]	;>= max length?
	bcs @tooLong
	inc a
	sta [1],y
	tay
	iny
	iny
	iny
	pla
	sep #$20
	sta [1],y
	rep #$20
	ply
	rts
@tooLong	pushlong #msgExprLen
	_WriteCS
	brl DoAbort
msgExprLen	dc.b cr,'*** Expression too long ***',cr,0

*****************************************************
*
* Scan num -- scan characters in input line,
* collecting numbers, until a non-digit is
* found.  Return it in A.
*
*****************************************************
snCount	dc.w 0
*
ScanNum	name
	stz snCount
ScanNum1	lda #0
	cpy NumChars
	bcc scCont
	rts
scCont	lda Buffer,y
	iny
	and #$00ff
	jsr digitValue
	bcs scanned
	ldx snCount
	bne @a
	stz Num1
	stz Num1+2
@a	inc snCount
	stz DisasmState
	and #$000f
	ldx #4
@shft	asl Num1
	rol Num1+2
	dex
	bne @shft
	clc
	adc Num1
	sta Num1
	bra ScanNum1

scanned	pha
*
	lda Num1+2
	sta RawNum+2
	lda Num1
	sta RawNum
*
	lda snCount
	cmp #5
	bcc UseBank
	lda Num1+2
	sta CurBank
UseBank	lda CurBank
	sta Num1+2
*
	pla
	clc
	rts
*
* isComma -- just like a regular range, but the second value is the length
*
isComma	name
	sec
	ror CommaFlag	;fall into isPeriod
*
* isPeriod -- range of addresses
*
isPeriod	name
	lda Num1+2
	ldx Num1
	sta RangeSt+2
	stx RangeSt
	lda RawNum+2
	sta RawRangeSt+2
	stx RawRangeSt
	sec
	ror RangeFlag
	rts
*
* BeginRange:
*   no range specified --> return SEC
*   range specified    --> return CLC after setting RangeEnd to the last
*	       number parsed and copying RangeSt into Num1
*	       and addr
*
BeginRange	name
	sec
	bit RangeFlag
	bpl brDone
	lsr RangeFlag
	jsr AdjustForComma	;added 2-Feb-91 for addr1,length form
	lda Num1+2
	ldx Num1
	sta RangeEnd+2
	stx RangeEnd
	lda RangeSt+2
	ldx RangeSt
	sta Num1+2
	stx Num1
	clc
brDone	lda Num1+2
	ldx Num1
	sta addr+2
	stx addr
	rts
*
* AdjustForComma--if CommaFlag then
*    RawNum--;
*    RawNum += RangeSt;
*    Num1 = RawNum;
*
AdjustForComma	bit CommaFlag
	bpl @done
	lsr CommaFlag

	ldx RawNum
	bne @1
	dec RawNum+2
@1	dec RawNum

	clc
	lda RawNum
	adc RangeSt
	sta RawNum
	sta Num1

	lda RawNum+2
	adc RangeSt+2
	sta RawNum+2
	sta Num1+2
@done	rts
*
* CheckRange--compare addr to RangeEnd and return SEC if finished
*
CheckRange	name
	lda addr+2
	cmp RangeEnd+2
	bne rcCmpd
	lda addr
	cmp RangeEnd
	bne rcCmpd
	clc
rcCmpd	rts
*
* upcase(A):A
*
upcase	name
	cmp #'a'
	bcc @isUp
	cmp #'z'+1
	bcs @isUp
	and #$005f
@isUp	rts
*
* downcase(A):A
*
downcase	name
	cmp #'A'
	bcc @isDown
	cmp #'Z'+1
	bcs @isDown
	ora #$0020
@isDown	rts
*
* upcase8 (1-byte A register)
*
upcase8	name
	longa off
	cmp #'a'
	bcc @isUp
	cmp #'z'+1
	bcs @isUp
	and #$5f
	longa on
@isUp	rts
*
* ? -- help
*
isHelp	name
	ldy index
	cpy NumChars
	bcs @plain
	brl isDescribe
@plain	pushlong #CmdsMsg
	_WriteCS
	rts
*
isDollar	name
	pushlong #TermsMsg
	_WriteCS
	rts
*
* print error message
*
Error	name
	pushlong #OopsMsg
	_WriteCS
	pla
	brl DoAbort
*
* 'list' command
*
doList	name
	ldx #18
@ListLp	phx
	jsr List1Line
	jsr crout
	lda addr+2
	ldy addr
	sta CurBank	;4-Feb-88
	sta Num1+2
	sty Num1
	plx
	dex
	bne @ListLp
	rts
*
* List1Line at 'addr'
*
List1Line	name
	lda addr+2
	ldx addr
	jsr praddr
	lda #':'
	jsr cout
	lda DisasmState
	beq normstate
	jsr P8P16block
	bra listed1

normstate
	jsr CheckForLabel	;2-Dec-90 DAL
	bcc listed1	;2-Dec-90 DAL
	jsr AutoTrack
	jsr getbyte
	jsr OpInfo
	jsr PrintBytes

*
* DisasmEntry:
*
* addr = address we're disassembling from
* OpInfo must have already been called on the opcode
*
DisasmEntry	name
	lda mnem
	jsr PrintMnem
	jsr spout
	jsr Operand
	jsr Special
listed1	sec		;length of oper + 1
	lda addr
	adc num
	sta addr
	bcc listed
	inc addr+2
listed	rts
*
* AutoTrack -- follow SEP/REP
*
AutoTrack	name
	lda AutoTrk
	beq noTrack
	jsr getbyte
	cmp #$c2		;REP opcode
	beq trkREP
	cmp #$e2		;SEP opcode
	beq trkSEP
	cmp #$fb		;XCE opcode
	beq trkXCE
noTrack	rts
*
trkXCE	lda #$ffff
	sta mflag
	sta xflag
	rts
*
trkREP	ldy #1
	jsr getbyteY
	tax
	and #$20
	beq trk1
	stz mflag
trk1	txa
	and #$10
	beq trk2
	stz xflag
trk2	rts
*
trkSEP	ldy #1
	jsr getbyteY
	tax
	and #$20
	beq trk3
	ldy #$ffff
	sty mflag
trk3	txa
	and #$10
	beq trk4
	ldy #$ffff
	sty xflag
trk4	rts
*
* CheckForLabel
*
* If this address (addr) is a named procedure, display the
* name and return CLC.
*
CheckForLabel	name
	lda addr+2
	ldy addr
	jsr GetProcName
	bcs @rts
	pha
	phy	;string ptr for nlShowStr
	ldx #15
	jsr PrintXBlanks
	jsr @apostOut
	pea nlShowStr
	jsl NLService
	jsr @apostOut
* set Num = number of bytes until next instruction (use BRL operand)
	ldy #1
	jsr GetWordY
	clc
	adc #2
	sta Num
	clc
@rts	rts

@apostOut	lda #$27	;"'"
	brl cout
*
* P8P16block -- print a byte, word, or longword
* instead of an instruction; we are in the middle
* of a ProDOS call block
*
P8P16block	name
	asl a		;DisasmState*2
	pha
	tax
	jsr (StateTbl,X)
	plx
	lda NextState,X
	sta DisasmState
	rts
*
NextState	DC.W 0	;never used
	dc.w StateP8b	;StateP8a --> StateP8b
	dc.w 0	;StateP8b --> normal
	dc.w StateP16b	;StateP16a --> StateP16b
	dc.w 0	;StateP16b --> normal
;	dc.w StateNameB	;StateNameA --> StateNameB
;	dc.w 0	;StateNameB --> normal

StateTbl	DC.W 0	;never used
	dc.w dByte	;StateP8a
	dc.w dWord	;StateP8b
	dc.w dWord	;StateP16a
	dc.w dLong	;StateP16b
;	dc.w dWord	;StateNameA
;	dc.w dPString	;StateNameB
*
* dByte -- disasm 1 byte
*
dByte	lda #0
	bra dSome
dWord	lda #1
	bra dSome
dLong	lda #3
dSome	sta num
* print blanks
	ldx #19
	jsr PrintXBlanks
	ldy num
some1	jsr getbyteY
	jsr prbyte
	dey
	bpl some1
	rts
*
* dPString -- disassemble a PString inline (for imbedded procedure names)
*
;dPString	jsr getbyte
;	sta num	;one less than number of bytes disassembled
;	ldx #19
;@19	jsr spout
;	dex
;	bne @19
;	lda #'"'
;	jsr @qout
;	pushlong addr
;	pea nlShowStr
;	jsl NLService
;@qout	lda #'"'
;	brl cout
*
* look up mnemonic index, num bytes, addr mode for opcode (A)
*
OpInfo	name
	asl a
	tax
	lda DisasmTbl,X
	pha
	and #$00ff
	sta mnem
	pla
	xba
	pha
	and #$1F
	sta mode
	pla
	and #$E0
	asl a
	asl a
	asl a
	xba
	cmp #4
	bcc gotnum
	sbc #4		;0=checkx, 1=checkm
	asl a		;0=checkx, 2=checkm
	tax
	ldy #1
	lda xflag,x
	bmi gotnum0
	iny	;m or x = 0 --> 2-byte operand
gotnum0	tya
gotnum	sta num
	rts
*
* PrintBytes -- print bytes 0..num at [addr] in hex
*
PrintBytes	name
	ldy #-1
@pb1	iny
	jsr getbyteY
	jsr prbyte
	jsr spout
	cpy num
	bcc @pb1
	lda num
	asl a
	adc num
	tax
@pb2	jsr spout
	inx
	cpx #12
	bcc @pb2
	rts
*
* Print mnemonic number A from mnemonic table (3 chars)
*
PrintMnem	name
	pha
	asl a
	adc 1,s
	sta 1,s
	plx
	lda MnemTbl,x
	jsr cout
	lda MnemTbl+1,x
	jsr cout
	lda MnemTbl+2,x
	brl cout
*
* Operand -- print operand
*
Operand	name
	jsr LeftText
	ldy num
	beq right
Oper1	jsr getbyteY
	sep #$30
	sta bytes,y
	rep #$30
	dey
	bne Oper1
	jsr chkRel
Oper2	lda bytes,y
	jsr prbyte
	dey
	bne Oper2
	jsr chkRel
right	brl RightText
*
* chkRel -- 2's comp add ADDR onto BYTES if relative mode
* (Return with Y=index to byte to start printing at)
*
chkRel	lda mode
	cmp #aREL1
	beq rel1
	cmp #aREL2
	bne notRel
* 2-byte relative (PER, BRL)  does NOT wrap
	lda addr
	adc bytes+1
	clc		;REQUIRED
	adc #2		;corrected 28-Jun-87 DL (was adc #3)
	sta bytes+1
	ldy #2
	rts
notRel	ldy num
	rts
* 1-byte relative
rel1	lda bytes+1
	and #$ff
	cmp #$80
	bcc forward
	ora #$ff00	;sign-extend it
forward	clc
	adc addr
	clc		;REQUIRED
	adc #2
	sta bytes+1
	ldy #2
	rts
*
* LeftText
*
LeftText	name
	lda mode
	asl a
	asl a
	tax
	lda LTtable+2,x
	pha
	lda LTtable,x
	pha
	_WriteCS
	rts
*
* RightText
*
RightText	name
	lda mode
	asl a
	asl a
	tax
	lda RTtable+2,x
	pha
	lda RTtable,x
	pha
	_WriteCS
	rts
*
* getbyte  -- fetch byte [addr]
* getbyteY -- fetch a byte from [addr],y
*
getbyte	name
	ldy #0
getbyteY	name
	jsr getwordY
	and #$00ff
	rts
*
getword	name
	ldy #0
getwordY	name
	lda $e0c068
	pha
	lda $e0c08b
	lda WhichLCBank
	beq lc0
	lda $e0c083
lc0	phd
	phx
	lda addr+2
	pha
	lda addr
	pha
	tsc
	tcd
	lda [1],y
	plx
	plx
	plx
	pld
	tax
	pla
	sta $e0c068
	txa
	rts
*
* PutByte
* PutByteY -- store byte from A at [addr]
*
putbyte	name
	ldy #0
putbyteY	name
	sta @byte
	lda $e0c068
	pha
	lda $e0c08b
	lda $e0c08b
	lda WhichLCBank
	beq @lc0
	lda $e0c083
	lda $e0c083
@lc0	phd
	phx
	lda addr+2
	pha
	lda addr
	pha
	tsc
	tcd
	sep #$30
	lda @byte
	sta [1],y
	rep #$30
	plx
	plx
	plx
	pld
	tax
	pla
	sta $e0c068
	txa
	rts
@byte	dc.w 0

*
* praddr -- print bb/aaaa
*
praddr	name
	jsr prbyte
	lda #'/'
	jsr cout
	txa		;fall into prword
*
* prword -- print A in hex
*
prword	name
	pha
	xba
	jsr prbyte
	pla		;fall into prbyte
*
* prbyte -- print 1 hex byte from A
*
prbyte	name
	pha
	lsr a
	lsr a
	lsr a
	lsr a
	jsr prnib
	pla		;fall into prnib
*
* prnib -- print 1 hex nybble from A
*
prnib	name
	and #$000f
	ora #'0'
	cmp #'9'+1
	bcc cout
	adc #6
	bra cout
*
* PrintXBlanks (X>0)
*
PrintXBlanks	name
	jsr spout
	dex
	bne PrintXBlanks
	rts
*
* cout
*
prwordSpout	name
	jsr prword
	bra spout

spout2	name
	jsr spout
spout	name
	lda #' '
	bra cout
crout	name
	jsr Pause
	lda #cr
cout	name
	pha
	phx
	phy
	pha
	pea $0001	;GS/OS string on stack
	tsc
	pea 0
	inc a
	pha
	pea cbWrite
	jsl doCallBack	;removes ptr and command
	pla	;throw out string
	pla	;throw out string length
	ply
	plx
	pla
	rts
*
* UnPause--quit stepping
*
UnPause	name
	lsr SteppingFlag
	rts
*
* Pause -- let the user pause the display.
*
Pause	name
	jsr Pause2
	bcc @pauseEx
	brl DoAbort
@pauseEx	rts


Pause2	name
	bit SteppingFlag
	bmi pStepping
	jsr CheckKey
	bcs PauseDone
	cmp #SPACE
	beq StartStepping
	jsr CheckAbort
	bcs Aborting
PauseDone	stz SteppingFlag
	clc
	rts
Aborting	stz SteppingFlag
	sec
	rts
*
StartStepping	name
;	sec
	ror SteppingFlag
pStepping
	jsr CheckKey
	bcs pStepping
	jsr CheckAbort
	bcs Aborting
	cmp #SPACE
	beq StepAgain
	stz SteppingFlag
StepAgain	clc
	rts

SteppingFlag	dc.w 0
*
* CheckAbort -- return SEC if ESC or Apple-. pressed
*
CheckAbort	name
	cmp #ESC
	beq @isAbort
	cmp #'.'
	bne @notAbort
	lda AppleKey
	beq @notAbort
@isAbort	sec
	rts
@notAbort	clc
	rts
*
* CheckKey -- return SEC if no key, CLC if key.  A=key,
*             AppleKey nonzero if Apple was down
*
* This routine calls the Event Manager if it's active.
*
CheckKey	name
	jsr CheckKy2
	bcs @ckExit
	cmp #$0014	;Ctrl-T?
	bne @notT
	jsr TwiddleSHR	;30-Jul-90
	bra CheckKey
@notT	clc
	ldy AppleKey
	beq @ckExit
	tax
	jsr AppleSpecial
	bcc CheckKey
	clc		;30-Jan-90 DAL
@ckExit	rts

CheckKy2	name
	pha
	_EMStatus
	pla
	beq chkkey2
*
	pha
	pea $0028		;keydown+autokey events ONLY
	pushlong #MyEvent
	_GetNextEvent
	lda MyEvent+$e		;modifiers
	and #$0100		;AppleKey bit
	sta AppleKey
	pla
	beq cknone
	lda MyEvent+2		;key hit
	and #$00ff
	clc
	rts
*
cknone	sec
	rts
*
chkkey2	sep #$20	;event manager not active
	longa off
	lda $e0c061
	and #$80
	sta AppleKey
	stz AppleKey+1
	lda $e0c000
	rep #$20
	longa on
	bpl cknone
	sep #$20
	sta $e0c010
	rep #$20
	and #$7f
	clc	;added 8-Oct-89
	rts
*
MyEvent	DC.W 0,0,0,0,0,0,0,0
AppleKey	DC.W 0
**********************************************
*
* PushLong #message, jsr WriteNoVoice displays
* a C string if and only if voiceFlag is false
*
**********************************************
WriteNoVoice	name
	ply
	plx
	pla
	phy
wnvAX	bit voiceFlag
	bmi omitMsg
	pha
	phx
	_WriteCS
omitMsg	rts

**********************************************
**********************************************
*
* Do special stuff in the right margin of the
* disassembly.
*
Special	name
*
* See if this is a JSR or JSL to a named procedure
*
@notNamed	jsr getbyte
	cmp #$22	;JSL
	beq @JSLName
	cmp #$20
	bne @notJSRName

* JSR to named proc?
@JSRName	ldy #1
	jsr getWordY
	tay
	lda addr+2
	jsr GetProcName
	bcs @cont
	ldx #4	;4 blanks
@showname	pha
	phy	;address for nlShowStr
	jsr PrintXBlanks
	lda #'>'
	jsr cout
	pea nlShowStr
	jsl NLService
	rts

* JSL to named proc?
@JSLName	ldy #1
	jsr getwordY
	pha
	ldy #3
	jsr getbyteY
	ply
	jsr GetProcName
	bcs @cont
	ldx #2	;2 blanks
	bra @showname

@notJSRName
@cont
*
* for JSL, JMP>, JMP, etc--trace ahead looking for something
* interesting
*
	jsr getbyte
	cmp #$80		;BRA
	beq lkAhead
	cmp #$82		;BRL
	beq lkAhead
	cmp #$22		;JSL
	beq lkAhead
	cmp #$4c		;JMP
	beq lkAhead
	cmp #$5C		;JMP long
	bne spContinue
lkAhead	jsr ToolLookahead
	bcs spContinue
	rts
spContinue	name
*
* show F8 routine or softswitch for 2-byte
* no-extra-text instructions
*
	lda mode
	bne noF8SS
	lda num
	cmp #2
	beq absF8SS

	cmp #3
	bne noF8SS
* allow long addressing $00Cxxx, $01Cxxx, $E0Cxxx, $E1Cxxx
	ldy #2
	jsr getWordY
	and #$fff0
	cmp #$00C0
	beq longF8SS
	cmp #$01C0
	beq longF8SS
	cmp #$E0C0
	beq longF8SS
	cmp #$E1c0
	beq longF8SS
	bra noF8SS
*
* a 2-byte instruction may or may not refer to a bank with
* softswitches or ROM in it, so the >r option disables display
* of the tags
*
absF8SS	name
	lda enableF8SS
	beq noF8ss

	ldy #2
	jsr getbyteY
	cmp #$c0
	bne noPEAC0xx
	jsr getbyte
	cmp #$f4	;disallow PEA $C0xx
	beq noF8SS
noPEAC0xx
longF8SS	jsr spout2
	ldy #1
	jsr getwordY
	tax
	lda #SecF8andSS
	jsr FindPrint0
	bcs noF8SS
	rts

noF8SS
	jsr getbyte
	cmp #$20	;check for JSR
	beq isJSR
	cmp #$5c	;handle JMP long like JSL
	beq isJML
	cmp #$22	;check for JSL
	bne notJSL
isJML	brl isJSL
notJSL	rts
*
* JSR -- check for $BF00 in bank 0 = ProDOS 8
*
isJSR	name
	lda addr+2
	and #$00ff
	bne noFun1	;ProDOS 8 call in bank 0 only
	iny	;y=1
	jsr getbyteY
	cmp #0
	bne noFun1
	iny	;y=2
	jsr getbyteY
	cmp #$BF
	bne noFun1
	iny	;y=3
	jsr getbyteY
	tax	;search value
	lda #SecP8
	jsr FindPrint
	lda #StateP8a
	sta DisasmState
noFun1	rts
*
* JSL -- check for $E100A8 = ProDOS 16 or GS/OS
*
*        $E100B0 = stack-based P16 or GS/OS
*    and $E10000,4,8,C = tool call
*
isJSL	name
	ldy #3
	jsr getbyteY
	cmp #$E1
	beq isE1oper
	cmp #$E0
	beq isE0oper
	cmp #$01
	beq is01oper
	bra E1Vec2

isE1oper	dey		;y=2
	dey		;y=1
	jsr getwordY
	cmp #$00A8		;check $E100A8
	beq doP16z
	cmp #$00B0		;check $E100B0
	beq doP16stk0
	bra doE1vec

doP16z	brl doP16
doP16stk0	brl doP16stk
*
* operand is $E0xxxx
*
isE0oper	dey		;y=2
	dey		;y=1
	jsr getwordY
	tax
	lda #SecE0vec
	brl NameTheOperand
*
* handling for $01xxxx vectors
*
is01oper	dey		;y=2
	dey		;y=1
	jsr getwordY
	tax
	lda #Sec01vec
	brl NameTheOperand
*
* $E1xxxx vectors
*
doE1vec	tax
	lda #SecE1vec
;	brl NameTheOperand	;fall through
NameTheOperand	name
	jsr FindPrint0
	bcs NameTheAddress
	rts
*
* Check the address we're disassembling...it may be a cool vector
* with a name we can display.
*
NameTheAddress	name
E1Vec2	lda Num1+2
	cmp #$00E1
	bne E0Vec2
	ldx Num1
	lda #SecE1Vec
	brl FindPrint0
*
E0Vec2	cmp #$00e0
	bne B01Vec2
	ldx Num1
	lda #SecE0Vec
	brl FindPrint0
*
B01Vec2	cmp #$0001
	bne NoFun2
	ldx Num1
	lda #Sec01Vec
	brl FindPrint0
*
noFun2	name
	rts
*
* ToolLookahead -- look for a tricky toolbox call, and print it
*    if found.  Return CLC if we're done.  Search starting at
*    addr.
*
ToolLookahead	name
	stz sJSLcount
	stz sJSLlevel
	stz sJSLxval
	stz sJSLpeaval
	stz sJSLsuccess
	pushlong addr
;	lda addr
	pha
	sec
	sbc #3
	sta addr
	jsr getbyte
	cmp #$A2	;LDX#
	bne sJSLnoLDX
	ldy #1
	jsr getwordY
	sta sJSLxval
	lda addr
	sec
	sbc #3
	sta addr
	jsr getbyte
sJSLnoLDX
	cmp #$F4	;PEA
	bne sJSLnoPEA
	ldy #1
	jsr getwordY
	sta sJSLpeaVal
sJSLnoPEA	pla
	sta addr
sJSLnext	inc sJSLcount
	lda sJSLcount
	cmp #10
	bcs sJSLfail
	lda sJSLlevel
	cmp #2
	bcs sJSLfail
	jsr interpret
	bcc sJSLnext
	clc
	lda sJSLsuccess
	bne sJSLexit
sJSLfail	sec
sJSLexit	pla
	sta addr
	pla
	sta addr+2
	rts
*
* interpret(addr) --> addr, level, C, Z
*
* Exit: SEC if we're done (successful or aborted)
*       sJSLsuccess nonzero if successful
*
interpret	name
	jsr getbyte
	cmp #$A2	;LDX#
	beq sJSLldx
	cmp #$4C	;JMP $xxyy
	beq sJSLjmp
	cmp #$5C	;JMP $xxyyzz
	beq sJSLjml
	cmp #$22	;JSL $xxyyzz
	beq sJSLjsl0
	cmp #$80	;BRA *+$xx
	beq sJSLbra
	cmp #$82	;BRL *+$xxyy
	beq sJSLbrl
	sec
	rts
sJSLjsl0	brl sJSLjsl
*
sJSLbra	ldy #1
	jsr getbyteY
	bit #$0080
	beq @sxPlus
	ora #$ff00
@sxPlus	clc	;don't add as much as BRL
	bra sBranch
*
sJSLbrl	ldy #1
	jsr getwordY
	sec
sBranch	adc #2
	clc	;needed!
	adc addr
	sta addr
	clc
	rts
*
sJSLldx	ldy #1
	jsr getwordY
	sta sJSLxval
	clc
	lda addr
	adc #3
	sta addr
	clc
	rts
*
sJSLjmp	ldy #1
	jsr getwordY
	sta addr
	clc
	rts
*
JSLplain	inc sJSLlevel
JMLplain	ldy #3
	jsr getbyteY
	pha
	ldy #1
	jsr getwordY
	sta addr
	pla
	sta addr+2
	clc
	rts
*
sJSLjml	ldy #2
	jsr getwordY
	cmp #$E100
	bne chkJML2
	ldx sJSLxval
	beq JMLplain
	ldy #1
	jsr getbyteY
	jsr checkTVec
	bne JMLplain
	bra sJSLwhee
*
chkJML2	ldy #2
	jsr getwordY
	cmp JumpService+2
	bne JMLplain
	ldy #1
	jsr getwordY
	cmp JumpService+1
	bne JMLplain
* it's a Nifty List service call (being disassembled)
isNLService	lda #SecNLService
	ldx sJSLpeaval
	jsr FindPrint
	inc sJSLsuccess
	sec
	rts
*
sJSLjsl	ldy #2
	jsr getwordY
	cmp #$E100
	bne chkJSL2
	ldx sJSLxval
	beq JSLplain0
	ldy #1
	jsr getbyteY
	jsr checkTVec
	beq sJSLwhee
JSLplain0	brl JSLplain
*
chkJSL2	cmp JumpService+2
	bne chkJSL3
	ldy #1
	jsr getwordY
	cmp JumpService+1
	bne chkJSL3
	bra isNLService
*
chkJSL3	cmp #$E102	;check for $E10220 (HyperCardIIGS)
	bne chkJSL4
	ldy #1
	jsr getwordY
	cmp #$0220
	bne chkJSL4
	ldx sJSLxval
	lda #secHyperCard
	jsr FindPrint
	lda #' '
	sta fpPadChar2
	inc sJSLsuccess
	sec
	rts
chkJSL4	brl JSLplain0
*
* whee! Found JSL $E100aa with X=sJSLxval
*
sJSLwhee	lsr a
	lsr a
	lsr a
	clc
	adc #SecSysTool
	ldx sJSLxval
	jsr FindPrint
	lda #' '
	sta fpPadChar2
	inc sJSLsuccess
	sec
	rts
*
checkTVec	cmp #$00
	beq tvecExit
	cmp #$08
	beq tvecExit
	cmp #$04
	beq tvecAlt
	cmp #$08
	bne tvecExit
tvecAlt	php
	ldx #'>'
	stx fpPadChar2
	plp
tvecExit	rts
*
sJSLcount	dc.w 0
sJSLlevel	dc.w 0
sJSLxval	dc.w 0
sJSLpeaval	dc.w 0
sJSLsuccess	dc.w 0
*
* doP16stk -- look for PEA $abcd before this JSL $E100B0
*
doP16stk	name
	lda addr
	pha
	sec
	sbc #3
	sta addr
	jsr getbyte
	cmp #$f4	;PEA
	bne unknP16
	ldy #1
	jsr getwordY
	tax
	pla
	sta addr
	lda #SecP16
	brl FindPrint
unknP16	pla
	sta addr
	rts
*
* ProDOS 16 or GS/OS call
*
doP16	name
	ldy #4
	jsr getwordY
	tax
	lda #SecP16
	jsr FindPrint
	lda #StateP16a
	sta DisasmState
	rts
*
* FindPrint -- search section A of the data
* for the word in X.  Returns SEC if nothing found.
*
* Uses IndexedFlag (bit 15 = find the Xth entry in section)
*
* JustFind returns pointer in FindResult/4 if found (else SEC).
*
JustFind	name
	ldy #$8000
	sty Silent
	stz findResult+2
	stz findResult
	bra Fnd2
FindPrint0	name
	ldy #1	;this entry prints nothing, not '--unknown--'
	sty Silent
	bra FndP

FindPrint	name
	stz Silent
FndP	stz IndexedFlag
Fnd2	stx target
	asl a	;double sec #
	asl a	;quadruple section number (27-May-91 DAL)
	tay
* If we have no data, do nothing
	lda DataPtr+2
	ora DataPtr
	bne SomeData
	sec
	rts
SomeData	phd	;store dirpage
	pushlong DataPtr
	tsc
	tcd	;dir page now on stk

***	lda [1],y 	;head of linked list for sec
***	tay
*** added 27-May-91 DAL
	iny
	iny
	lda [1],y
	tax
	dey
	dey
	lda [1],y
	clc
	adc <1
	sta <1
	txa
	adc <3
	sta <3
	ldy #0
*** end of 27-May-91 DAL

	jsr FindPr2
	pla	;get rid of DataPtr
	pla	;get rid of DataPtr+2
	pld	;restore dir page
	rts	;C preserved from FindPr2
*
Silent	DC.W 0
*
* FindPr2 -- do the work, now that things
* are set up nicely:
*   Y=index to beginning of section
*   [1] = pointer to a particular section
*
* return SEC if nothing is printed
*
FindPr2	name
	ldx IndexedFlag
	bmi doFindIndx

	bra enter1	;27-May-91 DAL

find1	cpy #0
	beq notfound
enter1	lda [1],y
	cmp target
	beq foundmatch
	iny	;advance to link field
	iny
	lda [1],y	;next item in linked list
	tay
	bra find1
notfound	lda Silent
	bne isSil
	lda fpPadChar2	;30-May-91 DAL
	sep #$20	;30-May-91 DAL
	sta MsgNotFound+1	;30-May-91 DAL
	rep #$20	;30-May-91 DAL
	pushlong #MsgNotFound
	_WriteCS
	clc
	rts
isSil	sec
	rts
*
* foundmatch -- compute abs address of the
* string to print, and print it
*
foundmatch	clc
	tya
	adc #5	;skip data & link and blank
	adc 1
	sta 1
	bcc @ok
	inc 3
@ok	lda Silent
	bmi JustReport
	jsr spout
	lda fpPadChar2
	jsr cout
	pei 3	;push address high
	pei 1	;push address low
	_WriteCS
	clc
	rts

doFindIndx	dec target
	beq @idxFound
	iny
	iny
	lda [1],y
	tay
	bne doFindIndx
	stz 1
	stz 3
	bra JustReport
@idxFound
	lda [1],y
	sta target
	clc
	tya
	adc #5
	adc 1
	sta 1
	bcc @1
	inc 3
@1
JustReport	lda 3
	ldy 1
	sta FindResult+2
	sty FindResult
	clc
	rts
FindResult	dc.l 0
fpPadChar2	dc.w $0020

**************************************************************
*
* GetProcName
*
* Inputs: AY = address
*
* Outputs: sec: no name found
*          clc: AY=pointer to pstring
*
*
* We recognize procedure names with the following convention:
*
*     addr:  BRL @1
*            $777x
*            pString Name
*     @1:    ...
*
**************************************************************
GetProcName	name
	phd
	pha
	phy
	tsc
	tcd
	lda [1]
	and #$00ff
	cmp #$82	;BRL?
	bne @noName
	ldy #3	;offset to signature
	lda [1],y
	and #$fff0	;added 30-May-91 DAL
	cmp #$7770	;$777x signature?
	bne @noName
	ldy #5	;offset to pString length
	lda [1],y
	and #$00ff	;length of pString
	clc
	adc #3
	ldy #1	;offset to BRL operand
	cmp [1],y	;does BRL operand = pString length + 3?
	bne @noName
	clc
	lda 1
	adc #5
	tay
	lda 3
	adc #0
;	clc
	dc.b $24	;bit <$xx
@noName	sec
	plx
	plx
	pld
	rts


**************************************************************
*
* -- parameter settings --
*
GLOBALS
CONFIGPARMS
xflag	DC.W 0	;bit15 = 8-bit X/Y regs
mflag	DC.W 0	;bit15 = 8-bit A-reg
WhichLCBank	DC.W 0	;language card bank 0/1
AutoTrk	DC.W $ffff	;nonzero = follow Rep/Sep
WhichHList	DC.W 0	;0/1/2 = e1/1600, e1/1604, e1/1608
PrinterSlot	dc.w 1	;default printer slot (1-7)
enableF8ss	dc.w $ffff	;allow softswitch/F8 tags
DataFlags	dc.w 1	;load data file at boot(1), but not purgable(2)
enableAbbrH	dc.w $ffff	;enables abbreviation of ;h output
voiceFlag	dc.w 0	;user is using a voice synthesizer
InfoTablePtr	dc.l BEGININFOTABLE	;constant!
ENDPARMS
*
* Session Data
*
theSess	dc.l $55550000
sessList	dc.l stdCallBack
	ds.b MaxSessions*ssnSize

CheckPrimarySess	name
	ldy theSess	;beq = primary
	rts

doKillSessions	name
* %%% need to kill them all
	lda #0
	pha
	pha
	tsc
	pea 0
	inc a
	pha
	pea cbDeath
	jsl doCallBack
	pla
	plx
	rts

doFlush	name
	pea 0	;25-Oct-90 DAL
	pea 0
	pea cbFlush
	jsl doCallBack
	rts

doGetKey	name
	jsr doFlush
	pea $000d	;default = RETURN
	tsc
	pea 0
	inc a
	pha
	pea cbGetKey
	jsl doCallBack
	pla
	rts

doCallBack	dc.b $5C	;long jump
theCallBack	dc.l stdCallBack

*
* Miscellaneous Local Storage
*
gBusyCount	dc.w 0	;number of active NL text sessions?
untoggleScrnFlag	dc.w 0	;nonzero = need to untoggle screen
DescrFlag	DC.W 0	;nonzero = describe command, not execute
MainStack	DC.W 0
MainDP	DC.W 0
index	DC.W 0	;index into command line
CurBank	DC.W 0	;bank number
RangeSt	DC.L 0	;number before period
RangeEnd	DC.L 0	;number after period
RangeFlag	DC.W 0	;high bit means range pending
CommaFlag	dc.w 0	;high bit means a "comma" range is pending
Num1	DC.L 0	;1st number parsed
RawNum	dc.l 0	;Num1 without special bank-number handling
RawRangeSt	dc.l 0	;RangeSt from RawNum
HandyAddr	DC.L 0	;used by '#'
addr	DC.L 0	;address to list from
OldB	DC.W 0	;saved Bank reg
OldD	DC.W 0	;saved Directpg reg
mnem	DC.W 0	;index into mnemonic table
num	DC.W 0	;# bytes in operand
mode	DC.W 0	;address mode this instr
char	DC.W 0	;a character for my COUT
bytes	DC.L 0	;copy of operand bytes
target	DC.W 0	;word searching for
DisasmState	DC.W 0	;keeps track of stuff for inline parms

ResourceMgrID	dc.w 0	;ID of Resource.Mgr file

pascBuffer	dc.b 0	;Pascal length byte for Buffer
Buffer	DS.B BuffSize	;input buffer
NumChars	DC.W 0	;# characters read into buffer
*
QuoteSec	DC.W 0
WhoseSec	DC.W secSysTool	;section index to System or User tools
WhoseTools	DC.W 0	;0=system, $8000=user
*
stackImage	ds.b 256

********************************************************************
********************************************************************
*
* initialization & data file processing
*
********************************************************************
*
* init--gets called exactly once, during boot (except on very old
*       system disks [before 2.0?])
*
********************************************************************
init	name
	php
	rep #$30
	phb
	phk
	plb
*
	pha
	_MMStartUp
	pla
	sta infoMemID
	ora #$0100
	sta MyID
*
* remove old copy of Nifty List
*
	jsr RemoveOldNL
*
* initialize the History Manager (for command-line history)
*
	jsr HistoryInit
*
* Set prefix 0 to the Nifty List directory
*
* Keep it here while we load the Config file,
* data files, and modules
*
	jsr SetNLPrefix0
*
* Load the config file
*
	jsr LoadConfig
*
* Load the data file if configured to load it at boot time (>d)
*
	lda DataFlags
	and #1
	beq noBootRead
	jsr ReadData
noBootRead
	jsr DoMessageCenter
	jsr DoDebugHook		;20-Oct-90 DAL
	jsr ComputePatchID		;30-May-91 DAL
	jsr InstallReqProc		;1-Jun-91 DAL
	jsr LoadModules

	lda #actBirth		;tell all the modules they're alive
	jsr NotifyModules		;8-Jul-90

	jsr FixPrefix0
*
* Chain into SysDeath vector
*
	php
	sei		;keep ints disabled for get/set vec
	pha
	pha
	pea 7
	_GetVector
	pla
	sta DeathChain+1
	pla
	sta DeathChain+3
	pea 7
	pushlong #DeathTsk
	_SetVector
	plp
*
	plb
	plp
	rts
*********************************************
DeathTsk	name
	php
	sep #$30
	longa off
	lda #0
	sta >$E100FF
	rep #$30
	longa on
	pea 0
	_EMStatus
	pla
	beq Death1
	_EMShutDown
Death1	plp
DeathChain	jmp >$777777
	dc.b 0
*********************************************
*********************************************
*
* RemoveOldNL--if there's an old Nifty List
* lying around, get rid of it.
*
RemoveDone	rts
RemoveOldNL	name
	pha
	_TLVersion
	pla
	and #$0fff	;was $7fff 7-Jan-91 DAL
	cmp #$0300
	bcc RemoveDone

	pha
	pha
	pea 0		;don't create message
	pushlong #MsgBlock
	_MessageByName
	ply		;id of old NL message
	pla		;flag (ignore)
	bcs RemoveDone

	pea 2		;get message
	phy		;message id
	pha
	pha		;space for NewHandle
	lda #0
	pha
	pha
	ldx MyID
	phx		;id
	pha		;attr
	pha
	pha
	_NewHandle
	lda 3,s
	sta mcHandle+2
	lda 1,s
	sta mcHandle
	_MessageCenter

	pushlong mcHandle
	phd
	tsc
	tcd
	ldy #2
	lda [3],y
	tax
	lda [3]
	sta 3
	stx 5

	ldy #$28
	lda [3],y
	sta OldService+1
	iny
	lda [3],y
	sta OldService+2

	pld
	pla
	pla

	pushlong mcHandle
	_DisposeHandle

	pha
	pha
	pushlong #theOldID
	pea nlRemoveNL
	jsl OldService
	ply
	pla
	beq @dun

	pha
	phy
	_RemoveCDA

	pha
	lda theOldID
	pha
	pea 0
	_UserShutDown
	pla

@dun	rts

mcHandle	dc.l 0
theOldID	dc.w 0
OldService	jmp >$777777

*********************************************
*
* DoMessageCenter--put a nice message into the
* messageCenter, giving a pointer to the Nifty
* List Service routine.
*
*********************************************
DoMessageCenter	name
	pha
	_TLVersion
	pla
	and #$0fff	;was $7fff 7-Jan-91 DAL
	cmp #$0300
	bcc noMsgCenter
	pha
	pha
	pea 1	;create it
	pushlong #MsgBlock
	_MessageByName
	pla
	sta myMsgID
	pla
noMsgCenter	rts
*
MsgBlock	dc.w MsgBlockEnd-MsgBlock
	dc.b 31,'DAL Systems: Nifty List service'
	dc.l NLService
MsgBlockEnd

*********************************************
*
* Install or remove the Request Proc
*
*********************************************
InstallReqProc	name
	ldx #myRequestProc>>16
	ldy #myRequestProc
	bra doReqProc

RemoveReqProc	name
	ldx #0
	txy

doReqProc	phx
	phy
	pha
	_QDVersion
	pla
	ply
	plx

	and #$0fff
	cmp #$0307
	bcs @have307
	rts	;added 8-Jun-91 DAL

@have307	pushlong #reqProcName
	lda infoMemID	;memory id
	and #$f0ff
	pha
	phx
	phy
	_AcceptRequests
	rts

reqProcName	dc.b 23,'DAL Systems~Nifty List~'
*
* myRequestProc:
*    WORD: space for result (set bit 15 if claimed)
*    WORD: reqProc
*    LONG: input
*    LONG: output pointer
*    RTL
*
myRequestProc	phd
	tsc
	tcd

@oldD	equ 1
@rtl	equ @oldD+2
@output	equ @rtl+3
@input	equ @output+4
@request	equ @input+4
@result	equ @request+2

	lda <@request
	bpl @notMine
	and #$7fff

	ldx #0
	phx
	phx	;result space
	pei <@input+2
	pei <@input
	pha	;function code
	jsl NLService
	plx
	pla	;result in AX

	ldy <@output+1	;does caller want result?
	beq @done
	ldy #4
	sta [<@output],y
	dey
	dey
	txa
	sta [<@output],y

@done	sec
	ror <@result

@notMine	pld
	lda 2,s
	sta 2+10,s
	lda 1,s
	sta 1+10,s
	pla
	pla
	pla
	pla
	pla
	rtl

*********************************************
*
* DoDebugHook--call DebugSetHook ($0BFF) with
* a pointer to a routine that enters Nifty List
* from within GSBug.
*
* UndoDebugHook--call DebugSetHook(nil).
*
*********************************************
UndoDebugHook	name
	lda #0
	pha
	pha
	bra doDbgHk

DoDebugHook	name
	pushlong #DebugHook
doDbgHk
** 30-Nov-90: if debug version less than $1511, don't call DebugSetHook
	pea 0
	_DebugVersion
	pla
	cmp #$1511
	bcc @error
**
	_DebugSetHook
	bcc @ok
	cmp #$0010
	bcs @ok
@error	pla	;dispatcher error--pull pointer
	pla
@ok	rts

*
* DebugHook--called by GSBug "n" command.
*
* A couple registers contain a pointer to the command line,
* but we aren't using it right now.
*
DebugHook	name
	phb
	phk
	plb
	sep #$20
	longa off
	lda >$e0c035
	pha
	and #$fe	;enable text shadowing
	sta >$e0c035
	rep #$20
	longa on

	jsr SetDefaultAddr

	pha
	pha
	_SaveTextState	;leave handle on stack

	pha
	pha
	pha
	pha
	pea nlEnter
	jsl NLService
	pla
	pla

	_RestoreTextState	;handle already on stack

	sep #$20
	longa off
	pla
	sta >$e0c035
	rep #$20
	longa on

	plb
	rtl
*
* If the debugger will give us a default address, use it
* (For ex, you can hit "n" from GSBug, when "w" in NL to
* see where you were.)
*
SetDefaultAddr	name
	tsc
	sta @oldStack
	pha
	pha	;space for result
	pea 0	;selector = default address
	_DebugGetInfo
	bcc @setaddr
	lda @oldStack
	tcs
	rts

@setaddr	pla
	sta Num1
	pla
	sta Num1+2
	sta CurBank	;added 17-Oct-91 DAL
	rts

@oldStack	dc.w 0

*********************************************
*********************************************
*
* LoadConfig--load the config file
*
*********************************************
LoadConfig	name
	jsr CheckP16
	bcs cfgDun
	jsl P16
	dc.w $10		;OPEN
	dc.l OpenCfg
	bcs cfgDun
	lda OpenCfg
	sta rwConfig
	jsl P16
	dc.w $12		;READ
	dc.l rwConfig
	jsl P16
	dc.w $14		;CLOSE
	dc.l OpenCfg
cfgDun	rts

SaveConfig	name
	jsr SetNLPrefix0
	bcs @x
	jsr SaveConfig2
	jsr FixPrefix0
@x	rts
*
SaveConfig2	jsr CheckP16
	lda #$ffff
	bcs cfgErr
	jsl P16
	dc.w $1		;CREATE
	dc.l cfgCreate
	bcc scOK
	cmp #$47		;duplicate file error ok
	bne cfgErr
scOK	jsl P16
	dc.w $10		;OPEN
	dc.l OpenCfg
	bcs cfgErr
	lda OpenCfg
	sta rwConfig
	jsl P16
	dc.w $13		;WRITE
	dc.l rwConfig
	pha
	jsl P16
	dc.w $14		;CLOSE
	dc.l OpenCfg
	pla
cfgErr	tax
	bne cfgErr2
	rts
cfgErr2	pha
	pushlong #SaveErr
	_WriteCS
	lda 1,s
	jsr prwordSpout
	plx
	lda #secErrors		;display error code name
	jsr FindPrint
	jmp crout
SaveErr	dc.b 'Could not save NList.Settings: $',0

OpenCfg	dc.w 0
	dc.l CfgName
	dc.l 0

rwConfig	dc.w 0
	dc.l CONFIGPARMS
	dc.l ENDPARMS-CONFIGPARMS
	dc.l 0		;xfer count

cfgCreate	dc.l CfgName
	dc.w $C3
	dc.w cfgFileType
	dc.l cfgAuxType
	dc.w 1
	dc.w 0,0

*********************************************
*********************************************
*
* Read the data file file from startup disk
* and preprocess it so we can use it easily.
*
* After processing, we have DataHandle = a
* handle to the hunk of memory the data
* occupies.  We keep this handle locked while
* executing, but unlock it before leaving.
*
*********************************************
ReadData	name
*
* Dispose of the old handle if it's been purged
*
	lda DataHandle+2
	beq noDataHndl
	pushlong DataHandle
	_DisposeHandle
noDataHndl
*
* open file NLIST.DATA
*
	stz clRefNum
	jsr CheckP16
	lda #$00ff
	bcs CantR0
	_OPEN OpenParms	;first try NList.AppleData (19-Jan-91 DAL)
	bcc opened

	lda #Filename2
	sta theOpenDataName	;try again with NList.Data (19-Jan-91 DAL)
	_OPEN OpenParms
	bcc opened

CantR0	brl CantRead
opened	lda opRefNum
	sta clRefNum
	sta EOFRefNum
	sta rdRefNum
*
* get end-of file
*
	_GET_EOF EOFParms
	bcc CanRead
	brl CantRead
CanRead	lda EOFval+2
	ldx EOFval
	sta rdAmount+2
	stx rdAmount
*
* DataHandle = NewHandle(LOCKED,ID,size of file+headerSize+40)
*
	pha
	pha		;space for NewHandle
	clc
	lda EOFval
	adc #HeaderSize+40
	tax		;low word of block size
	lda EOFval+2
	adc #0
	pha		;push high word of size
	phx		;push lo size
	lda MyID		;user ID
	pha
	ldx #$8008	;attributes=LOCKED+NO_SPECIAL_MEM
	lda DataFlags
	and #2
	beq DataAttr
	ldx #$8208
DataAttr	phx
	lda #0		;push address=0 (allocate anywhere)
	pha
	pha
	_NewHandle
	bcc @canread
	ply		;20-Feb-90
	ply		;20-Feb-90
	brl CantRead
@canread	pla
	sta DataHandle
	pla
	sta DataHandle+2
*
	jsl deref	;dereference DataHandle-->DataPtr
	lda DataPtr
	clc
	adc #HeaderSize
	sta rdWhere
	lda DataPtr+2
	adc #0
	sta rdWhere+2
*
* read file into RAM
*
	_READ ReadParms
	bcs CantRead00
*
* close file
*
	_CLOSE CloseParms
	bcc didClose
CantRead00	brl CantRead
didClose
*
* Append some asterisks to end of file in case it doesn't have
* enough sections in it!
*
	phd
	pushlong DataPtr
	tsc
	tcd
	lda EOFval
	clc
	adc #HeaderSize
	tax
	lda EOFVal+2
	adc #0
	tay	;YX=EOFVal+HeaderSize

	clc
	txa
	adc <1
	sta <1
	tya
	adc <3
	sta <3	;<1 = += (EOF+headerSize)

	lda #$0D2A	;Asterisk, Return
	ldx #8
	ldy #0
@storAst	sta [1],y
	iny
	iny
	dex
	bne @storAst

* strip bit 7
	clc
	lda DataPtr
	adc #HeaderSize
	sta <1
	lda DataPtr+2
	adc #0
	sta <3

	ldx EOFVal+2
	beq @clearLastChunk
	ldy #0
@stripOneBank	lda [1],y
	and #$7f7f
	sta [1],y
	iny
	iny
	bne @stripOneBank
	inc <3
	dex
	bne @stripOneBank

@clearLastChunk	lda EOFVal
	and #$fffe
	tay
@1	lda [1],y
	and #$7f7f
	sta [1],y
	dey
	dey
	cpy #$fffe
	bne @1
@done

	pla
	pla
	pld
*
* process file into usable format
*
	jsr PreProcess
*
* unlock handle
*
	pushlong DataHandle
	_HUnlock
	stz DataPtr+2
	stz DataPtr
	rts
*
* CantRead -- error reading file
*
CantRead	sta ErrorCode
	stz DataHandle+2
	stz DataHandle
* close file if refnum nonzero
	jsr CheckP16
	bcs noClose
	lda clRefNum
	beq noClose
	_CLOSE CloseParms
noClose	rts

**************************************************************
*
* PreProcess -- take raw text data at DataPtr+HeaderSize and
* produce the following:
*
* DataPtr:	table of 4-byte pointers, each one
*	an offset from the start of the big
*	handle to the data block of the
*	first line of a section
*
* DataPtr+HeaderSize:  the real data; each line has the
* following form:
*
*  ttll xxxxxxx...xxxxxxxxxxx $00
*
*  tt = one-word value
*  ll = link to next value (offset from start of section)
*
**************************************************************
PreProcess	name
	phd
	pushlong DataPtr
	pushlong DataPtr	;added 27-May-91 DAL
	tsc
	tcd
	jsr PreProc2
	pla
	pla
	pla	;27-May-91 DAL
	pla	;27-May-91 DAL
	pld
	rts
*
* 27-May-91 DAL
*
* <1 and <5 both point to the data file.  <1 will stay put,
* and <5 will get bumped along as we do each section.  Offests
* for the header are stored through [1] as the difference between
* <5 and <1.
*
PreProc2	lda #0
	ldy #HeaderSize-2
zerohdr	sta [1],y
	dey
	dey
	bpl zerohdr

***	ldy #HeaderSize	;index to 1st line of section
	clc
	lda <5
	adc #HeaderSize
	sta <5
	bcc @1
	inc <7
@1	ldy #0


	ldx #0	;sec #
seclp	phx
	lda [1],y
	and #$007f
	cmp #'*'	;if not '*', store head of list
	beq EmptySec
	phy
	txa
	asl a
	asl a	;added 27-May-91 DAL (*4)
	tay

***	lda 1,s	;old Y val = head of list
***	sta [1],y
*** added 27-May-91 DAL
	sec
	lda <5
	sbc <1
	sta [1],y
	lda <7
	sbc <3
	iny
	iny
	sta [1],y
*** end of 27-May-91 DAL

	ply
	jsr Proc1Sec
***
	clc
	tya
	adc <5
	sta <5
	bcc @1
	inc <7
@1	ldy #0
***
EmptySec	plx
	inx
	cpx #SecNUMBER
	bcc seclp
	rts
*
* Proc1Sec -- process one section of the
* text data.  Y=index to first line.
* [5] is the raw data, to be processed in
* place.
*
* Must return with Y=first line of next section.
*
Proc1Sec	name
P1SecLp	jsr Proc1Line
	lda [5],y
	and #$007f
	cmp #'*'
	bne P1SecLp
skipcr	iny
	lda [5],y
	and #$007f
	cmp #cr
	bne skipcr
	iny	;points to line 1 next sec
	rts
*
* Proc1Line -- process line a [5],Y.  Then
* return with Y pointing to the next line.
*
Proc1Line	name
	phy
	jsr EatHexWord
	ply
	sta [5],Y	;stored target value
*
* Scan for next line.  When found CR, replace
* with $00 and insert link to next line right
* after the target word of THIS line.
*
	phy
	iny
	iny
	iny
	iny
scancr2	iny	;inc past 'hhhh '
	lda [5],y
	and #$007f
	cmp #cr
	bne scancr2
	lda #0
	sep #$20	;ready to store a 1-BYTE zero
	longa off
	sta [5],y
	rep #$30
	longa on
* store link field
	iny	;index of next line
	tyx
	stx NextSec
	lda [5],y
	and #$7f
	cmp #'*'
	bne StoreLink
	ldx #0	;0=end of linked list for this sec
StoreLink	txa	;A=value for link field
	ply	;index of THIS line
	iny
	iny	;ahead 2 to link field
	sta [5],y	;store link field
	ldy NextSec
	rts
*
* EatHexWord -- from [5],y analyze 4 bytes
* of ASCII.  Return A=the hex value they
* represented.
*
EatHexWord	name
	pea 0	;build result on stack
	ldx #4	;# nybbles to eat
hw1	jsr EatHexNyb
	iny
	dex
	bne hw1
	pla
	rts
*
* EatHexNyb
*
EatHexNyb	lda [5],y
	and #$007f
	cmp #'9'+1
	bcc hnDigit
	sbc #7
hnDigit	and #$0f
	pha
	lda 5,s	;result in progress (EatHexWord)
	asl a
	asl a
	asl a
	asl a
	ora 1,s	;from PHA
	sta 5,s	;result for EatHexWord
	pla
	rts

**********************************************
*
* Dereference DataHandle into DataPtr, return
* old Locked state in Carry
*
**********************************************
deref	name
	stz DataPtr+2
	stz DataPtr 	;anticipate NIL handle
	lda DataHandle+2
	ora DataHandle
	bne dhNotNIL
	sec	;indicate no need to _HUnLock
	rtl
dhNotNIL	phd	;save direct pg
	pushlong DataHandle
	tsc	;put dir page on stack
	tcd
	lda [1]	;at 1..4 is DataHandle
	sta DataPtr
	ldy #2
	lda [1],y
	sta DataPtr+2
	iny
	iny
	lda [1],y	;y=4 (o_attributes)
	asl a	;return old locked state in carry
	pla
	pla
	pld	;restore direct pg
	rtl

*****************************************************
*
* P16 parameter lists for reading in the
* data file
*
*****************************************************
OpenParms
opRefNum	DC.W 0
theOpenDataName	DC.L Filename1	;19-Jan-91 DAL
	DC.L 0	;I/O buffer (result)
*
EOFparms
EOFRefNum	DC.W 0
EOFval	DC.L 0
*
ReadParms
rdRefNum	DC.W 0
rdWhere	DC.L 0
rdAmount	DC.L $0000ffff
	DC.L 0	;how much was read
*
CloseParms
clRefNum	DC.W 0
****************************************************
NextSec	DC.W 0
DataHandle	DC.L 0	;handle to disasm data
DataPtr	DC.L 0	;dereferenced DataHandle
MyID	DC.W 0	;mem mgr id for data file
MyMsgID	dc.w 0	;MessageByName ID
ErrorCode	DC.W 0	;Error loading data file
****************************************************

****************************************************
*
* Set Prefix 0 to the directory containing Nifty List
*
****************************************************
SetNLPrefix0	name
	jsr CheckP16
	bcs @x
	_GetPrefixGS origPrefix
	jsr CalcMyPrefix
	_SetPrefixGS newPrefix
@x	rts

CalcMyPrefix	name
	pha
	pha
	lda MyID
	and #$f0ff
	pha
	pea 1
	_LGetPathname2
	plx
	pla
	bcs @x
	phd
	pha
	phx
	tsc
	tcd
	lda [1]
	cmp #128
	bcs @abort
	tay
	iny
	iny
@srch	dey
	cpy #2
	bcc @abort
	jsr get1y
	cmp #':'
	bne @srch
	tya
	dec a
	dec a
	sta [1]
	pei 3
	pei 1
	pushlong #NLDirPath
	pea 0
	phy
	_BlockMove
@abort	ply
	ply
	pld
@x	rts
*
* Put prefix 0 back how it was before SetNLPrefix0
*
FixPrefix0	name
	jsr CheckP16
	bcs @x
	_SetPrefixGS restorePrefix
@x	rts

origPrefix	dc.w 2
	dc.w 0
	dc.l tempPrefix
restorePrefix	dc.w 2
	dc.w 0
	dc.l tempPrefix+2
newPrefix	dc.w 2
	dc.w 0
	dc.l NLDirPath

tempPrefix	dc.w 67
	ds.b 65

NLDirPath	dc.w 18
	dc.b '*/System/Desk.Accs'
	ds.b 128-18
*
* Load modules (prefix 0 is already set to the right directory)
*
LoadModules	name
	stz NextModIndex
	_OpenGS OpenNLDir
	bcs lmDone
	lda dirRef
	sta dirRef2
	sta dirRef3
GetNextFilename	name
	_GetDirEntryGS GetDirEnt
	bcs lmClose
	lda entType
	cmp #modFileType
	bne GetNextFilename
	lda entAux+2
	bne GetNextFilename
	lda entAux
	cmp #modAuxType
	bne GetNextFilename
	jsr LoadOneModule
	bcs GetNextFilename
	jsr InstallModule
	bra GetNextFilename
lmClose	_CloseGS CloseNLDir
lmDone	rts

OpenNLDir	dc.w 3
dirRef	dc.w 0
	dc.l ZeroSlash
	dc.w $0001	;read only
ZeroSlash	dc.b 2,0,'0/'

CloseNLDir	dc.w 1
dirRef3	dc.w 0

GetDirEnt	dc.w 13
dirRef2	dc.w 0
	dc.w 0,1,1	;flags, base, displacement
	dc.l fileNameBuff
	dc.w 0	;entry num
entType	dc.w 0	;filetype
	dc.l 0	;eof
	dc.l 0	;blocks
	dc.l 0,0,0,0	;create/mod date/time
	dc.w 0	;access
entAux	dc.l 0	;auxtype

fileNameBuff	dc.w 34
	ds.b 32
*
* LoadOneModule--load the module in fileNameBuff and
* return pointer in AX
*
LoadOneModule	name
	pha
	pha
	pha
	pha
	pha
	pea $5000		;was $5700 14-Jul-90 DAL
	pushlong #FileNameBuff+2
	pea 1		;no special memory
	pea 1		;name is a GS/OS string
	_InitialLoad2
	ply		;memID--ignore
	plx		;address low
	pla		;address high
	ply		;direct-page location--ignore
	ply		;direct-page size--ignore
	rts

************************************************************
*
* FirstModule--point ModIndex and X at first module's entry;
* return SEC if there are no more modules
*
************************************************************
FirstModule	name
	lda #0
	sta ModIndex
	bra NextMod2
*
* NextModule--point ModIndex and X at next module's entry;
* return SEC if there are no more modules.
*
NextModule	name
	lda #ModEntSize
NextMod2	clc
	adc ModIndex
	sta ModIndex
	tax
	cpx NextModIndex
	lda ModuleList+oModTable+1,x
	sta ModuleBank
	rts
*
SetModuleBank	name
	pha
	lda ModuleBank
	pha
	plb
	plb
	pla
	rts
ModuleBank	dc.w 0
*
* InstallModule--AX = pointer to loaded module
*
InstallModule	name
	pha
	phx
	phd
	tsc
	tcd
	ldy #$10
	lda [3],y
	pld
	cmp #myVersion**$7fff
	beq @ok
	bcc @ok
	plx
	plx
	rts
@ok	ldx NextModIndex
	stx ModIndex
	txa
	clc
	adc #ModEntSize
	sta NextModIndex
	pla
	sta ModuleList+oModPtr,x
	pla
	sta ModuleList+oModPtr+2,x
	jsr FindModTable
	jsr PatchModule
	rts
*
* Kill Modules
*
KillModules	name
	jsr FirstModule
	bcs @dun

@kill1
*
*  Call module's Action routine so it can clean up
*
	phx
	lda #actDeath
	ldx #0
	txy
	jsr CallAction	;8-Jul-90   (%%% should allow errors!)
	plx
*
* UserShutDown the module
*
	pha	;space for FindHandle (so we can find the ID)
	pha
	lda ModuleList+oModPtr+2,x
	pha
	lda ModuleList+oModPtr,x
	pha
	_FindHandle
	phd
	tsc
	tcd
	ldy #hID
	lda [3],y
	pld
	plx
	plx

	pha
	pha
	pea 0
	_UserShutDown
	pla

	jsr NextModule
	bcc @kill1
@dun	rts
*
* FindModTable--call the module's OPEN routine and record
* the table pointer
*
FindModTable	name
	phd
	ldx ModIndex
	lda ModuleList+oModPtr+2,x
	pha
	lda ModuleList+oModPtr,x
	pha
	tsc
	tcd
	phb
	pea 0
	pea 0
	ldy #1
	lda [1],y
	tax
	lda [1]
	jsl CallXA
	lda >ModIndex	;was LDX ModIndex (1-Apr-90)
	tax
	pla
	sta >ModuleList+oModTable,x
	pla
	sta >ModuleList+oModTable+2,x
	plb
	pla
	pla
	pld
	rts
*
* NotifyModules--tell all the modules the action in A
*
NotifyModules	name
	sta @theCode
	jsr FirstModule
	bcs @exit
@next	lda @theCode
	ldx #0
	txy
	jsr CallAction
	jsr NextModule
	bcc @next
@exit	rts

@theCode	dc.w 0
*
* CallAction--call the module's Action routine
*
CallAction	name
	sta callA
	stx callX
	sty callY
	phd
	ldx ModIndex
	lda ModuleList+oModPtr+2,x
	pha
	lda ModuleList+oModPtr,x
	pha
	tsc
	tcd
	ldy #9
	lda [1],y
	tax
	dey
	lda [1],y
	phb
	jsl CallXAregs
	plb
	pla
	pla
	pld
	rts

CallXARegs	name
	phx
	phk
	dec a
	sta 1,s
	jsr setModuleBank
	lda >callX
	tax
	lda >callY
	tay
	lda >callA
	rtl

callA	dc.w 0
callX	dc.w 0
callY	dc.w 0

*
* PatchModule--store a pointer to NLService into the location
* indicated by the module's table
*
PatchModule	name
	phd
	ldx ModIndex
	lda ModuleList+oModTable+2,x
	pha
	lda ModuleList+oModTable,x
	pha
	tsc
	tcd
	ldy #mtPatchAddr+2
	lda [1],y
	pha
	dey
	dey
	lda [1],y
	sta 1
	pla
	sta 3
	lda JumpService
	sta [1]
	ldy #2
	lda JumpService+2
	sta [1],y
	pla
	pla
	pld
	rts
JumpService	jmp >NLService
*
* do a long jump to XA (3-byte value: X=high 2 bytes, A=low 2 bytes)
*
CallXA	name
	phx
	phk
	dec a
	sta 1,s
	jsr SetModuleBank
	lda >DebugBreak
	beq @go
	lda #0
	sta >DebugBreak
	BRK $42
@go	rtl
*
* find module's command table (return in AX)
*
* Return Y = command entry size
*
FindModCmdTbl	name
	phd
	ldx ModIndex
	lda ModuleList+oModTable+2,x
	pha
	lda ModuleList+oModTable,x
	pha
	tsc
	tcd
	ldy #mtCmdEntSize
	lda [1],y
	sta @yTemp
	ldy #mtCommandTbl
	lda [1],y
	tax
	iny
	iny
	lda [1],y
	ply
	ply
	pld
	ldy @yTemp
	rts
@yTemp	dc.w 0
*
* Print all the module help
*
PrintAllModHelp	name
	jsr firstModule
	bcc @firstHelp	;was bra 28-Aug-92 DAL (crashed if no modules)
@nexthlp	bcs @hlpdone
	pushlong #mNextHelp
	_WriteCS
	jsr AskReturnESC
	bcs @hlpdone
	jsr crout
	jsr crout
@firstHelp	jsr Print1ModHelp
	jsr crout
	jsr nextModule
	bra @nexthlp
@hlpdone	rts

mNextHelp	DC.B '[ RETURN=next module; ESC=stop ] ',0

*
* Print Module Help
*
Print1ModHelp	name
	phd
	jsr FindModCmdTbl
	pha
	phx
	tsc
	tcd
	ldy #mcHelp+1
	lda [1],y
	tax
	dey
	lda [1],y
	phb
	jsl CallXA
	plb
	pla
	pla
	pld
	rts
*
NextModIndex	dc.w 0
ModIndex	dc.w 0
ModuleList	ds.b MaxModules*ModEntSize

****************************************************
****************************************************
*
* NLService--called by modules with toolbox-style
* parms:  long result space, long input, word input
*
* long := NLService(dataPtr,req_code)
*
dataP	equ 9
NLService0	name	;don't name the real one

NLService	rep #$30	;nlRemoveNL stores a BRK here
	phb
	phk
	plb
	phd
	tsc
	tcd
	lda 7	;req_code
	asl a
	tax
	cpx #EndServ-ServTable
	bcs @Serviced
	lda dataP+2
	ldy dataP
	jsr (ServTable,x)
	bcs @Serviced
	sta 15
	stx 13
@Serviced	pld
	plb
	lda 2,s
	sta 8,s
	lda 1,s
	sta 7,s
	pla
	pla
	pla
	rtl
*
ServTable
* Environment services ($00-$0f)
	dc.w XnlRecover,XnlEnter,XnlRemoveNL,XnlGetInfo	;$0-3
	dc.w XnlInstallHook,XnlRemoveHook,XnlGetDir,XnlNewSsn	;$4-7
	dc.w XnlKillSsn,XnlSetSsn,XnlWelcome,XnlLoadStuff	;$8-B
	dc.w XnlGetTextState,XnlSetTextState,nlErr,nlErr	;$C-F
* Information services ($10-$1f)
	dc.w XnlGetFirstHandle,XnlGetHandleInfo,XnlLookup,XnlIndLookup
	dc.w XnlGetProcName,XnlClassifyAddr,nlErr,nlErr
	dc.w nlErr,nlErr,nlErr,nlErr,nlErr,nlErr,nlErr,nlErr
* Utility services ($20-$2f)
	dc.w XnlScanHandles,XnlDisasm1,XnlExecCmdLine,XnlGetRange
	dc.w XnlGetAGlobal,XnlSetAGlobal,XnlAbortToCmd,nlErr
	dc.w nlErr,nlErr,nlErr,nlErr,nlErr,nlErr,nlErr,nlErr
* Input/Output services ($30-$4F)
	dc.w XnlWriteChar,XnlShowChar,XnlWriteStr,XnlShowStr
	dc.w XnlWriteCStr,XnlShowCStr,XnlWriteText,XnlShowText
	dc.w XnlWriteByte,XnlWriteWord,XnlWritePtr,XnlWriteLong
	dc.w XnlGetLn,XnlGetChar,XnlCheckKey,XnlCrout
	dc.w XnlSpout,XnlPause,XnlHandleInfo,XnlWriteNoVoice	;$40-43
	dc.w XnlShowWStr,nlErr,nlErr,nlErr
	dc.w nlErr,nlErr,nlErr,nlErr,nlErr,nlErr,nlErr,nlErr
* Parsing services ($50-$5F)
	dc.w XnlChrGet,XnlChrGot,XnlEatBlanks,nlErr
	dc.w XnlEvalExpr,nlErr,nlErr,nlErr
	dc.w nlErr,nlErr,nlErr,nlErr
	dc.w nlErr,nlErr,nlErr,nlErr
* Memory access services ($60-$6f)
	dc.w XnlGetByte,XnlGetWord,XnlGetLong
EndServ
*
* Nifty List service routines
*   --on entry, AY=dataP
*   --return CLC if AX=valid result
*
nlErr	sec
	rts
***
*** environment services
***
*
* nlRecover--for debugging (re-enters NL so you can keep debugging)
*
XnlRecover	pea 0
	pld
	jsl start
	brk $77
*
* nlEnter--enter Nifty List, if not already entered
*
XnlEnter	name
	lda gBusyCount
	beq @notBusy
* return value 1 = Nifty List is already busy
	lda #0
	ldx #1
	clc
	rts
@notBusy	sep #$20
	longa off
	lda >$E0C029
	pha
	and #$7f
	sta >$E0C029
	rep #$20
	longa on
	jsl start
	sep #$20
	pla
	sta >$E0C029
	rep #$20
	clc	;31-May-91 DAL
	lda #0	;31-May-91 DAL
	tax	;31-May-91 DAL
	rts
*
* nlRemove--detach Nifty List from everywhere, so that somebody can
* call RemoveCDA and UserShutDown on us.
*
* If successful, return handle & ID (failed: handle=nil)
*
XnlRemoveNL	name
	jsr RemoveMe
	bcs @exit	;failed (return NIL)

	lda MyID	;return ID in passed pointer
	and #$f0ff
	sta [dataP]

	pha	;return CDA handle = result
	pha
	pushlong #start
	_FindHandle
	plx
	pla
	clc
@exit	rts

*
* RemoveMe -- get NL's fingers out of the system
*
RemoveMe	name

	jsr doKillSessions
	jsr UndoDebugHook
	jsr KillModules
*
	jsr RemoveReqProc
*
* kill the Nifty List Service message, if there is one
*
	lda myMsgID
	beq @noMessage
	pea 3	;dispose message
	pha
	phy
	phy
	_MessageCenter
@noMessage
*
* unhook the System Death vector
*
	pea 7
	pushlong DeathChain+1
	_SetVector
*
* dispose of the data file handle
*
	pushlong DataHandle
	_DisposeHandle
	stz DataHandle+2
	stz DataHandle
*
* shut down the history manager
*
	jsr HistoryShutdown
*
* fix the Start, Shutdown, and Service points to just BRK
*
	stz Suicide1
	stz Suicide2
	stz NLService
	clc
	rts
*
* nlGetInfo--return misc information in buffer
*
XnlGetInfo	name	;takes @buffer
	lda >E1CompactFlag	;just a byte
	and #$00ff
	sta infoCompactFl
	lda gBusyCount
	beq @storebz
	lda #1
@storebz	sta infoBusyFlag

	ldy BEGININFOTABLE	;table size
@copy	dey
	dey
	lda BEGININFOTABLE,y
	sta [dataP],y
	tya
	bne @copy
	sec
	rts
*
* Table for nlGetInfo(version/4, mainMemID, nlBusy, compactmem)
*
BEGININFOTABLE	dc.w ENDINFOTABLE-BEGININFOTABLE	;word = table size
	dc.l myVersion	;$2
infoMemID	dc.w 0	;$6
infoBusyFlag	dc.w 0	;$8
infoCompactFl	dc.w 0	;$A
SystemPatchID	dc.w $7777	;$C: ID of tool.setup patch file (for 3.3)
infoServAddr	dc.l NLService	;$E: for 3.3
ENDINFOTABLE
*
* nlInstallHook--
*
*@*
XnlInstallHook	name
	sec
	rts
*
* nlRemoveHook--
*
*@*
XnlRemoveHook	name
	sec
	rts
*
* nlGetDirectory--return pointer to class-1 pathname = directory NL is in
*
XnlGetDir	name
	lda #NLDirPath>>16
	ldx #NLDirPath
	clc
	rts
*
* nlNewSession(@callback):sessionRef
* *@*
XnlNewSsn	name
	ldy #0
	tyx
@find	lda sessList+1,y
	beq @found
	inx
	tya
	clc
	adc #ssnSize
	tay
	cpy #MaxSessions*ssnSize
	bcc @find
	lda #$ffff
	tax
	clc
	rts
@found	lda dataP+2
	sta sessList+2,y
	lda dataP
	sta sessList,y
	lda #$5555
	clc
	rts
*
* nlKillSession(sessionRef)
*
XnlKillSsn	name
	jsr SessionIndexY
	lda #0
	sta sessList+2,y
	sta sessList,y
	sec
	rts
*
* nlSetSession(sessionRef):oldSession
*
XnlSetSsn	name
	pushlong theSess
	sty theSess
	jsr SessionIndexY
	lda sessList+2,y
	sta theCallBack+2
	lda sessList,y
	sta theCallBack
	plx
	pla
	clc
	rts
*
* Compute Y = index to session Y (assume ssnSize = 4)
*
SessionIndexY	name
	cpy #MaxSessions+1
	bcc @ok
	brk $55	;bad session number!
@ok	pha
	tya
	asl a
	asl a
	tay
	pla
	rts
*
* nlWelcome(0) -- print the Welcome message
*
XnlWelcome	name
	pushlong #theTitle
	pea nlWriteCStr
	jsl NLService
	sec
	rts
*
* nlLoadStuff(0):error -- force the data file to get loaded
*
XnlLoadStuff	name
	stz ErrorCode
	jsl Deref
	lda DataPtr+2
	bne @x
	jsr SetNLPrefix0
	tax
	bcs @x
	jsr ReadData
	jsr FixPrefix0
	ldx ErrorCode
@x	lda #0
	clc
	rts
*
* nlGetTextState(0):TextInfo/4
*
XnlGetTextState	jsl TxtGetState
	clc	;return info in AX
	rts
*
* nlSetTextState(TextInfo/4)
*
XnlSetTextState	tyx
	jsl TxtSetState	;inputs = AX
	sec
	rts
*
* Information services ($10-$1f)
*
XnlGetFirstHandle	name
	tya	;low word of data (0,1,2)
	asl a
	asl a
	tax
	lda >$E11600,x
	pha
	lda >$E11602,x
	plx
	clc
	rts

XnlGetHandleInfo	name	;ptr to (Handle/4, @buffer)
	phd
	ldy #6
@push	lda [dataP],y
	pha
	dey
	dey
	bpl @push
	tsc
	tcd		;[1] = handle, [5] = buffer

	lda #20		;return buffer size in first word
	sta [5]
	clc
	lda 5
	adc #2
	sta 5
	bcc @ok
	inc 7
@ok
	ldy #20-2
@copy	lda [1],y
	sta [5],y
	dey
	dey
	bpl @copy
	pla
	pla
	pla
	pla
	pld
	sec
	rts
*
* dataP points at  0:section, 2:data/4, 6:@buffer
*
XnlIndLookup	name
	sec
	bra nlLKUP
XnlLookup	name
	clc
nlLKUP	ror IndexedFlag
	pushlong DataPtr
	jsl Deref
	jsr nlLookup2
	pla
	sta DataPtr
	pla
	sta DataPtr+2
;	sec
	rts

nlLookup2	name
	ldy #2
	lda [dataP],y
	tax
	lda [dataP]
* JustFind: uses A=section, X=data (or if IndexedFlag then X=1,2,3...)
	jsr JustFind	;returns FindResult = nil or @cstring
	phd
	ldy #8
	lda [dataP],y
	pha
	dey
	dey
	lda [dataP],y
	pha
	pushlong FindResult
	tsc
	tcd	;[1]=findResult, [5]=buffer

	lda IndexedFlag	;if indexed, transfer the result word 1st
	bpl @notInd

	lda target
	sta [5]
	ldy #2
	lda #0
	sta [5],y
	clc
	lda 5
	adc #4
	sta 5
	bcc @ok2
	inc 7
@ok2

@notInd	lda #0
	sta [5]
	lda 1
	ora 3
	beq @dun

	sep #$30
	longa off
	longi off

	ldy #0
@copy	lda [1],y
	beq @done
	iny
	sta [5],y
	bra @copy
@done	tya
	sta [5]

	rep #$30
	longa on
	longi on

@dun	pla
	pla
	pla
	pla
	pld
	sec
	rts
IndexedFlag	dc.w 0
*
* XnlGetProcName(ptr):@name
*
XnlGetProcName	name
	jsr GetProcName
	tyx
	bcc @rts
	lda #0
	tax
	clc
@rts	rts
*
* XnlClassifyAddr(ptr):TypeAndCharacter
*
* Low word of result = code: 0=System, 1=Sys patch, 2=other patch, 3=weird
* High word of result = character: blank=ROM, +=system, *=other, ?=invalid
*
* In=AY, Out=AX
*
XnlClassifyAddr	name
	and #$00ff
	ldx #0	;anticipate System
	cmp #$00f8	;ROM = System
	bcs @gotIt

	pha
	pha	;space for FindHandle
	pha
	phy	;input address
	_FindHandle
	ldx #3	;anticipate invalid
	ply
	pla
	beq @gotIt

	sta <dataP+2
	sty <dataP

	ldy #4
	lda [<dataP],y	;get handle's attributes
	bmi @attrOK	;locked --> okay
	and #$4300	;check fixed + purge level
	cmp #$4000	;must be fixed and non-purgable
	bne @gotIt	;Use X=3 (invalid)
@attrOK
	ldy #6
	lda [<dataP],y	;get handle's owner ID
	beq @gotIt	;X=3 (invalid)
	and #$f0ff	;mask out AuxID

	ldx #1	;anticipate system patch
	cmp SystemPatchID	;is this TSx?
	beq @gotIt

	ldx #0	;anticipate System
	cmp ResourceMgrID	;Resource.Mgr init file?
	beq @gotIt
	and #$f000
	cmp #$4000	;4xxx=RAM Tool = System
	beq @gotIt
	cmp #$7000	;7xxx=Loader = System
	beq @gotIt
	cmp #$3000	;3xxx=GS/OS = System
	beq @gotIt

	ldx #2	;X=2 (other)

@gotIt	lda classChars,x	;return A=character in high word
	and #$00ff
	clc	;return X=code in low word
	rts

classChars	dc.b ' +*?'	;ROM, System, Other, Invalid

*
* ComputePatchID--Determine the memory ID of the TSx toolbox patch
* file, by calling LGetPathname2 on IDs from $A001 to $A020 looking
* for the first one where the 2nd- and 3rd-to-last letters are "TS".
*
ComputePatchID	name
	lda #$A001
@CheckNextID	pha

	pha
	pha	;space for LGetPathname2 result
	pha	;mem id
	pea 1	;file number
	_LGetPathname2
	plx
	pla
	bcs @noper

	phd
	pha
	phx
	tsc
	tcd
	lda [1]
	tay
	dey
	lda [1],y	;fetch 2nd and 3rd-to-last characters
	plx
	plx
	pld
	cmp #$5354	;'TS'
	beq @foundIt

@noper	pla
	inc a
	cmp #$A020
	bcc @CheckNextID
	stz SystemPatchID
	bra @cont

@foundIt	pla
	sta SystemPatchID
*
* Now find the Resource Manager ID!
*
* Method:  Assume RM function 8 (reserved) is not patched;
* do a FindHandle on it and use that handle's ID.
*
@cont	lda #0
	pha
	pha	;space for FindHandle
	pha
	pha	;space for GetFuncPtr
	pha	;system tool
	pea $081E	;reserved Resource Mgr function
	_GetFuncPtr
	_FindHandle
	phd
	tsc
	tcd
	ldy #6	;offset to handle's ID
	lda [3],y
	sta ResourceMgrID
	pld
	pla
	pla
	rts

*
* Utility services ($20-$2f)
*
XnlScanHandles	name	;data = ptr to (WhichList/2, BankValue/4, @Proc)
	ldy #4-1	;point at middle word of BankValue
	lda [dataP],y
	sta @scanBank

	ldy #6
	lda [dataP],y
	sta @proc
	iny
	iny
	lda [dataP],y
	sta @proc+2

	lda [dataP]
	asl a
	asl a
	tax
	lda >$E11600,x
	tay
	lda >$E11602,x
	sta dataP+2
	sty dataP

@next	lda dataP+2
	ora dataP
	beq @done

	phb
	pei dataP+2
	pei dataP
	jsl @callProc
	plb

	ldy #hNext+2
	lda [dataP],y
	tax
	dey
	dey
	lda [dataP],y
	sta dataP
	stx dataP+2
	bra @next
@done	sec
	rts
@scanBank	dc.w 0
@proc	dc.l 0
*
@callproc	ldx @proc+1
	lda @proc
	phx
	phk
	dec a
	sta 1,s
	lda @scanBank
	pha
	plb
	plb
	rtl
*
* nlDisasm1--
*
*@*
XnlDisasm1	name	;input address in AY
	tax	;address now in XY
	pushlong addr
	stx addr+2
	sty addr
	stz DisasmState
	jsr List1Line
	ldy addr+2
	ldx addr
	pla
	sta addr
	pla
	sta addr+2
	tya	;return new address in AX
	clc
	rts
*
* nlExecCmdLine(@WordString):0
*
XnlExecCmdLine	name
*
* %%% need to preserve old command line and NumChars and index and lots
* %%% of other stuff! (self-modifying locations, local storage, etc)
*
	lda [dataP]
	sta NumChars
	tay
	cmp #buffSize-1
	bcs @toobig
	sep #$20
	tya
	beq @copied	;25-Oct-90 DAL
@copy	iny
	lda [dataP],y
	sta Buffer-2,y
	dey
	dey
	cpy #1
	bcs @copy
@copied	rep #$20

	jsl deref
	php	;clc=handle was unlocked
	pushlong DataHandle
	_HLock

	jsr DoCommandLine

	plp
	bcs @wasLocked
	pushlong DataHandle
	_HUnLock
	stz DataPtr
	stz DataPtr+2

@wasLocked	bra @exit

@toobig	pushlong #tooBigString
	pea nlWriteCStr
	jsl NLService

@exit
* %%% need to restore everything saved above

	jsr doFlush

	lda #0
	tax
	clc
	rts

tooBigString	dc.b 13,'*** command line too long ***',13,0
*
* nlGetRange(@buffer):numParms(1 or 2)
*   buffer:
*     +000 = beginning of range
*     +004 = end of range
*     +008 = beginning of range, no bank handling
*     +012 = end of range, no bank handling
*
XnlGetRange	name
	ldy #-2
	bit RangeFlag
	bpl @noRange

	ldx RangeSt+2
	lda RangeSt
	jsr @stxa
	ldx Num1+2
	lda Num1
	jsr @stxa
	ldx RawRangeSt+2
	lda RawRangeSt
	jsr @stxa
	ldx RawNum+2
	lda RawNum
	jsr @stxa
	lda #0
	ldx #2
	clc
	rts

@noRange	ldx Num1+2	;Y=-2
	lda Num1
	jsr @stxa
	jsr @zerlong
	ldx RawNum+2
	lda RawNum
	jsr @stxa
	jsr @zerlong
	ldx #1		;A=0
	clc
	rts

@stxa	jsr @store
	txa
	bra @store
@zerLong	jsr @z
@z	lda #0
@store	iny
	iny
	sta [dataP],y
	rts
*
* nlGetAGlobal(refnum):value
*
XnlGetAGlobal	name
	tya		;dataP
	asl a
	tax
	cpx #GlobTableEnd-GlobalTable
	bcs xSetErr
	lda GlobalTable,x
	tax
	lda GLOBALS,x
	pha
	lda GLOBALS+2,x
	plx
	clc
	rts
*
* nlSetAGlobal--
*
XnlSetAGlobal	name
	lda [dataP]
	asl a
	tax
	cpx #GlobTableEnd-GlobalTable
	bcs xSetErr
	lda GlobalTable,x
	tax
	ldy #2
	lda [dataP],y
	sta GLOBALS,x
	iny
	iny
	lda [dataP],y
	sta GLOBALS+2,x
xSetErr	sec
	rts
*
* Table of stuff that GetAGlobal/SetAGlobal can fiddle
* with.  All of them must be 4-byte storage areas!
*
GlobalTable	dc.w 0	;invalid = 0
	dc.w Num1-GLOBALS	;nlgNUM1 = 1
	dc.w addr-GLOBALS	;nlgADDR = 2
	dc.w InfoTablePtr-GLOBALS ;nlgInfoTable = 3 (for 3.3)
GlobTableEnd
*
XnlAbortToCmd	name
	phk	;parameter undefined (use 0)
	plb
	jsr crout
	pea cbAbort	;7-aug-90 DAL
	jsl doCallBack
	brk $11
*
* Input/Output services ($30-$4F)
*
XnlWriteChar	name	;char
	tya
	jsr cout
	sec
	rts

XnlWriteStr	name	;@pstr
	lda [dataP]
	and #$00ff
	tax
	beq @x
	ldy #1
@a	lda [dataP],y
	jsr cout
	iny
	dex
	bne @a
@x	sec
	rts

XnlWriteCStr	name	;@cstr
	pha
	phy
	_WriteCS
	sec
	rts

XnlWriteNoVoice	name	;@cstr
	pha
	phy
	jsr WriteNoVoice
	sec
	rts

XnlWriteText	name	;@(length,@text)
	lda [dataP]
	tax
	beq @done
	ldy #4
	lda [dataP],y
	pha
	dey
	dey
	lda [dataP],y
	sta dataP
	pla
	sta dataP+2
	ldy #0
@next	lda [dataP],y
	jsr Cout
	iny
	dex
	bne @next
@done	sec
	rts

XnlShowChar	name	;char
	tya	;dataP
	jsr ACout
	sec
	rts

XnlShowStr	name	;@pstr
	lda [dataP]
	and #$00ff
	tax
	beq @done
	ldy #1
@next	lda [dataP],y
	jsr ACout
	iny
	dex
	bne @next
@done	sec
	rts

XnlShowCStr	name	;@cstr
	ldy #0
@char	lda [dataP],y
	and #$00ff
	beq @done
	jsr ACout
	iny
	bra @char
@done	sec
	rts

XnlShowText	name	;@(length,@text)
	lda [dataP]
	tax
	beq @done
	ldy #4
	lda [dataP],y
	pha
	dey
	dey
	lda [dataP],y
	sta dataP
	pla
	sta dataP+2
	ldy #0
@next	lda [dataP],y
	jsr ACout
	iny
	dex
	bne @next
@done	sec
	rts

XnlShowWStr	name	;@GString
	lda [dataP]
	tax
	beq @x
	ldy #2
@next	lda [dataP],y
	jsr ACout
	iny
	dex
	bne @next
@x	sec
	rts

XnlWriteByte	name	;byte
	tya
	jsr prbyte
	sec
	rts

XnlWriteWord	name	;word
	tya
	jsr prword
	sec
	rts

XnlWritePtr	name	;ptr (3 bytes)
	jsr prbyte
	lda dataP
	jsr prword
	sec
	rts

XnlWriteLong	name	;long
	jsr prword
	lda dataP
	jsr prword
	sec
	rts
*
* nlGetLn--
*
*@*
XnlGetLn	name
	sec
	rts
*
* nlGetChar -- get a character
*
XnlGetChar	name
	jsr GetKey
	clc
	tax
	lda #0
	rts
*
* nlCheckKey--return 0 if no key pressed
*
XnlCheckKey	name
	jsr CheckKey
	lda #0
	bcs @exit	;no key
	lda #$ffff
@exit	tax
	clc
	rts
*
XnlCrout	name
	jsr crout
	sec
	rts
*
XnlSpout	jsr spout
	sec
	rts
*
XnlPause	jsr Pause
	sec
	rts
*
XnlHandleInfo	name
	jsr InvalidatePathCache
	tyx
	jsr PrHandInfo	;handle in AX
	sec
	rts
*
* Parsing services
*
XnlChrGet	name
	jsr chrget
	bra getgot
XnlChrGot	name
	jsr chrgot
getgot	tax
	lda #0
	bcc @okay
	ldx #0
@okay	rts

XnlEatBlanks	name
	jsr eatblanks
	sec
	rts
*
eatblanks	name
	jsr chrgot
	cmp #' '
	bne @dun
	jsr chrget
	bra eatblanks
@dun	jmp chrgot
*
* nlEvalExpr(@buffer):ExprSize
*
* buffer:
*   MaxExprSize/2
*   ActExprSize/2
*   Expr/n
*
XnlEvalExpr	name
	jsr EvalExpr	;ay=buffer
	ldy #2
	lda [dataP],y
	tax
	lda #0
	clc
	rts
*
* Memory access services ($60-$6f)
*
XnlGetByte	name
	sta addr+2
	sty addr
	jsr getbyte
	tax
	lda #0
	clc
	rts

XnlGetWord	name
	sta addr+2
	sty addr
	jsr getword
	tax
	lda #0
	clc
	rts

XnlGetLong	name
	sta addr+2
	sty addr
	jsr getword
	pha
	ldy #2
	jsr getwordY
	plx
	clc
	rts
****************************************************
****************************************************
ListDP	DC.L 0
ListCtlFlag	DC.W 0
*
SetNumAddr	name
	lda addr+2
	ldy addr
	sta CurBank
	sta Num1+2
	sty Num1
	rts
*
* ; -- interpret misc info at address
*
DefaultSemi	ds.w 1

isSemi	name
	lda Num1+2
	ldy Num1
	sta addr+2
	sty addr
	ldy index
	inc index
	cpy NumChars
	bcs intDefault
	lda Buffer,y
	and #$7f
	cmp #';'
	beq intDefault
	cmp #' '
	bne intNotDflt
intDefault	dec index
	lda DefaultSemi
intNotDflt
	jsr downcase	;6-Jul-90
	sta DefaultSemi
	cmp #'a'
	bne intNotA
	brl intA
intNotA	cmp #'h'
	bne intNotH
	brl intH
intNotH	cmp #'n'
	bne intNotN
	brl intN
intNotN	cmp #'p'	;6-Jul-90 (P)
	bne intNotP
	brl intP
intNotP	cmp #'w'	;6-Jul-90 (W)
	bne intNotW
	brl intW
intNotW	cmp #'m'	;6-Jul-90 (M)
	bne intNotMenu
	brl intMenu
intNotMenu	cmp #'s'
	bne intNotStack
	brl intStack
intNotStack
*
	cmp #'r'
	bne intNotR
	pushlong addr
	_CheckHandle
	bcs @rect
	brl intRgn
@rect	brl intRect

intNotR	cmp #'c'
	bne intNotC
	lda addr+2
	ora addr
	beq @control	;NIL or valid handle = control (not CDA)
	pushlong addr
	_CheckHandle
	bcc @control
	lda addr+2	;7-Jan-91 DAL
	ldy addr	;7-Jan-91 DAL
	jsr VerifyW	;7-Jan-91 DAL
	bcc @control	;7-Jan-91 DAL
	brl intC	;CDA header
@control	brl intCtl

intNotC

intErr	pushlong #desSemi
	_WriteCS
	rts

*
* ASCII dump
*
AsciiDump	name
intA	jsr BeginRange
	bcs Asc16
* xx/xxxx.yy/yyyy;a
AscRange	jsr Ascii1
	jsr SetNumAddr
	jsr CheckRange
	bcc AscRange
	rts
Asc16	ldx #16
AscLp1	phx
	jsr Ascii1
	jsr SetNumAddr
	plx
	dex
	bne AscLp1
	rts
*
Ascii1	lda Num1+2
	ldx Num1
	sta addr+2
	stx addr
	jsr praddr		;uses AX
	lda #':'
	jsr cout
	ldy #0
AscL2	jsr GetByteY
	jsr ACout
	iny
	cpy #64
	bcc AscL2
	clc
	lda addr
	adc #64
	sta addr
	lda addr+2
	adc #0
	sta addr+2
	brl crout
*
ACout	and #$007f
	cmp #' '
	bcs Acout1
	lda #'.'
ACout1	brl cout
*
* Hex dump
*
HexDump	name
intH	stz hexPrevFlag
	stz hexEllipsis
	jsr BeginRange
	bcs Hex16
* xx/xxxx.yy/yyyy;h
HexRange	jsr Hex1
	jsr SetNumAddr
	jsr CheckRange
	bcc HexRange
	bra finishEllipsis

Hex16	ldx #16
HexLp1	phx
	stz HexPrevFlag	;Disables compression for non-range ;h
	jsr Hex1
	jsr SetNumAddr
	plx
	dex
	bne HexLp1
finishEllipsis
	lda HexEllipsis
	beq @hxExit
	jsr praddrAddr
	jsr crout
@hxExit	rts
*
praddrAddr	lda addr+2
	ldx addr
	jsr praddr
	lda #':'
	jmp cout
*
Hex1	lda HexPrevFlag
	beq @noPrev
	ldy #14
@cmpPrev	jsr getwordY
	cmp HexPrevBuff,y
	bne @differ
	dey
	dey
	bpl @cmpPrev
* the next line matches the last one
	lda HexEllipsis
	bne @stillEllip
	inc HexEllipsis
	jsr praddrAddr
	jsr repeat8
	jsr spout
	jsr repeat8
	pushlong #EllipsMsg
	_WriteCS
	jsr crout
@stillEllip bra Hex1dun
@differ	stz HexEllipsis
@noPrev	lda enableAbbrH		;true = compression enabled
	sta HexPrevFlag
	jsr praddrAddr
	ldy #0
HexLp2	jsr GetByteY
	sta HexPrevBuff,y
	jsr prbyte
	jsr spout
	cpy #7
	bne @noBlnk
	jsr spout
@noBlnk	iny
	cpy #16
	bcc HexLp2
* do ASCII part over to right
	jsr spout2
	ldy #0
HexLp3	lda HexPrevBuff,y
;	jsr GetByteY
	jsr ACout
	iny
	cpy #16
	bcc HexLp3
	jsr crout
*
Hex1dun	clc
	lda addr
	adc #16
	sta addr
	lda addr+2
	adc #0
	sta addr+2
	rts
*
repeat8	lda #8
repeat1	pha
	lda #$27	;'
	jsr cout
	jsr cout
	jsr spout
	pla
	dec a
	bne repeat1
	rts
*
HexEllipsis	dc.w 0
HexPrevFlag	dc.w 0
HexPrevBuff	ds.b 17	;16 useful, 1 slop (stored over)
EllipsMsg	dc.b '  '
	dc.b $27,$27,$27,$27,$27,$27,$27,$27
	dc.b $27,$27,$27,$27,$27,$27,$27,$27,0
*
* CDA header dump
*
intC
CDAHeaderDump	name
	lda Num1+2
	ldx Num1
	sta addr+2
	stx addr
	pushlong #mName
	_WriteCS
	jsr ShowPstr
	jsr crout
*
	pushlong #mEntry
	_WriteCS
	jsr Show4Proc		;return addr in AX
	sta HandyAddr+2
	stx HandyAddr
	jsr crout
*
	pushlong #mShutdn
	_WriteCS
	jsr Show4Proc
	brl crout
*
mName	DC.B '    Name: ',0
mEntry	DC.B '   Entry: ',0
mShutdn	DC.B 'Shutdown: ',0
mOpen	DC.B '    Open: ',0
mClose	DC.B '   Close: ',0
mAction	DC.B '  Action: ',0
mInit	DC.B '    Init: ',0
mPeriod	DC.B '  Period: ',0
mMask	DC.B '    Mask: ',0

*
* NDA header dump
*
intN
NDAHeaderDump	name
	lda Num1+2
	ldx Num1
	sta addr+2
	stx addr
*
	pushlong #mOpen
	_WriteCS
	jsr Show4Proc
	jsr crout
*
	pushlong #mClose
	_WriteCS
	jsr Show4Proc
	jsr crout
*
	pushlong #mAction
	_WriteCS
	jsr Show4Proc
	sta HandyAddr+2
	stx HandyAddr
	jsr crout
*
	pushlong #mInit
	_WriteCS
	jsr Show4Proc
	jsr crout
*
	pushlong #mPeriod
	_WriteCS
	jsr Show2
	jsr crout
*
	pushlong #mMask
	_WriteCS
	jsr Show2
	jsr crout
*
	pushlong #mName
	_WriteCS
	ldx #60
	ldy #2
NDAname	phx
	jsr GetByteY
	cmp #'\'
	beq NDAx
	jsr ACout
	plx
	iny
	dex
	bne NDAname
	phx
NDAx	plx
	brl crout
*
* ShowPstr -- display pascal string at addr (max out at 60 characters!)
*
ShowPstr	jsr GetByte
	tax
	beq shpx
	cmp #60
	bcc pstrok
	ldx #60
pstrok	phx
	ldy #1
shp1	phx
	jsr GetByteY
	jsr ACout
	plx
	iny
	dex
	bne shp1
	sec
	pla
	adc addr
	sta addr
	bcc shpx
	inc addr+2
shpx	rts
*
* Show4Proc -- show 4-byte address and then "(RTL)" if there's an RTL there
*
Show4Proc	name
	jsr Show4
	pha
	phx
	phd
	tsc
	tcd
	lda [3]
	and #$00ff
	cmp #$006b	;RTL
	bne @notRTL
	pushlong #msgRTL
	_WriteCS
@notRTL	pld
	plx
	pla
	rts
msgRTL	dc.b ' (RTL)',0
*
* Show4 -- show 4-byte address, inc addr by 4, return value in AX
*
Show4	name
	jsr GetWord
	pha
	ldy #2
	jsr GetWordY
	pha
	jsr prword
	lda 3,s
	jsr prword
	clc
	lda addr
	adc #4
	sta addr
	lda addr+1
	adc #0
	sta addr+1
	pla
	plx
	rts
*
Show2	name
	jsr GetWord
	jsr prword
	clc
	lda addr
	adc #2
	sta addr
	lda addr+1
	adc #0
	sta addr+1
	rts
*
* PrSigned
*
PrSigned	name
	pha
	pushlong #intBuff
	pea 8
	pea $ffff
	_Int2Dec
	ldx #0
PrS1	lda intBuff,x
	and #$00ff
	cmp #' '
	beq PrSkip
	phx
	jsr cout
	plx
PrSkip	inx
	cpx #8
	bcc PrS1
	rts
intBuff	DS.B 8
*
* Rectangle dump
*
intRect
RectDump	name
	lda addr+2
	ldx addr
	jsr praddr
	lda #':'
	jsr cout
	lda addr+2
	ldy addr
PrRect	jsr checkNilAY
	bcs @rectDun
	phd	;AY = rect ptr
	pha
	phy
	tsc
	tcd
	ldy #2
	lda [1],y
	tax
	lda [1]
	tay
	jsr PrPoint
	ldy #6
	lda [1],y
	tax
	ldy #4
	lda [1],y
	tay
	jsr PrPoint
	pla
	pla
	pld
@rectDun	rts
*
* PrPoint(X,Y)
*
PrPoint	name
	phy
	phx
	lda #'('
	jsr cout
	pla
	jsr PrSigned
	lda #','
	jsr cout
	pla
	jsr PrSigned
	lda #')'
	brl cout
*
* Region dump
*
intRgn
RegionDump	name
	lda addr+2
	ldx addr
	jsr praddr
	lda #':'
	jsr cout
	lda addr+2
	ldy addr
PrRgn	jsr checkNilAY
	bcs @rgnDun
	phd
	pha
	phy
	tsc
	tcd
	ldy #2
	lda [1],y
	pha
	lda [1]
	sta 1
	pla
	sta 3
	clc
	lda 1
	adc #2
	tay
	lda 3
	adc #0
	jsr PrRect
	lda #'+'
	jsr cout
	lda [1]
	sec
	sbc #10
	jsr PrSigned
	pla
	pla
	pld
@rgnDun	rts

CheckNilAY	name
	cmp #0
	bne @notNil
	cpy #0
	bne @notNil
	pushlong #Znilmsg
	_WriteCS
	sec
	rts
@notNil	clc
	rts
Znilmsg	dc.b 'NIL!',0
*
* Port dump
* =========
* .LocInfo: SCB=$xxxx Pix=$xxxxxx W=$xxxx bounds=(-xxxxx,-xxxxx)(xxxxx,xxxxx)
* PortRect: (-xxxxx,-xxxxx)(xxxxx,xxxxx)
* .ClipRgn: (-xxxxx,-xxxxx)(xxxxx,xxxxx)+xxxxx
* ..VisRgn: (-xxxxx,-xxxxx)(xxxxx,xxxxx)+xxxxx
* PenState: Loc=(-xxxxx,-xxxxx) Size=(-xxxxx,-xxxxx) Mode=$xxxx Vis=$xxxx
* ....Font: H=$xxxxxx ID=$xxxxxxxx, Flags=$xxxx
* ....Text: Size=$xxxx Face=$xxxx Mode=$xxxx fgCol=$xxxx bgCol=$xxxx
*
intP
PortDump	name
	lda addr+2
	ora addr
	bne @nonz
	pha
	pha
	_GetPort
	pla
	sta addr
	pla
	sta addr+2		;added 0/0;p 11-Aug-90
@nonz	lda #dumpPtbl>>16
	ldy #dumpPtbl
	brl DumpByTbl
*
pd1	DC.B '  LocInfo: SCB=',0
pd2	DC.B ' Pix=',0
pd3	DC.B ' W=',0
pd4	DC.B ' bounds=',0
pd5	DC.B cr,' PortRect: ',0
pd6	DC.B cr,'  ClipRgn: ',0
pd7	DC.B cr,'   VisRgn: ',0
pd8	DC.B cr
	DC.B ' PenState: Loc=',0
pd9	DC.B ' Size=',0
pd10	DC.B ' Mode=',0
pd11	DC.B ' Vis=',0
pd12	DC.B cr,'     Font: H=',0
pd13	DC.B ' ID=',0
pd14	DC.B ' Flags=',0
pd15	DC.B cr,'     Text: Size=',0
pd16	DC.B ' Face=',0
pd17	DC.B ' Mode=',0
pd18	DC.B ' fgCol=',0
pd19	DC.B ' bgCol=',0
pd20	DC.B cr,'     Misc: PicSave=',0
pd21	DC.B ' rgnSave=',0
pd22	DC.B ' polySave=',0
pd23	DC.B cr,'           GrafProcs=',0
pd24	DC.B ' userField=',0
pd25	DC.B ' sysField=',0

dumpPtbl	DC.W pd1,dumpWrd,$00
	DC.W pd2,dumpPtr,$02
	DC.W pd3,dumpWrd,$06
	DC.W pd4,dumpRct,$08
	DC.W pd5,dumpRct,$10
	DC.W pd6,dumpRgn,$18
	DC.W pd7,dumpRgn,$1C
	DC.W pd8,dumpPnt,$40
	DC.W pd9,dumpPnt,$44
	DC.W pd10,dumpWrd,$48
	DC.W pd11,dumpWrd,$72
	DC.W pd12,dumpPtr,$74
	DC.W pd13,dumpLng,$78
	DC.W pd14,dumpWrd,$7C
	DC.W pd15,dumpWrd,$7E
	DC.W pd16,dumpWrd,$80
	DC.W pd17,dumpWrd,$82
	DC.W pd18,dumpWrd,$8C
	DC.W pd19,dumpWrd,$8E
	DC.W pd20,dumpLng,$90
	DC.W pd21,dumpLng,$94
	DC.W pd22,dumpLng,$98
	DC.W pd23,dumpLng,$9C
	DC.W pd24,dumpLng,$A2
	DC.W pd25,dumpLng,$A6
	DC.W 0
*
* Window dump
*
intW
WindowDump	name
	lda addr+2
	ldy addr
	jsr VerifyW
	sta addr+2
	sty addr
	bcc isAwind
	pushlong #notAwind
	_WriteCS
	rts
notAwind	dc.b 'invalid window ptr',cr,0

isAwind	pushlong #wd0
	_WriteCS
	lda addr+2
	sta WindP+2
	lda addr
	sta WindP
	ldy #$D2-4
	jsr GetWordY
	sta TheFrame
	jsr PrWTitle
	lda #dumpWtbl>>16
	ldy #dumpWtbl
	jsr DumpByTbl
	brl intP
*
wd0	DC.B    '    Title: ',0
wd1	DC.B cr,'    Frame: ',0
wd7	DC.B cr,'  DefProc: ',0
wd9	DC.B cr,' ContDraw: ',0
wd8	DC.B '     RefCon: ',0
wd2	DC.B cr,' StrucRgn: ',0
wd3	DC.B cr,'  ContRgn: ',0
wd4	DC.B cr,'UpdateRgn: ',0
wd5	DC.B cr,' Controls: ',0
wd6	DC.B cr,'FrameCtls: ',0

dumpWtbl	DC.W wd1,dumpWrd,$D2-4
	DC.W wd7,dumpLng,$AE-4
	DC.W wd9,dumpLng,$B6-4
	DC.W wd8,dumpLng,$B2-4
	DC.W wd2,dumpRgn,$BE-4
	DC.W wd3,dumpRgn,$C2-4
	DC.W wd4,dumpRgn,$C6-4
	DC.W wd5,dumpLng,$CA-4
	DC.W wd6,dumpLng,$CE-4
	DC.W 0
*
* AY = pointer to dump-table
*
DumpByTbl	name
	phd
	pha
	phy
	tsc
	tcd
dumpNxtT	lda [1]
	beq dumpedTb
	pea DumpByTbl>>16
	lda [1]
	pha
	_WriteCS
	per dumpCont-1
	ldy #2
	lda [1],y
	dec a
	pha
	ldy #4
	lda [1],y
	tay
	rts
dumpCont	jsr Pause	;25-Feb-90
	clc
	lda 1
	adc #6
	sta 1
	lda 3
	adc #0
	sta 3
	bra dumpNxtT
dumpedTb	pla
	pla
	pld
	brl crout
*
dumpStr	name
	phy
	lda #$22
	jsr cout
	ply
	iny
	iny
	jsr GetWordY
	pha
	dey
	dey
	jsr GetWordY
	pha
	pea nlShowStr
	jsl nlService	;17-Mar-90
	lda #$22
	jsr cout
	rts
*
dumpLngPause	name
	sec
	ror SteppingFlag
dumpLng	name
	phy
	iny
	iny
	jsr dumpWrd
	ply		;fall thru
dumpWrd	name
	jsr GetWordY
	brl prword
*
dumpByt	name
	jsr GetByteY
	brl prbyte
*
dumpPtr	name
	phy
	iny
	iny
	jsr GetWordY
	jsr prbyte
	ply
	bra dumpWrd
*
dumpPnt	name
	phy
	iny
	iny
	jsr GetWordY
	ply
	pha
	jsr GetWordY
	tay
	plx		;was PLA! 27-Sep-88
	brl PrPoint
*
dumpRct	name
	clc
	adc addr
	tay
	lda addr+2
	adc #0
	brl PrRect
*
dumpRgn	name
	phy
	iny
	iny
	jsr GetWordY
	ply
	pha
	jsr GetWordY
	tay
	pla
	ldx addr+2
	phx
	ldx addr
	phx
	sta addr+2
	sty addr
	jsr intRgn
	plx
	stx addr
	plx
	stx addr+2
	rts
*
* ;C -- dump a control record from its handle
*
* 7-Jan-91 DAL: Added windptr;c feature.
*
intCtl
DumpControls	name
	lda addr+2
	ora addr
	bne @dumpCtlOrWind
* 0/0;C
	lda #0
	pha
	pha
	_FrontWindow
	tsc
	pea 0
	inc a
	pha
	pea cbFunWindow
	jsl doCallBack
	pla
	sta addr
	pla
	sta addr+2
	ora addr
	beq intCtl2
	bra DumpWindCtls

@dumpCtlOrWind	lda addr+2	;7-Jan-91 DAL
	ldy addr
	jsr VerifyW
	bcs intCtl2

DumpWindCtls	ldy #$c6	;get first content control
	jsr getwordY
	pha
	iny
	iny
	jsr getwordY
	ply
NextCtl0	sta addr+2
	sty addr
	jsr crout
intCtl2	lda addr+2
	ora addr
	bne CtlNotNIL
	pushlong #nilMsg
	_WriteCS
	rts

CtlNotNIL	name
	lda addr+2
	ldx addr
	jsr praddr
	lda #':'
	jsr cout
	lda addr+2
	pha
	lda addr
	pha
	ldy #2
	jsr GetWordY
	pha
	jsr GetWord
	sta addr
	pla
	sta addr+2
*
	jsr CalcCtlKind
*
	jsr GetWord	;set '#' = next control
	sta HandyAddr
	ldy #2
	jsr GetWordY
	sta HandyAddr+2
*
	lda #0
	pha
	pha
	_GetListDefProc
	pla
	sta ListDP
	pla
	sta ListDP+2
*
	lda #dumpCtbl>>16
	ldy #dumpCtbl
	jsr DumpByTbl
* dump regular List control extra fields
	bit ListCtlFlag
	bpl noListInfo
	lda #dumpLCtbl>>16
	ldy #dumpLCtbl
	jsr DumpByTbl
noListInfo
* Dump stuff as a function of ctlKind
	jsr DumpCtlSpecial
*
	pla
	sta addr
	pla
	sta addr+2
*
	lda HandyAddr+2
	ora HandyAddr
	beq ctlStop
	pushlong #mNextCtl
	_WriteCS
CtlAsk	name
	jsr AskReturnESC
	bcs noNextC
	lda HandyAddr+2
	ldy HandyAddr
	brl NextCtl0
noNextC	jsr crout
ctlStop	rts
*
* AskReturnESC -- wait for a Return or ESC key
*
* Return SEC if they hit ESC
*
AskReturnESC	name
	jsr GetKey
	cmp #$000d
	beq @return
	cmp #$001b
	beq @esc
	bra AskReturnESC
@return	clc
@esc	rts
*
* Given a control pointer in addr, calculate CtlProc and CtlKind
*
CalcCtlKind	name
	lda #$ffff
	sta CtlKind
	ldy #$16
	jsr GetWordY
	pha
	sta CtlProc
	ldy #$14
	jsr GetWordY
	plx	;XA = CtlProc
	cmp #0
	beq @isStdC

	cpx #$87ff	;6-Nov-91 DAL ctlKind $00xx = $87FF00xx
	bne @notStdC	;6-Nov-91 DAL ctlKind $0x00 = $0x000000
	tax	;6-Nov-91 DAL
@isStdC	stx CtlKind
@notStdC	rts
*
mNextCtl	DC.B '[ RETURN=next control; ESC=stop ] ',0
ctlKind	DC.W 0
ctlProc	dc.w 0	;high word of ctlProc
nilMsg	DC.B '(nil)'
	DC.B cr,0
cd01	DC.B cr,'      ctlNext: ',0
cd02	DC.B cr,'     ctlOwner: ',0
cd03	DC.B cr,'      ctlRect: ',0
cd04	DC.B cr,'      ctlFlag: ',0
cd05	DC.B cr,'    ctlHilite: ',0
cd11	DC.B cr,'     ctlValue: ',0
cd06	DC.B cr,'      ctlProc: ',0
cd07	DC.B cr,'    ctlAction: ',0
cd08	DC.B cr,'      ctlData: ',0
cd09	DC.B cr,'    ctlRefCon: ',0
cd10	DC.B cr,'     ctlColor: ',0
* standard control record stuff
dumpCtbl	DC.W cd01,dumpLng,$00
	DC.W cd02,dumpLng,$04
	DC.W cd03,dumpRct,$08
	DC.W cd04,dumpByt,$10
	DC.W cd05,dumpByt,$11
	DC.W cd11,dumpWrd,$12
	DC.W cd06,dCtlPrc,$14
	DC.W cd07,dumpLng,$18
	DC.W cd08,dCtlDat,$1C
	DC.W cd09,dumpLng,$20
	DC.W cd10,dumpLng,$24
	dc.w 0
*
* list-record stuff (extension to control record)
*
dumpLCtbl	DC.W lc01,dumpLng,$28	;ctlMemDraw
	DC.W lc02,dumpWrd,$2C	;ctlMemHeight
	DC.W lc03,dumpWrd,$2E	;ctlMemSize
	DC.W lc04,dumpPtr,$30	;ctlList
	DC.W lc05,dumpPtr,$34,0	;ctlListBar
lc01	DC.B    '   ctlMemDraw: ',0
lc02	DC.B cr,' ctlMemHeight: ',0
lc03	DC.B cr,'   ctlMemSize: ',0
lc04	DC.B cr,'      ctlList: ',0
lc05	DC.B cr,'     cListBar: ',0
*
dCtlPrc	name
	jsr dumpLng
	phy
	ldx #0
	stx SpecialFields		;anticipate not-found
	lsr ListCtlFlag
	lda ListDP
	ora ListDP+2
	beq notLctrl
	jsr getwordY
	cmp ListDP
	bne notLctrl
	iny
	iny
	jsr getwordY
	cmp ListDP+2
	bne notLctrl
isROM3LC	sec
	ror ListCtlFlag
	ply
	pushlong #KindL
	_WriteCS
	rts
notLctrl	ply

	phy
	jsr getwordY	;hard-code $FCF0E9 = list control for ROM 03
	cmp #$F0E9	;(alternative to matching GetListDefProc)
	bne notLCtl2
	iny
	iny
	jsr getbyteY
	cmp #$00FC
	beq isROM3LC
notLCtl2	ply

	ldx #0
findCtlName	lda CtlNameList,x
	cmp #$ffff
	beq dCtlPrcX
	cmp CtlKind
	beq dFoundName
	inx
	inx
	inx
	inx
	inx
	inx
	bne findCtlName

dCtlPrcX	pushlong #CustCtlMsg
	_WriteCS
	lda #FieldsCust
	sta SpecialFields

	lda CtlProc
	bpl @notExt
	pushlong #ExtndMsg
	_WriteCS
	lda #FieldsExt
	sta SpecialFields
@notExt	rts

dFoundName	lda CtlNameList+4,x
	sta SpecialFields

	pea Kind00>>16
	lda CtlNameList+2,x
	pha
	_WriteCS
	rts
*
* Six bytes per control kind:  Kind(2),NameString(2),ExtraFieldsTable(2)
*
CtlNameList	dc.w $0000,Kind00,Fields00,$0200,Kind02,Fields02
	dc.w $0400,Kind04,Fields04,$0600,Kind06,Fields06
	dc.w $0800,Kind08,Fields08,$8000,Kind80,Fields80
	dc.w $8100,Kind81,Fields81,$8200,Kind82,Fields82
	dc.w $8300,Kind83,Fields83,$8400,Kind84,Fields84
	dc.w $8500,Kind85,Fields85,$8600,Kind86,Fields86
	dc.w $8700,Kind87,Fields87,$8800,Kind88,Fields88
	dc.w $8900,Kind89,Fields89,$8D00,Kind8D,Fields8D
	dc.w $0001,KindIcon,FieldsIcon
	dc.w $0002,KindThermo,FieldsThermo
	dc.w $0003,KindRect,FieldsRect
	dc.w $ffff
Kind00	DC.B '  simple button',0
Kind02	DC.B '  check box',0
Kind04	DC.B '  radio button',0
Kind06	DC.B '  scroll bar',0
Kind08	DC.B '  size box',0
Kind80	DC.B '  simple button (extended)',0
Kind81	DC.B '  static text (extended)',0
Kind82	DC.B '  check box (extended)',0
Kind83	DC.B '  line edit (extended)',0
Kind84	DC.B '  radio button (extended)',0
Kind85	DC.B '  text edit (extended)',0
Kind86	DC.B '  scroll bar (extended)',0
Kind87	DC.B '  pop up menu (extended)',0
Kind88	DC.B '  size box (extended)',0
Kind89	DC.B '  list (extended)',0
Kind8D	DC.B '  picture (extended)',0
KindIcon	DC.B '  icon Button (extended)',0
KindL	DC.B '  list control',0	;special
KindThermo	dc.b '  thermometer (extended)',0
KindRect	dc.b '  rectangle (extended)',0
CustCtlMsg	dc.b '  custom control',0
ExtndMsg	dc.b ' (extended)',0
*
* dumpCtlSpecial--show extra fields based on ctlKind
*
dumpCtlSpecial	name
	lda #dumpCtlSpecial>>16
	ldy SpecialFields
	beq @noExtra
	jsr dumpByTbl
@noExtra	rts

SpecialFields	dc.w 0
*
* special fields for various control types
* (format is {String(2),DumpProc(2),Offset(2)} $0000)
*
******
*
* Most nonextended controls have no extra fields:
*
Fields00		;simple button
Fields02		;check box
Fields04		;radio button
Fields08		;size box
	dc.w 0
*
* Custom non-extended controls may have extra stuff
* after the end of the standard $28-byte record
*
FieldsCust	dc.w stNull,dumpExtra,$28
	dc.w 0
*
* Custom extended controls--standard fields + possibly
* more stuff at $40.
*
FieldsThermo
FieldsExt	dc.w stReserved,dReserv16,$28
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w stNull,dumpExtra,$40
	dc.w 0
stNull	dc.b cr,0
*
dumpExtra	phy
	pha
	pha		;space for GetHandleSize
	pha
	pha		;space for FindHandle
	pushlong addr
	_FindHandle
	_GetHandleSize
	pla
	ply		;high word of size (assume 0)
	bcs @exit
	sta @size
	ply		;start here
	stz @byteCount
@loop	cpy @size
	bcs @rts
	jsr getbyteY
	jsr prbyte
	jsr spout
	phy
	jsr @maybeCrout
	ply
	iny
	bra @loop

@exit	ply
@rts	rts
@size	dc.w 0
@byteCount	dc.w 0
*
@maybeCrout	inc @byteCount
	lda @byteCount
	cmp #16
	bcc @dun
	stz @byteCount
	jsr crout
@dun	rts
*
* Extended simple buttons, extended check boxes, and extended radio buttons
* all have the same format (generic extended + key equivalents)
*
Fields80		;simple extended button
Fields82		;extended check box
Fields84		;extended radio button
	dc.w stKeyEquiv,dKeyEquiv,$28
	dc.w stReservCR,dReserv10,$2E
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w 0
stKeyEquiv	dc.b    '     keyEquiv: ',0
stReservCR	dc.b cr
stReserved	dc.b    '  ctlReserved: ',0
stContrlID	dc.b cr,'        ctlID: ',0
stMoreFlgs	dc.b cr,' ctlMoreFlags: ',0
stCtlVersn	dc.b cr,'   ctlVersion: ',0
*
Fields81			;extended static text
	dc.w stJust,dumpWrd,$28
	dc.w stReservCR,dReserv14,$2A
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w 0
stJust	dc.b '      ctlJust: ',0
*
Fields85			;extended text edit
	dc.w stTxFlags,dumpLng,$28
	dc.w stTxLen,dumpLng,$2c
	dc.w stCachHnd,dumpLng,$30
	dc.w stCachOff,dumpLng,$34
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w stViewR,dumpRct,$40
	dc.w stTotHt,dumpLngPause,$48
	dc.w stLineSup,dumpSuper,$4c
	dc.w stStylSup,dumpSuper,$58
	dc.w stStylLis,dumpLng,$64
	dc.w stRulrLis,dumpLng,$68
	dc.w stAtEnd,dumpWrd,$6c
	dc.w stSelSt,dumpLng,$6e
	dc.w stSelEn,dumpLng,$72
	dc.w stSelAct,dumpWrd,$76
	dc.w stSelStt,dumpWrd,$78
	dc.w stCaretT,dumpLng,$7A
	dc.w stNullStA,dumpWrd,$7E
	dc.w stNullSt,dumpStyle,$80
	dc.w stTopTxt,dumpLng,$8c
	dc.w stTopTxV,dumpWrd,$90
	dc.w stVrtSc,dumpLng,$92
	dc.w stVrtScPs,dumpLng,$96
	dc.w stVrtScMx,dumpLng,$9a
	dc.w stVrtScAm,dumpWrd,$9E
	dc.w stHrzSc,dumpLng,$A0
	dc.w stHrzScPs,dumpLng,$A4
	dc.w stHrzScMx,dumpLng,$A8
	dc.w stHrzScAm,dumpWrd,$AC
	dc.w stGrowBx,dumpLng,$AE
	dc.w stMaxChar,dumpLng,$B2
	dc.w stMaxLine,dumpLng,$B6
	dc.w stMaxChL,dumpWrd,$BA
	dc.w stMaxHt,dumpWrd,$BC
	dc.w stTxDrMd,dumpWrd,$BE
	dc.w stWrdBrk,dumpLng,$C0
	dc.w stWrdWrp,dumpLng,$C4
	dc.w stKeyFilt,dumpLng,$C8
	dc.w stFiltRct,dumpRct,$CC
	dc.w stBuffVP,dumpWrd,$D4
	dc.w stBuffHP,dumpWrd,$D6
	dc.w stKeyRec1,dumpWrd,$D8
	dc.w stKeyRec2,dumpWrd,$D8+2
	dc.w stKeyRec3,dumpLng,$D8+4
	dc.w stKeyRec4,dumpLng,$D8+8
	dc.w stKeyRec5,dumpWrd,$D8+$C
	dc.w stCaSlOff,dumpLng,$E6
	dc.w stCaVP,dumpWrd,$EA
	dc.w stCaHP,dumpWrd,$EC
	dc.w stMouseR,dumpRct,$EE
	dc.w stMouseT,dumpLng,$F6
	dc.w stMouseK,dumpWrd,$FA
	dc.w stLastClk,dumpLng,$FC
	dc.w stSavedHP,dumpWrd,$100
	dc.w stAnchPt,dumpPnt,$102
	dc.w 0
*
stTxFlags	dc.b    '    textFlags: ',0
stTxLen	dc.b cr,'   textLength: ',0
stCachHnd	dc.b cr,'    blockList: cachedHandle=$',0
stCachOff	dc.b '  cachedOffset=$',0
stViewR	dc.b cr,'     viewRect: ',0
stTotHt	dc.b cr,'  totalHeight: ',0
stLineSup	dc.b cr,'    lineSuper: ',0
stStylSup	dc.b cr,'   styleSuper: ',0
stStylLis	dc.b cr,'    styleList: ',0
stRulrLis	dc.b cr,'    rulerList: ',0
stAtEnd	dc.b cr,'lineAtEndFlag: ',0
stSelSt	dc.b cr,'     selStart: ',0
stSelEn	dc.b cr,' selectionEnd: ',0
stSelAct	dc.b cr,'    selActive: ',0
stSelStt	dc.b cr,'     selState: ',0
stCaretT	dc.b cr,'    caretTime: ',0
stNullStA	dc.b cr,' nullStyleAct: ',0
stNullSt	dc.b cr,'    nullStyle: ',0
stTopTxt	dc.b cr,'topTextOffset: ',0
stTopTxV	dc.b cr,'  topTextVPos: ',0
stVrtSc	dc.b cr,'vertScrollBar: ',0
stVrtScPs	dc.b cr,'vertScrollPos: ',0
stVrtScMx	dc.b cr,'vertScrollMax: ',0
stVrtScAm	dc.b cr,'vertScrollAmt: ',0
stHrzSc	dc.b cr,'horzScrollBar: ',0
stHrzScPs	dc.b cr,'horzScrollPos: ',0
stHrzScMx	dc.b cr,'horzScrollMax: ',0
stHrzScAm	dc.b cr,'horzScrollAmt: ',0
stGrowBx	dc.b cr,'growBoxHandle: ',0
stMaxChar	dc.b cr,' maximumChars: ',0
stMaxLine	dc.b cr,' maximumLines: ',0
stMaxChL	dc.b cr,'maxCharsPerLn: ',0
stMaxHt	dc.b cr,'maximumHeight: ',0
stTxDrMd	dc.b cr,' textDrawMode: ',0
stWrdBrk	dc.b cr,'wordBreakHook: ',0
stWrdWrp	dc.b cr,' wordWrapHook: ',0
stKeyFilt	dc.b cr,'    keyFilter: ',0
stFiltRct	dc.b cr,'theFilterRect: ',0
stBuffVP	dc.b cr,'theBufferVPos: ',0
stBuffHP	dc.b cr,'theBufferHPos: ',0
stKeyRec1	dc.b cr,' theKeyRecord: theChar=$',0
stKeyRec2	dc.b ' theMods=$',0
stKeyRec3	dc.b ' theInHand=$',0
stKeyRec4	dc.b cr,'               cursOffset=$',0
stKeyRec5	dc.b ' theOpCode=$',0
stCaSlOff	dc.b cr,'cachSelOffset: ',0
stCaVP	dc.b cr,' cachSelcVPos: ',0
stCaHP	dc.b cr,' cachSelcHPos: ',0
stMouseR	dc.b cr,'    mouseRect: ',0
stMouseT	dc.b cr,'    mouseTime: ',0
stMouseK	dc.b cr,'    mouseKind: ',0
stLastClk	dc.b cr,'    lastClick: ',0
stSavedHP	dc.b cr,'    savedHPos: ',0
stAnchPt	dc.b cr,'  anchorPoint: ',0
*
* dump a Text Edit SuperHandle
*
dumpSuper	name
	phy
	pushlong #stCachHand
	_WriteCS
	ply
	phy
	jsr dumpLng
	pushlong #stCachOffset
	_WriteCS
	ply
	iny
	iny
	iny
	iny
	phy
	jsr dumpLng
	pushlong #stCachIndex
	_WriteCS
	ply
	iny
	iny
	iny
	iny
	phy
	jsr dumpWrd
	pushlong #stItemPerBlk
	_WriteCS
	ply
	iny
	iny
	jsr dumpWrd
	rts
*
stCachHand	dc.b 'cachedHandle=$',0
stCachOffset	dc.b ' cachedOffset=$',0
stCachIndex	dc.b cr,'               cachedIndex=$',0
stItemPerBlk	dc.b ' itemsPerBlock=$',0
*
dumpStyle	name
	phy
	pushlong #stFontID
	_WriteCS
	ply
	phy
	jsr dumpLng
	pushlong #stForeColor
	_WriteCS
	ply
	iny
	iny
	iny
	iny
	phy
	jsr dumpWrd
	pushlong #stBackColor
	_WriteCS
	ply
	iny
	iny
	phy
	jsr dumpWrd
	pushlong #stUserData
	_WriteCS
	ply
	iny
	iny
	jmp dumpLng
*
stFontID	dc.b 'fontID=$',0
stForeColor	dc.b ' foreColor=$',0
stBackColor	dc.b ' backColor=$',0
stUserData	dc.b cr,'               userData=$',0
*
*
Fields87		;extended pop-up menu
	dc.w stMRef,dumpLng,$28
	dc.w stMEnd,dumpLng,$2c
	dc.w stPopRect,dumpRct,$30
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w stTitleWid,dumpWrd,$40
	dc.w 0
stMRef	dc.b    '      menuRef: ',0
stMEnd	dc.b cr,'      menuEnd: ',0
stPopRect	dc.b cr,'    popUpRect: ',0
stTitleWid	dc.b cr,'   titleWidth: ',0
*
Fields89		;extended list
	DC.W lc01,dumpLng,$28	;ctlMemDraw
	DC.W lc02,dumpWrd,$2C	;ctlMemHeight
	DC.W lc03,dumpWrd,$2E	;ctlMemSize
	DC.W stListRef,dumpPtr,$30	;ctlListRef
	DC.W lc05,dumpPtr,$34	;ctlListBar
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w 0
stListRef	dc.b cr,'   ctlListRef: ',0

*
FieldsIcon		;extended icon button
	dc.w stKeyEquiv,dKeyEquiv,$28
	dc.w stReservCR,dReserv10,$2E
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w stIconRef,dumpLng,$40
	dc.w stDispMode,dumpWrd,$44
	dc.w 0
stIconRef	dc.b cr,'      iconRef: ',0
stDispMode	dc.b cr,'  displayMode: ',0

FieldsRect		;extended rectangle
	dc.w stKeyEquiv,dKeyEquiv,$28
	dc.w stReservCR,dReserv10,$2E
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w rcPenHeight,dumpWrd,$40
	dc.w rcPenWidth,dumpWrd,$42
	dc.w rcPenMask,dump8,$44	;8 bytes
	dc.w rcPenPatt,dump16,$4C	;(patt = 32 bytes total)
	dc.w rcPenPatt2,dump16,$5C	;16 more bytes
	dc.w 0
rcPenHeight	dc.b cr,'    penHeight: ',0
rcPenWidth	dc.b '  penWidth: ',0
rcPenMask	dc.b cr,'      penMask: ',0
rcPenPatt	dc.b cr,'   penPattern: ',0
rcPenPatt2	dc.b cr,'               ',0


*
* Scroll Bar extra fields
*
Fields06		;nonextended scroll bar
	dc.w stThumbR,dumpRct,$28
	dc.w stPageR,dumpRct,$30
	dc.w 0
stThumbR	dc.b    '    thumbRect: ',0
stPageR	dc.b cr,'   pageRegion: ',0
*
Fields86		;extended scroll bar
	dc.w stThumbR,dumpRct,$28
	dc.w stPageR,dumpRct,$30
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w 0
*
* Extended Line Edit, Extended size box, and extended picture
* all have generic format
*
Fields83		;extended line edit
Fields88		;extended size box
Fields8D		;extended picture
	dc.w stReserved,dReserv16,$28
	dc.w stContrlID,dumpLng,$38
	dc.w stMoreFlgs,dumpWrd,$3c
	dc.w stCtlVersn,dumpWrd,$3e
	dc.w 0

***************************************************
*
* display key-equivalent field
*
***************************************************
dKeyEquiv	name
	phy
	pushlong #mKey1
	_WriteCS
	ply
	phy
	jsr GetByteY
	jsr PrintKey
	pushlong #mKey2
	_WriteCS
	ply
	iny
	phy
	jsr GetByteY
	jsr PrintKey
	pushlong #mKeyMod
	_WriteCS
	ply
	iny
	phy
	jsr GetWordY
	jsr prword
	pushlong #mKeyCare
	_WriteCS
	ply
	iny
	iny
	jsr GetWordY
	jsr prword
	rts
mKey1	dc.b 'key1=$',0
mKey2	dc.b ' key2=$',0
mKeyMod	dc.b ' keyModifiers=$',0
mKeyCare	dc.b ' keyCareBits=$',0
*
* PrintKey:  show in hex and, if printable, show literally
*
PrintKey	name
	pha
	jsr prbyte
	pla
	cmp #$7f
	bcs @pkNo
	cmp #$20
	bcc @pkNo
	pha
	jsr spout
	lda #'('
	jsr cout
	pla
	jsr cout
	lda #')'
	jsr cout
@pkNo	rts
*
* display reserved bytes, or other blocks of unformatted bytes
*
dump8	ldx #8
	bra ResSome
dReserv14	ldx #14
	bra ResSome
dump16
dReserv16	ldx #16
	bra ResSome
dReserv10	ldx #10
ResSome	phx
	phy
	jsr GetByteY
	jsr prbyte
	jsr spout
	ply
	plx
	iny
	dex
	bne ResSome
	rts

***************************************************
*
* display ctlData field
*
***************************************************
dCtlDat	name
	phy
	jsr dumpLng
	ply
	lda CtlKind
	cmp #$0000	;nonextended simple button
	beq ctlTtl
	cmp #$0200	;nonextended check box
	beq ctlTtl
	cmp #$0400	;nonextended radio button
	beq ctlTtl
	cmp #$8000	;extended simple button
	beq ctlTitleRef
	cmp #$8200	;extended check box
	beq ctlTitleRef
	cmp #$8400	;extended radio button
	beq ctlTitleRef
;	cmp #$87ff	;extended icon button
;	beq ctlTitleRef
;	cmp #$07ff	;extended icon button(?)
;	beq ctlTitleRef
	cmp #$0001	;extended icon button
	beq ctlTitleRef	;6-Nov-91 DAL

	rts
ctlTtl	jsr spout2
	lda #'"'
	jsr cout
	phy
	iny
	iny
	jsr GetWordY
	ply
	pha
	jsr GetWordY
	pha
	pea nlShowStr
	jsl nlService
	lda #'"'
	jsr cout
	rts
*
ctlTitleRef	name
	jsr GetWordY
	sta cTitlePtr
	iny
	iny
	jsr GetWordY
	sta cTitlePtr+2
	ldy #$3c
	jsr GetByteY	;get low byte of ctlMoreFlags
	and #%00000011
	beq @isPtr
	dec a
	beq @isHandle
	dec a
	beq @isResource
	rts
*
@isResource pushlong #msgIsRsrc
	_WriteCS
	rts
*
@isHandle	phd
	pushlong cTitlePtr
	tsc
	tcd
	ldy #hFlags
	lda [1],y
	pha
	pei 3
	pei 1
	_HLock
	ldy #2
	lda [1],y
	sta cTitlePtr+2
	lda [1]
	sta cTitlePtr
	jsr @isPtr
	pla
	ldy #hFlags
	sta [1],y
	pla
	pla
	pld
	rts
*
@isPtr	lda cTitlePtr+2
	bne @isPtrOK
	lda cTitlePtr
	beq @isNIL
@isPtrOK	jsr spout2
	lda #'"'
	jsr cout
	pushlong cTitlePtr
	pea nlShowStr
	jsl nlService
	lda #'"'
	jsr cout
@isNIL	rts

msgIsRsrc	dc.b '  (rPString resource ID)',0

cTitlePtr	dc.l 0

************************************************
*
* ;M -- dump a menu bar handle
*
************************************************
intMenu
DumpMenu	name
	lda addr+2
	ora addr
	php
	lda addr+2
	ldy addr
	plp
	bne mNotNIL
	pha
	pha
	_GetMenuBar
	ply
	pla
	bcc mNotNIL
	rts
mNotNIL	jsr derefAY
	sta addr+2
	sty addr
*
	jsr CalcCtlKind
*
	lda #dumpCtbl>>16
	ldy #dumpCtbl
	jsr DumpByTbl
	ldy #$28
dNextMnu	phy
	pushlong addr
	phd
	tsc
	tcd
	lda [3],y
	pha
	iny
	iny
	lda [3],y
	ply
	jsr derefAY
	ror menuDone
	bmi skipmenu
	sta addr+2
	sty addr
	jsr dump1menu
	jsr AskNextMenu
	ror menuDone
skipmenu	pld
	pla
	sta addr
	pla
	sta addr+2
	ply
	iny
	iny
	iny
	iny
	bit menuDone
	bpl dNextMnu
	rts

menuDone	dc.w 0
*
dump1menu	name
	jsr crout
	lda addr+2
	ldx addr
	jsr praddr
	lda #':'
	jsr cout
	lda #dumpMtbl>>16
	ldy #dumpMtbl
	jsr DumpByTbl
	rts
*
m00	DC.B cr
	DC.B '    menuID: ',0
m01	DC.B '  titleName: ',0
m02	DC.B cr
	DC.B ' titleWdth: ',0
m03	DC.B '  menuWidth: ',0
m04	DC.B '  menuHeight: ',0
m05	DC.B cr
	DC.B '  menuProc: ',0
m06	DC.B cr
	DC.B '  menuFlag: ',0
m07	DC.B '  menuRes: ',0
m08	DC.B cr
	DC.B 'numOfItems: ',0
m10	DC.B cr,' menuCache: ',0
dumpMtbl	DC.W m00,dumpWrd,$00
	DC.W m01,dumpMTtl,$10
	DC.W m02,dumpWrd,$0E
	DC.W m03,dumpWrd,$02
	DC.W m04,dumpWrd,$04
	DC.W m05,dumpLng,$06
	DC.W m06,dumpByt,$0A
	DC.W m07,dumpByt,$0B
	DC.W m08,dumpWrd,$0C
	DC.W m10,dumpLng,$14
	DC.W 0
*
* dumpMTtl -- like dumpStr, but checks for a reasonable pointer first
*
dumpMTtl	name
	sty @yval
	jsr getwordY
	sta @dmtVal
	iny
	iny
	jsr getwordY
	sta @dmtVal+2

	pha
	lda @dmtVal
	pha
	_CheckHandle
	bcc @isHandle

	pea 0
	_ResourceStatus
	pla
	beq @isPtr

	pha	;space for fileID
	pea $8006	;rPString
	lda @dmtVal+2
	pha
	lda @dmtVal
	pha
	_HomeResourceFile
	pla
	bcc @isRsrc

@isPtr	ldy @yval
	jmp dumpStr

@yval	dc.w 0
@dmtVal	dc.l 0

@isHandle
@isRsrc	lda @dmtVal+2
	jsr prword
	lda @dmtVal
	jmp prword
*
AskNextMenu	name
	pushlong #mNextMenu
	_WriteCS
mnuAsk	jsr GetKey
	and #$007f
	cmp #$000d
	beq mnuCont
	cmp #$001b
	bne mnuAsk
mnuStop	sec
	rts
mnuCont	clc
	rts
*
mNextMenu	dc.b '[ RETURN=next menu; ESC=stop ] ',0
*
derefAY	name
	tax
	bne derNnil
	cpy #0
	bne derNnil
	sec
	rts
derNnil	phd
	pha
	phy
	tsc
	tcd
	ldy #2
	lda [1],y
	pha
	lda [1]
	tay
	pla
	plx
	plx
	pld
	clc
	rts

*****************************************************
*
* ;S -- interpret stack history
*
*****************************************************
intStack
StackDump	name
	pushlong #Stkmsg
	_WriteCS

	lda curBank	;is this good?
	and #$00ff
	sta stkCurBank

	lda Num1
StackDumpContinueA
	sta stack
	sta OrigStack
	jsr CalcSLimit
	lda #0
	sta byteCount
	lda #1500	;originally 15
	sta lineCount
	inc stack

sdLoop	lda lineCount
	beq sdDun
	lda stack
	cmp stkLimit
	bcs sdHitEnd
	jsr CheckRetAdr
	bcc sdLoop
	jsr StackByte
	bra sdLoop

*
* If GS/OS is busy and we just finished dumping its stack,
* then dump the caller's stack, as stored at $00BD48.
*
sdHitEnd	cmp #$be00
	bcc sdDun
	lda >$e100be	;GS/OS busy?
	bpl sdDun	;no, done
	jsr crout
	lda >$00bd48
	brl StackDumpContinueA

sdDun	rts
*
StackByte	name
	lda byteCount
	bne nonZerCnt
	lda stack
	jsr prword
	lda #':'
	jsr cout
	lda byteCount	;20-Oct-90
nonZerCnt	inc a
	sta byteCount
	cmp #17
	bcc thisLine
	jsr StackNewLine
	bra StackByte

thisLine	lda stack
	tax
	lda >0,x
	and #$00ff
	jsr prbyte
	jsr spout
	inc stack
	rts
*
StackNewLine	lda ByteCount
	php
	stz byteCount
	lda lineCount
	beq @lcZero
	dec a
@lcZero	sta lineCount
	plp
	beq @noCrout	;if we were already at the line start, don't CR
	jsr crout
@noCrout	rts
*
CheckRetAdr	name	;returns clc if found one
	jsr CheckJSR
	bcc craDone
	jsr CheckJSL
craDone	rts
*
CheckJSR	name	;clc if found
	phd
	lda stkCurBank
	pha
	lda stack
	tax
	lda >0,x
	dec a	;back up 2 bytes and look for JSR
	dec a
	pha
	tsc
	tcd
	lda [1]
	and #$00ff
	cmp #$FC	;7-Jan-91 DAL: JSR ($zzzz,X)
	beq @isJSR	;7-Jan-91 DAL
	cmp #$20	;JSR
	bne @notJSR
@isJSR	jsr STKisJSR
	clc
	bra exitJSR
@notJSR	sec
exitJSR	plx
	plx
	pld
	rts

STKisJSR	name
	jsr StackNewLine
	jsr StackByte
	jsr StackByte
	pushlong #JSR1msg
	_WriteCS
	lda 3
	jsr prbyte
	lda 1
	jsr prword
	pushlong #JSR2msg
	_WriteCS
	pushlong addr	;3-Dec-90: now uses DisasmEntry
	lda 1
	sta addr
	lda 3
	sta addr+2
	jsr getbyte
	jsr OpInfo
	jsr DisasmEntry
	pla
	sta addr
	pla
	sta addr+2
	brl StackNewLine
*
JSR1msg	dc.b '     ',0
JSR2msg	dc.b ': ',0
*
CheckJSL	name
	phd	;clc if found
	lda stack
	tax
	lda >2,x
	pha
	lda >0,x
	dec a	;back up 3 bytes and look for JSL
	dec a
	dec a
	pha
	tsc
	tcd
	lda [1]
	and #$00ff
	cmp #$22	;JSL
	bne STKnotJSL
	jsr STKisJSL
	clc
	bra exitJSL
STKnotJSL	sec
exitJSL	plx
	plx
	pld
	rts

STKisJSL	name
	jsr StackNewLine
	jsr StackByte
	jsr StackByte
	jsr StackByte
	pushlong #JSL1msg
	_WriteCS
	lda 3
	and #$00ff
	sta stkCurBank
	jsr prbyte
	lda 1
	jsr prword
	pushlong #JSL2msg
	_WriteCS
	pushlong addr	;3-Dec-90: now uses DisasmEntry
	lda 1
	sta addr
	lda 3
	sta addr+2
	jsr getbyte
	jsr OpInfo
	jsr DisasmEntry
	pla
	sta addr
	pla
	sta addr+2
	brl StackNewLine
*
JSL1msg	dc.b '  ',0
JSL2msg	dc.b ': ',0
JSL3msg	dc.b ', X=$',0
*
StkShowProcName	pha
	phy
	ldx #2
	jsr PrintXBlanks
	lda #'>'
	jsr cout
	pea nlShowStr
	jsl NLService
	rts
*
CalcSLimit	name
	phd
	lda #$200
	sta stkLimit
	lda OrigStack
	cmp #$200
	bcc sDone
*** 10-Feb-92
	lda #$c000
	sta stkLimit
***
	pea 0
	pea 0
	tsc
	tcd
	pea 0
	lda OrigStack
	pha
	_FindHandle
	lda 1
	ora 3
	beq sNotAloc
	clc
	lda [1]
	ldy #8	;low word of block size
	adc [1],y
	sta stkLimit
sNotAloc	pla
	pla
sDone	pld
	rts
*
stkmsg	dc.b 13,'Stack contents:',13,0

stkCurBank	dc.w 0
OrigStack	dc.w 0
stack	dc.w 0
stkLimit	dc.w 0
byteCount	dc.w 0
lineCount	dc.w 0

*******************************************************
*******************************************************
*
* ~ -- print misc info
*
*******************************************************
isTilde	name
	jsr chrgotAdvance
	bcs tildeErr
	jsr upcase
	cmp #'M'
	beq tildeM
	cmp #'S'
	bne notTildeS
	brl tildeS
notTildeS
	cmp #'H'
	bne notTildeH
	brl tildeH
notTildeH
	cmp #'W'
	bne notTildeW
	brl tildeW
notTildeW
	cmp #'P'
	bne notTildeP
	brl tildeP
notTildeP
tildeErr	pushlong #desTilde
	_WriteCS
	rts
*
* ~m = MessageCenter info--
*   check ToolLocator version >= 2.1
*   get MemoryManager WAP = handle to msg chain
*   follow chain (checking for valid handles)
*     display list of types, handles, sizes
*
ListMessages	name
tildeM	phd
	pha
	pha
	tsc
	tcd	;4 bytes at 1..4
	lda #0
	pha
	pha
	pha	;0=system tools
	pea 2	;mem mgr
	_GetWAP
	pla
	sta 1
	pla
	sta 3
	ora 1
	beq mcDun0
*
	pushlong #mcMsg
	_WriteCS
	pushlong #mcMsg2
	jsr WriteNoVoice
*
* 1..4 = handle to a message record (6+x bytes)
*   1st 4 bytes = link to next record
*
mcWhile	lda 1
	ora 3
mcDun0	beq mcDun
	jsr FollowPtr	;1..4=ptr to msg record
*
	ldy #4
	lda [1],y
	sta msgcType
	jsr prwordSpout	;type
	clc
	lda 1
	adc #6
	pha
	lda 3
	adc #0
	sta HandyAddr+2
	jsr prbyte	;address high
	pla
	sta HandyAddr
	jsr prwordSpout	;address low
	lda #0
	pha	;space for GetHandSize
	pha
	pha	;space for FindHandle
	pha
	pei 3
	pei 1
	_FindHandle
	_GetHandleSize
	pla
	sec
	sbc #6
	tax
	pla
	phx
	sbc #0
	jsr prbyte
	pla
	jsr prword
	jsr msgcExplType
*
mcNext	jsr crout
	jsr FollowPtr
	brl mcWhile
mcDun	pla
	pla
	pld
	rts
*
FollowPtr	ldy #2
	lda [1],y
	tax
	lda [1]
	sta 1
	stx 3
	rts
*
msgcExplType	jsr spout2
	lda msgcType
	cmp #$b0b0	;Claris stole this type
	beq @Claris
	cmp #$8000
	bcs msgcName
	ldx #12
	jsr PrintXBlanks
	lda msgcType
	cmp #1
	beq msgcFndr
	cmp #2
	beq msgcDesk
	cmp #$0011
	beq msgcFndrLong
@Claris	rts

msgcFndr	pushlong #msgc1
	_WriteCS
	rts

msgcDesk	pushlong #msgc2
	_WriteCS
	rts

msgcFndrLong	pushlong #msgc11
	_WriteCS
	rts

msgcName	phd
	pushlong HandyAddr
	tsc
	tcd
*** 6-Nov-91 DAL -- If this is an AcceptRequests entry, show ID and proc
	ldy #3
	lda [1],y
	cmp #$3eff	;AcceptRequests signature
	bne @notReqProc

	ldy #2
	jsr get1y
	clc
	adc #3
	tay
	phy
	lda [1],y
	jsr prword
	jsr spout
	ply
	iny
	iny
	lda [1],y
	pha
	iny
	iny
	lda [1],y
	jsr prbyte
	pla
	jsr prword
	bra @showName

@notReqProc	ldx #11
	jsr PrintXBlanks
@showName	jsr spout
*** end 6-Nov-91
	lda #$22
	jsr cout
	ldy #2
	jsr get1y
	clc
	adc #3
	sta msgcLimit
	iny	;y=3
msgcN1	lda [1],y
	jsr aCout
	iny
	cpy msgcLimit
	bcc msgcN1
	lda #$22
	jsr cout
	pla
	pla
	pld
	rts
*
msgcType	dc.w 0
msgcLimit	dc.w 0
mcMsg	dc.b 'type addr   size    id   proc   name',cr,0
mcMsg2	dc.b '---- ------ ------  ---- ------ ----',cr,0
msgc1	dc.b '(pstring paths to Open/Print)',0
msgc2	dc.b '(desktop pattern/picture)',0
msgc11	dc.b '(wstring paths to Open/Print)',0
*
* ~s = ScrapManager info--
*   check that scrap manager is present and active
*   get the WAP = handle to list of scrap records
*   display list of types, handles, sizes
*
ListScraps	name
tildeS	pea 0
	_ScrapStatus
	pla
	bne ScrapAct
	brl ScrapNotAct


ScrapAct
	pha
	_ScrapVersion
	pla
	and #$0fff
	cmp #$0301	;SpongBoy Scrap Manager version
	bcc OldScrapWalk

	pushlong #BriefScrapMsg
	_WriteCS
	pushlong #scMsg3
	jsr WriteNoVoice

	lda #1	;index = first scrap
@OneScrap	pha

	pha
	pushlong #ScrInfoBuff
	ldx #$1416
	jsl $e10000
;	_GetIndScrap
	pla
	bcs @done
	pha

	lda ScrInfoBuff+8
	jsr prbyte
	lda ScrInfoBuff+6
	jsr prwordSpout
	lda ScrInfoBuff+4
	jsr prbyte
	lda ScrInfoBuff+2
	jsr prwordSpout
	lda ScrInfoBuff
	pha
	jsr prwordSpout
	pla
	jsr PrintScrapName
	jsr crout	

	pla
	inc a
	bra @OneScrap
@done	rts

ScrInfoBuff	dc.w 0	;scrap type
	dc.l 0	;scrap size
	dc.l 0	;scrap handle

*
* Older way of dumping scrap list--walk through all types!
*
OldScrapWalk	pushlong #scMsg2
	_WriteCS
	pushlong #scMsg3
	jsr WriteNoVoice
	lda #0
scrap1	pha
	pea 0
	pea 0
	pha
	_GetScrapHandle
	plx
	pla
	bcs nextScrp

	pha
	phx
	jsr prbyte
	lda 1,s
	jsr prwordSpout	;printed handle

	pha
	pha	;space for GetHandleSize
	lda 7,s
	pha
	lda 7,s
	pha
	_GetHandleSize
	lda 3,s
	jsr prbyte
	pla
	jsr prwordSpout
	pla	;printed handle size

	pla
	pla	;pull handle

	lda 1,s	;scrap type
	jsr prwordSpout
	lda 1,s
	jsr PrintScrapName
	jsr crout

nextScrp	jsr CheckKey
	bcc scrAbort
	pla
	inc a
	bne scrap1
	rts
scrAbort	jmp DoAbort	;too long for a BRL!
*
ScMsg2	DC.B '(Takes a minute or two--hit a key to abort)',cr
BriefScrapMsg	DC.B cr
	dc.b 'handle size   type',cr,0
ScMsg3	dc.b '------ ------ ----',cr,0
*
ScrapNotAct	pushlong #sNotMsg
	_WriteCS
	rts

sNotMsg	DC.B 'Scrap Manager not loaded',cr,0

PrintScrapName	sta ScrapNameTbl
	ldx #ScrapNamesEnd-ScrapNameTbl
@search	dex
	dex
	dex
	dex
	cmp ScrapNameTbl,x
	bne @search
	pea ScrapNameTbl>>16
	lda ScrapNameTbl+2,x
	pha
	_WriteCS
	rts
*
* ScrapNameTbl--one word scrap type followed by one word
*               string pointer.
*
ScrapNameTbl	dc.w $7777,scrapOther	;first entry is catch-all
	dc.w $0000,scrapText
	dc.w $0001,scrapPict
	dc.w $0002,scrapSound
	dc.w $0064,scrapTEStyle
	dc.w $4945,scrapIcon
	dc.w $8000,scrapMask
	dc.w $8001,scrapColorTbl
	dc.w $8003,scrapResRef
ScrapNamesEnd

scrapOther	dc.b 0
scrapText	dc.b '(text)',0
scrapPict	dc.b '(picture)',0
scrapSound	dc.b '(sound)',0
scrapTEStyle	dc.b '(Text Edit style info)',0
scrapIcon	dc.b '(Icon Data)',0
scrapMask	dc.b '(mask)',0
scrapColorTbl	dc.b '(color table)',0
scrapResRef	dc.b '(resource reference)',0

*
* ~H -- dump heartbeat queue!
*
ListHeartbeat	name
tildeH	phd
	pea $00E1
	pea $00D8	;not guaranteed!
	tsc
	tcd	;1..3 --> heartbeat queue
	pushlong #hbMSG
	_WriteCS
	pushlong #hbMSG2
	jsr WriteNoVoice
	jsr tildeH2
	pla
	pla
	pld
	rts
hbMSG	DC.B 'Entry   handle addr   size   flgs ownr path',cr,0
hbMSG2	DC.B '------  ------ ------ ------ ---- ---- ----',cr,0
*
tildeH2	lda 1
	ora 3
	bne hbCont
hbEnd	rts
hbCont
	ldy #2
	lda [1],y
	tax
	lda [1]
	sta 1
	stx 3
	ora 3
	beq hbEnd
	ldy #6
	lda [1],y
	cmp #$A55A
	beq hbOK
	pushlong #hbDamage
	_WriteCS
	rts
hbDamage	DC.B 'HB queue damaged: $A55A sig missing'
	DC.B cr,0

hbOK	lda 3
	jsr prbyte
	lda 1
	clc
	adc #8
	jsr prword
	lda #$3a
	jsr cout
	jsr spout
	pea 0
	pea 0
	pei 3
	pei 1
	_FindHandle
	plx
	pla
	bne hbIsAllc
	cpx #0
	bne hbIsAllc
	brl NotAllocated
hbIsAllc	jsr PrHandInfo
	brl tildeH2

**********************************************
*
* ~w: dump window list
*
* address frame title
* ------- ----- -----
*
wmHDR	DC.B 'address frame title',cr,0
wmHDR2	DC.B '------- ----- -----',cr,0
*
ListWindows	name
tildew	pushlong #wmHDR
	_WriteCS
	pushlong #wmHDR2
	jsr WriteNoVoice
	jsr MyFirstWind
	tyx
	bra Wind9
Wind1	sta WindP+2
	stx WindP
	jsr Pr1Wind
	lda #0
	pha
	pha
	lda WindP+2
	pha
	lda WindP
	pha
	_GetNextWindow
	plx
	pla
Wind9	cmp #0
	bne Wind1
	cpx #0
	bne Wind1
	rts
*
Pr1Wind	name
	jsr spout
	lda WindP+2
	jsr prbyte
	lda WindP
	jsr prword
	jsr spout2
	pea 0
	pushlong WindP
	_GetWFrame
	pla
	sta TheFrame
	jsr prwordSpout
	jsr PrWtitle
	brl crout
*
PrWtitle	lda TheFrame
	and #$0020		;visible?
	bne isVis
	lda #'['
	jsr cout
isVis	lda #0
	pha
	pha
	pushlong WindP
	_GetWTitle
	bcs ttlErr
	lda 1,s
	ora 3,s
	bne tNotNIL
	pla
	pla
	bra titleNIL
tNotNIL
*
* Dereference the window title address if it's a handle
*
	phd
	tsc
	tcd
	lda 5
	bpl @titleNotHand
	ldy #2
	lda [3],y
	and #$00ff
	tax
	lda [3]
	sta 3
	stx 5
	lda #'+'	;print a "+" before the title
	jsr cout	;if it was a handle

@titleNotHand	pld
	pea nlShowStr
	jsl nlService
titleNIL	lda TheFrame
	and #$0020	;visible?
	bne isVis2
	lda #']'
	jsr cout
isVis2	rts
*
ttlErr	cmp #$0010
	bcs badWind
	pla
	pla
badWind	pla
	pla
	rts
*
WindP	DC.L 0
TheFrame	DC.W 0
*
* VerifyW -- return CLC if AY is in the window list
*
VerifyW	name
	tax
	bne @notNil
	tyx
	bne @notNil
	lda #0
	pha
	pha
	_FrontWindow
	tsc
	pea 0
	inc a
	pha
	pea cbFunWindow
	jsl doCallBack
	ply
	pla
@notNil	sta verWind+2
	sty verWind
	jsr MyFirstWind
VerifyW1	cmp #0
	bne VerW2
	cpy #0
	bne VerW2
	sec
	rts
VerW2	cmp verWind+2
	bne VerW3
	cpy verWind
	bne VerW3
	clc
	rts
VerW3	pea 0
	pea 0
	pha
	phy
	_GetNextWindow
	ply
	pla
	bra VerifyW1
verWind	DC.L 0
*
* MyFirstWind -- call GetFirstWindow, allowing for the bug in
*	       WindMgr < 2.2 (return value was too low by 4)
*	       AND the bug in 2.2 where $000004 is returned
*	       when there is NO front window!
*
fwNIL	lda #0
	tay
	rts
MyFirstWind	pea 0
	_WindStatus
	pla
***	bcs fwNIL	;28-Sep-90 DAL for better compatibility
	beq fwNIL
	lda #0
	pha
	pha
	_GetFirstWindow
	lda 3,s
	bne SomeWinds
	lda 1,s
	beq noWinds
	cmp #4
	bne SomeWinds
noWinds	ply
	ldy #0
	pla
	rts
SomeWinds
	pea 0
	_WindVersion
	pla
	and #$0fff	;was $7fff 7-Jan-91 DAL
	tax
	lda #0		;add 0 to GetFirstW result
	cpx #$0202
	bcs noAdjWM
	lda #4		;add 4 to GetFirstW result
noAdjWM	clc
	adc 1,s
	plx
	tay
	pla
	adc #0
	rts
*
* ~p -- show interesting port pointers
*
DumpPorts	name
tildeP	lda #PortTbl>>16
	ldy #PortTbl
	brl DumpByTbl
*
portCurr	DC.B '       GetPort: ',0
portWind	DC.B cr
	DC.B '   GetWMgrPort: ',0
portMenu	DC.B cr
	DC.B 'GetMenuMgrPort: ',0
PortTbl	DC.W portCurr,dTool4,$1C04	;GetPort
	DC.W portWind,dTool4,$200E	;GetWMgrPort
	DC.W portMenu,dTool4,$1B0F	;GetMenuMgrPort
	DC.W 0
*
dTool4	pha
	and #$00ff
	ora #$0600	;xxxStatus
	tax
	pea 0
	jsl tool
	pla
	cmp #$0001	;SEC = nonzero status!
	pla
	bcs dToolOK
	pushlong #notAct
	_WriteCS
	rts
notAct	DC.B 'toolset inactive'
	DC.B 0
dToolOK	tax
	pea 0
	pea 0
	jsl tool
	lda 3,s
	jsr prbyte
	pla
	jsr prword
	pla
	rts

**********************************************
**********************************************
*
* Modified 28-Jun-87 DL
*   Addressing modes for $01 and $37 fixed
*
**********************************************
*
* Tables for List
*
**********************************************
*
* MnemTbl -- table of 3-byte mnemonics 0..90
*
MnemTbl	DC.B 'ADCANDASLBCCBCSBITBEQBMIBNEBPL'
	DC.B 'BRABRLBVCBVSBRKCLCCLDCLICLVCMP'
	DC.B 'COPCPXCPYDECDEXDEYEORINCINXINY'
	DC.B 'JMLJMPJSLJSRLDALDXLDYLSRMVNMVP'
	DC.B 'NOPORAPEAPEIPERPHAPHBPHDPHKPHP'
	DC.B 'PHXPHYPLAPLBPLDPLXPLYREPROLROR'
	DC.B 'RTIRTLRTSSBCSECSEDSEISEPSTASTP'
	DC.B 'STXSTYSTZTAXTAYTCDTCSTDCTRBTSB'
	DC.B 'TSCTSXTXATXSTXYTYATYXWAIWDMXBA'
	DC.B 'XCEPLP'
*
* mnemonic codes for following table
*
mADC	equ 00
mAND	equ 01
mASL	equ 02
mBCC	equ 03
mBCS	equ 04
mBIT	equ 05
mBEQ	equ 06
mBMI	equ 07
mBNE	equ 08
mBPL	equ 09
mBRA	equ 10
mBRL	equ 11
mBVC	equ 12
mBVS	equ 13
mBRK	equ 14
mCLC	equ 15
mCLD	equ 16
mCLI	equ 17
mCLV	equ 18
mCMP	equ 19
mCOP	equ 20
mCPX	equ 21
mCPY	equ 22
mDEC	equ 23
mDEX	equ 24
mDEY	equ 25
mEOR	equ 26
mINC	equ 27
mINX	equ 28
mINY	equ 29
mJML	equ 30
mJMP	equ 31
mJSL	equ 32
mJSR	equ 33
mLDA	equ 34
mLDX	equ 35
mLDY	equ 36
mLSR	equ 37
mMVN	equ 38
mMVP	equ 39
mNOP	equ 40
mORA	equ 41
mPEA	equ 42
mPEI	equ 43
mPER	equ 44
mPHA	equ 45
mPHB	equ 46
mPHD	equ 47
mPHK	equ 48
mPHP	equ 49
mPHX	equ 50
mPHY	equ 51
mPLA	equ 52
mPLB	equ 53
mPLD	equ 54
mPLX	equ 55
mPLY	equ 56
mREP	equ 57
mROL	equ 58
mROR	equ 59
mRTI	equ 60
mRTL	equ 61
mRTS	equ 62
mSBC	equ 63
mSEC	equ 64
mSED	equ 65
mSEI	equ 66
mSEP	equ 67
mSTA	equ 68
mSTP	equ 69
mSTX	equ 70
mSTY	equ 71
mSTZ	equ 72
mTAX	equ 73
mTAY	equ 74
mTCD	equ 75
mTCS	equ 76
mTDC	equ 77
mTRB	equ 78
mTSB	equ 79
mTSC	equ 80
mTSX	equ 81
mTXA	equ 82
mTXS	equ 83
mTXY	equ 84
mTYA	equ 85
mTYX	equ 86
mWAI	equ 87
mWDM	equ 88
mXBA	equ 89
mXCE	equ 90
mPLP	equ 91
*
* addressing modes -- high 3 bits = # bytes in operand
*
b0	equ $00	;0 operand bytes
b1	equ $20	;1 operand byte
b2	equ $40	;2 operand bytes
b3	equ $60	;3 operand bytes
bx	equ $80	;depends on 'x' flag: 1 or 2 operand bytes
bm	equ $A0	;depends on 'm' flag: 1 or 2 operand bytes
*
aCOMX	equ $01	;xxx ---,X
aCOMY	equ $02	;xxx ---,Y
aIND 	equ $03	;xxx (---)
aINDX	equ $04	;xxx (---,X)
aINDY	equ $05	;xxx (---),Y
aILONG	equ $06+b1	;xxx [$xx]
aILONGY	equ $07+b1	;xxx [$xx],Y
aSTK	equ $08+b1	;xxx $xx,S
aISTKY	equ $09+b1	;xxx ($xx,S),Y
aREL1	equ $0A	;xxx $xxxx
aREL2	equ $0B	;xxx $xxxx
aIMM	equ $0C	;xxx #
*
* left-text table, right-text table (1 entry per addr mode above)
*
LTtable	DC.L tNO,tNO,tNO,tLP,tLP,tLP
	DC.L tLB,tLB,tNO,tLP,tNO,tNO,tIMM
RTtable	DC.L tNO,tCOMX,tCOMY,tRP,tCXRP,tRPCY
	DC.L tRB,tRBCY,tCS,tSY,tNO,tNO,tNO
*
tNO	DC.B 0		;no text
tLP	DC.B $28,0		;'('
tLB	DC.B $5B,0		;'['
tIMM	DC.B $23,0		;'#'
tCOMX	DC.B $2c,$58,0		;',X'
tCOMY	DC.B $2c,$59,0		;',Y'
tRP	DC.B $29,0		;')'
tCXRP	DC.B $2c,$58,$29,0		;',X)'
tRPCY	DC.B $29,$2c,$59,0		;'),Y'
tRB	DC.B $5d,0		;']'
tRBCY	DC.B $5d,$2c,$59,0		;'],Y'
tSY	DC.B $2c,$53,$29,$2c,$59,0	;',S),Y'
tCS	DC.B $2c,$53,0		;',S'
*
* DisasmTbl -- one word per opcode.
*    word 1 = mnemonic index (MnemTbl)
*    word 2 = address mode (NNNmmmmm)
*	     N = # bytes in operand (0, 1, 2, 3, x:1/2, m:1/2)
*	     M = mode (aXXXX)
*
DisasmTbl	DC.B mBRK,b1,mORA,b1+aINDX,mCOP,b1,mORA,aSTK	;$0-3
	DC.B mTSB,b1,mORA,b1,mASL,b1,mORA,aILONG
	DC.B mPHP,b0,mORA,aIMM+bm,mASL,b0,mPHD,b0
	DC.B mTSB,b2,mORA,b2,mASL,b2,mORA,b3
	DC.B mBPL,b1+aREL1,mORA,aINDY+b1,mORA,aIND+b1,mORA,aISTKY	;$10-13
	DC.B mTRB,b1,mORA,b1+aCOMX,mASL,b1+aCOMX,mORA,aILONGY
	DC.B mCLC,b0,mORA,b2+aCOMY,mINC,b0,mTCS,b0
	DC.B mTRB,b2,mORA,b2+aCOMX,mASL,b2+aCOMX,mORA,b3+aCOMX
	DC.B mJSR,b2,mAND,b1+aINDX,mJSL,b3,mAND,aSTK	;$20-23
	DC.B mBIT,b1,mAND,b1,mROL,b1,mAND,aILONG
	DC.B mPLP,b0,mAND,aIMM+bm,mROL,b0,mPLD,b0
	DC.B mBIT,b2,mAND,b2,mROL,b2,mAND,b3
	DC.B mBMI,b1+aREL1,mAND,b1+aINDY,mAND,b1+aIND,mAND,aISTKY	;$30-33
	DC.B mBIT,b1+aCOMX,mAND,b1+aCOMX,mROL,b1+aCOMX,mAND,aILONGY
	DC.B mSEC,b0,mAND,b2+aCOMY,mDEC,b0,mTSC,b0
	DC.B mBIT,b2+aCOMX,mAND,b2+aCOMX,mROL,b2+aCOMX,mAND,b3+aCOMX
	DC.B mRTI,b0,mEOR,b1+aINDX,mWDM,b1,mEOR,aSTK	;$40-43
	DC.B mMVP,b2,mEOR,b1,mLSR,b1,mEOR,aILONG
	DC.B mPHA,b0,mEOR,aIMM+bm,mLSR,b0,mPHK,b0
	DC.B mJMP,b2,mEOR,b2,mLSR,b2,mEOR,b3
	DC.B mBVC,b1+aREL1,mEOR,b1+aINDY,mEOR,b1+aIND,mEOR,aISTKY	;$50-53
	DC.B mMVN,b2,mEOR,b1+aCOMX,mLSR,b1+aCOMX,mEOR,aILONGY
	DC.B mCLI,b0,mEOR,b2+aCOMY,mPHY,b0,mTCD,b0
	DC.B mJMP,b3,mEOR,b2+aCOMX,mLSR,b2+aCOMX,mEOR,b3+aCOMX
	DC.B mRTS,b0,mADC,b1+aINDX,mPER,b2+aREL2,mADC,aSTK	;$60-63
	DC.B mSTZ,b1,mADC,b1,mROR,b1,mADC,aILONG
	DC.B mPLA,b0,mADC,bm+aIMM,mROR,b0,mRTL,b0
	DC.B mJMP,b2+aIND,mADC,b2,mROR,b2,mADC,b3
	DC.B mBVS,b1+aREL1,mADC,b1+aINDY,mADC,b1+aIND,mADC,aISTKY	;$70-73
	DC.B mSTZ,b1+aCOMX,mADC,b1+aCOMX,mROR,b1+aCOMX,mADC,aILONGY
	DC.B mSEI,b0,mADC,b2+aCOMY,mPLY,b0,mTDC,b0
	DC.B mJMP,b2+aINDX,mADC,b2+aCOMX,mROR,b2+aCOMX,mADC,b3+aCOMX
	DC.B mBRA,b1+aREL1,mSTA,b1+aINDX,mBRL,b2+aREL2,mSTA,aSTK	;$80-83
	DC.B mSTY,b1,mSTA,b1,mSTX,b1,mSTA,aILONG
	DC.B mDEY,b0,mBIT,aIMM+bm,mTXA,b0,mPHB,b0
	DC.B mSTY,b2,mSTA,b2,mSTX,b2,mSTA,b3
	DC.B mBCC,b1+aREL1,mSTA,b1+aINDY,mSTA,b1+aIND,mSTA,aISTKY	;$90-93
	DC.B mSTY,b1+aCOMX,mSTA,b1+aCOMX,mSTX,b1+aCOMY,mSTA,aILONGY
	DC.B mTYA,b0,mSTA,b2+aCOMY,mTXS,b0,mTXY,b0
	DC.B mSTZ,b2,mSTA,b2+aCOMX,mSTZ,b2+aCOMX,mSTA,b3+aCOMX
	DC.B mLDY,aIMM+bx,mLDA,b1+aINDX,mLDX,aIMM+bx,mLDA,aSTK	;$A0-A3
	DC.B mLDY,b1,mLDA,b1,mLDX,b1,mLDA,aILONG
	DC.B mTAY,b0,mLDA,aIMM+bm,mTAX,b0,mPLB,b0
	DC.B mLDY,b2,mLDA,b2,mLDX,b2,mLDA,b3
	DC.B mBCS,b1+aREL1,mLDA,b1+aINDY,mLDA,b1+aIND,mLDA,aISTKY	;$B0-B3
	DC.B mLDY,b1+aCOMX,mLDA,b1+aCOMX,mLDX,b1+aCOMY,mLDA,aILONGY
	DC.B mCLV,b0,mLDA,b2+aCOMY,mTSX,b0,mTYX,b0
	DC.B mLDY,b2+aCOMX,mLDA,b2+aCOMX,mLDX,b2+aCOMY,mLDA,b3+aCOMX
	DC.B mCPY,aIMM+bx,mCMP,b1+aINDX,mREP,b1+aIMM,mCMP,aSTK	;$C0-C3
	DC.B mCPY,b1,mCMP,b1,mDEC,b1,mCMP,aILONG
	DC.B mINY,b0,mCMP,aIMM+bm,mDEX,b0,mWAI,b0
	DC.B mCPY,b2,mCMP,b2,mDEC,b2,mCMP,b3
	DC.B mBNE,b1+aREL1,mCMP,b1+aINDY,mCMP,b1+aIND,mCMP,aISTKY	;$D0-D3
	DC.B mPEI,b1,mCMP,b1+aCOMX,mDEC,b1+aCOMX,mCMP,aILONGY
	DC.B mCLD,b0,mCMP,b2+aCOMY,mPHX,b0,mSTP,b0
	DC.B mJML,b2+aIND,mCMP,b2+aCOMX,mDEC,b2+aCOMX,mCMP,b3+aCOMX
	DC.B mCPX,bx+aIMM,mSBC,b1+aINDX,mSEP,aIMM+b1,mSBC,aSTK	;$E0-E3
	DC.B mCPX,b1,mSBC,b1,mINC,b1,mSBC,aILONG
	DC.B mINX,b0,mSBC,aIMM+bm,mNOP,b0,mXBA,b0
	DC.B mCPX,b2,mSBC,b2,mINC,b2,mSBC,b3
	DC.B mBEQ,b1+aREL1,mSBC,b1+aINDY,mSBC,b1+aIND,mSBC,aISTKY	;$F0-F3
	DC.B mPEA,b2,mSBC,b1+aCOMX,mINC,b1+aCOMX,mSBC,aILONGY
	DC.B mSED,b0,mSBC,b2+aCOMY,mPLX,b0,mXCE,b0
	DC.B mJSR,b2+aINDX,mSBC,b2+aCOMX,mINC,b2+aCOMX,mSBC,b3+aCOMX

**************************************************************************
*
* Messages and stuff
*
Filename1	dc.b 15,'NList.AppleData'	;added 19-Jan-91 DAL
Filename2	dc.b 10,'NList.Data'
CfgName	dc.b 14,'NList.Settings'
*
FileMsg	DC.B cr,'(Could not load NList.Data: ',0
*
OopsMsg	DC.B 'Unknown command--type "?" for valid commands.',cr,0
*
MonMsg	DC.B cr,'Use Ctrl-Y or Q to return',cr,0
*
NotAlloc	DC.B 'not allocated',cr,0
*
MemHdr	DC.B 'handle addr   size   flgs ownr path',cr,0
MemHdr2	DC.B '------ ------ ------ ---- ---- ----',cr,0
*
	export CmdsMsg
CmdsMsg	DC.B cr
	DC.B 'For info on a command, type "=" or "?" followed by the character.',cr
	dc.b 'Type =\ or ?\ to list extra commands in modules.  Type =\xxx for a',cr
	dc.b 'description of a particular module command.',cr
	DC.B cr
*                        '00000000011111111112222222222333333333344444444445555555555666666666677777777778'
*                        '12345678901234567890123456789012345678901234567890123456789012345678901234567890'
	DC.B 'DISASSEMBLE',cr
	DC.B '  L  list (disasm)         m  toggle 8/16-bit A      x  toggle 8/16-bit X,Y',cr
	dc.b ' ^E (Ctrl-E) 8-bit A,X,Y  ^N  (Ctrl-N) 16-bit A,X,Y',cr
	DC.B 'MEMORY BLOCKS',cr
	DC.B '  H  info by Handle        W  "where" (by address)   R  Resource file paths',cr
	DC.B '  I  show blocks by ID',cr
	DC.B 'TOOLSETS',cr
	DC.B '  V  show versions/etc     T info by call number     "  find by partial name',cr
	DC.B 'ADDRESSES',cr
	DC.B '  ^  3-byte indirection    @  2-byte indirection     .  separates range st/end',cr
	DC.B '  #  retrieves old address ;  display info from addr :  store values into RAM',cr
	DC.B 'MISCELLANEOUS',cr
	DC.B '  ~  display a list        p  parameter settings     >  set a parameter',cr
	DC.B '  Q  quit from Nifty List  Z  save parameters->disk  =  describe a command',cr
	DC.B '  S  various Status info   *  visit the Monitor      \  extra commands',cr
	dc.b '  `  evaluate expression   _  make a toolbox call!   ^Z debug next command',cr
	dc.b 0
*
MsgNotFound	DC.B '  ---unknown---',0	;note: char 2 is self-modified
*
	dc.b '[end of NL]'
**************************************************************
	ENDP


**************************************************************
*
* Online help text
*
**************************************************************
HelpText	PROC
	export DescrTbl
	export DesSemi
	export DesTilde

	import CmdsMsg
	import TermsMsg

DescrTbl	DC.L desError,desIgnore,desDesc,desBank,desList
	DC.L desQuit,desM,desX,desVersion,desTool
	DC.L CmdsMsg,TermsMsg,desHandle,desID
	DC.L desWhat,desMon,desPrevVal,desStatus
	DC.L desAt,desCaret,desSetvar,desQuote
	DC.L desParam,desTilde,desSemi,desPeriod,desComma
	DC.L desResources,desBackslash
	DC.L desCtlN,desCtlE,desCtlE,desCtrlZ
	dc.l desSaveConfig
	dc.l desEvalExpr,desUnderscore,desColon
	dc.l desComment
**************************************************************
desError	DC.B 'Character after "=" is not a command.',cr,0

desIgnore	DC.B 'A blank does nothing.',cr,0

desCtrlZ	dc.b 'Ctrl-Z executes a BRK $42 just before the next command dispatch.',cr
	dc.b 'This is helpful if you''re debugging a Nifty List command module',cr
	dc.b 'and have a debugger installed.  Example:  ^Z 1\getdp',cr,0

desDesc	DC.B 'The "=" command describes the next command instead of executing it.',cr,0

desBank	DC.B 'The "/" command sets the current bank, as in the Monitor.  If you type 5 or',cr
	DC.B '6 digits of an address, you don''t need a "/".  Example: FE/0L',cr,0

desList	DC.B 'The L command disassembles the specified range of memory or one screen',cr
	DC.B 'of instructions starting at the given address.',cr
	dc.b cr
	DC.B 'Examples:  100.300L   FF1800L    L     2/100W#L',cr
	DC.B cr
	DC.B 'Special information (toolbox call names & much more) is provided in the',cr
	dc.b 'right margin of the disassembly.',cr,0

desQuit	DC.B 'Quit takes you back to the CDA menu.  ESC also quits.',cr,0

desM	DC.B 'M toggles between 8- and 16-bit Memory operations for the List',cr
	DC.B ' command (see also ">").',cr,0

desX	DC.B 'X toggles between 8- and 16-bit indeX operations for the List',cr
	DC.B ' command (see also ">").',cr,0

desVersion
	DC.B 'V (versions) prints a table of all toolsets currently in ROM or',cr
	DC.B 'RAM.  Each line in the table has the following form:',cr
	DC.B cr
	DC.B '  02  + v0102 RAM=02 ROM=2D WAP=00000000  === memory manager ===',cr
	DC.B cr
	DC.B 'All the numbers are in hex.  "+" means the toolset is active, and "-"',cr
	DC.B 'means it is inactive.  The version number, a count of the number of',cr
	DC.B 'functions in RAM and ROM, and the Work Area Page address are given',cr
	DC.B 'for each toolset loaded.  Use 0>u to select system tools, 1>u for',cr
	DC.B 'user tools.',cr,0

desTool	DC.B 'Prints the name and entry point for a tool, which is specified by',cr
	DC.B 'number.  Example:  0902T',cr
	DC.B cr
	DC.B 'If the function number is 0, the info is printed for every tool in',cr
	DC.B 'the toolset.  Example:   0002T or just 2T',cr
	DC.B cr
	DC.B '0T prints the addresses of the system and user TPTs and WAPTs.',cr,0

desHandle
	DC.B 'Prints information on a handle.  See also W and I.  Owner pathnames',cr
	DC.B 'are available for many handles when ProDOS 16 or GS/OS is active.',cr
	DC.B cr
	DC.B 'The "flags" field of a handle is the sum of the following values:',cr
	DC.B '    8000 = locked',cr
	DC.B '    4000 = fixed',cr
	dc.b '    2000 = system handle',cr
	dc.b '    1000 = master pointer block',cr
	DC.B '    0p00 = purge level (0 to 3)  3=most purgable',cr
	DC.B '    0010 = can''t cross bank boundary',cr
	DC.B '    0008 = can''t use special memory',cr
	DC.B '    0004 = page aligned',cr
	DC.B '    0002 = fixed address',cr
	DC.B '    0001 = fixed bank',cr,0

desID	DC.B 'Prints info on all handles belonging to selected memory manager IDs.',cr
	DC.B '0 prints info on ALL allocated handles.  With optional word value',cr
	dc.b 'before the ".", display is limited to blocks with attributes words',cr
	dc.b 'exactly matching the given value.',cr
	DC.B cr
	DC.B 'Examples:  1001i    0i    A002i    C018.1000i',cr
	DC.B cr
	DC.B 'The first digit of an ID identifies it as owned by one of the following:',cr
	DC.B '   0 = memory manager',cr
	DC.B '   1 = application',cr
	DC.B '   2 = control program',cr
	DC.B '   3 = OS',cr
	DC.B '   4 = toolsets (41xx=misc tools, 42xx=scrap mgr)',cr
	DC.B '   5 = desk accessory',cr
	DC.B '   6 = runtime library',cr
	DC.B '   7 = loader',cr
	DC.B '   8 = firmware',cr
	DC.B '   9 = tool locator',cr
	DC.B '   A = setup file',cr
	DC.B '   F = (used by system)',cr
	DC.B cr
	DC.B 'See also W and H.',cr,0

desWhat	DC.B 'Determines what handle an address belongs to, and then prints info on',cr
	DC.B 'that handle.  See also H and I.',cr,0

desMon	DC.B '"*" drops you into the Monitor.  Use Ctrl-Y or Q to return.',cr,0

desPrevVal
	DC.B 'The "#" command is like retyping the last useful address printed',cr
	DC.B 'by the T, I, H, or (") command.  Example:  0101T, then #L',cr
	DC.B cr
	DC.B 'The address will be the entry address for a tool or the starting',cr
	DC.B 'address of a memory block.  See also ;c, ;n, ;C.',cr,0

desStatus
	DC.B 'S)tatus.   Prints memory use statistics and ROM version.  If ProDOS 16',cr
	DC.B 'or GS/OS is active, it also prints the OS version, the current',cr
	DC.B 'application''s name, the name of the boot volume, and the values of',cr
	DC.B 'all non-empty prefixes (0 to 7 for ProDOS 16; 0 to 31 for GS/OS).',cr,0

desAt	DC.B '"@" sets the current address to the two-byte value found at the',cr
	DC.B 'given address, leaving the bank number alone.  Example:  0/36@L',cr,0

desCaret	DC.B '"^" sets the current address to the three-byte value found at the',cr
	DC.B 'given address.  Examples:  E1/1^L    E0644C^L',cr,0

desSetvar	DC.B '">" sets the value of a Nifty List parameter.  Type the value, ">"',cr
	DC.B 'and then the parameter name (listed below).',cr,cr
	DC.B '   L   Language card bank (0 or 1)',cr
	DC.B '   s   Slot for output (normally 3)',cr
	dc.b '   p   slot number for printer (for Apple-H, etc)',cr
	DC.B '   u   1=V and T deal with user toolsets; 0=system toolsets',cr
	DC.B '   x   1=8-bit index registers; 0=16-bit index registers (for L)',cr
	DC.B '   m   1=8-bit A register; 0=16-bit index register (for L)',cr
	DC.B '   a   1=automatically track SEP/REP/XCE instructions (0=don''t)',cr
	DC.B '   h   0=allocated handles; 1=purged handles; 2=free handles (for I)',cr
	dc.b '   r   1=show uncertain softswitch and F8 ROM labels in disassembly',cr
	dc.b '   d   1=load data file at boot, 2=make data file purgable, 3=both',cr
	dc.b '   c   1=enable Condensed output (for ;h)',cr
	dc.b '   v   1=adjust output for voice synthesizer use (no lines of dashes)',cr
	DC.B cr
	dc.b 'Examples:  0>L      1>S        See also "p"',cr,0

desQuote	DC.B 'Type a (") followed by a string to display info on everything in',cr
	DC.B 'NList.Data whose names contain the string.  A (") by itself displays',cr
	dc.b 'everything.  Examples:',cr
	DC.B cr
	DC.B '   "Rgn',cr
	DC.B '   "Version',cr
	DC.B '   "NewHandle',cr
	DC.B '   "',cr
	DC.B '   "OPEN',cr,0

desParam	DC.B 'P displays current parameter settings.  Use ">" to set them.',cr,0

desTilde	DC.B '~ displays miscellaneous info according to the next character:',cr
	DC.B cr
	DC.B '  ~h   HeartBeat interrupt queue tasks',cr
	DC.B '  ~m   MessageCenter info (Tool Locator v2.1+)',cr
	DC.B '  ~p   Ports (current, WindowMgr, MenuMgr)',cr
	DC.B '  ~s   Scrap Manager info',cr
	DC.B '  ~w   Window list (front to back)',cr,0

desSemi	DC.B '; displays information at the current address based on the next',cr
	DC.B 'character:',cr
	DC.B cr
	DC.B '   ;a   ASCII dump (1024 bytes or specified range: xxxx.yyyy;a)',cr
	DC.B '   ;c   Classic Desk Accessory header',cr
	DC.B '   ;c   Control record (needs handle; 0/0 is front window''s ctls)',cr
	DC.B '   ;h   Hex dump (256 bytes or specified range: xxxx.yyyy;h)',cr
	DC.B '   ;m   Menu bar and menus (use 0/0;m for system bar)',cr
	DC.B '   ;n   New Desk Accessory header',cr
	DC.B '   ;p   QuickDraw II port (use ~p and ~w for partial list)',cr
	DC.B '   ;r   Rectangle dump (in decimal)',cr
	DC.B '   ;r   Region summary--needs handle (bounds rect + size of extra data)',cr
	dc.b '   ;s   Interprets stack if executing in bank bb: bb/xxxx;s',cr
	DC.B '   ;w   Window record (use ~w for list)',cr
	DC.B 0

desPeriod	DC.B '. separates beginning and ending address.  Ex: 5/1000.2000L',cr,0

desComma	DC.B '. separates beginning address and length.  Ex: 5/1000,20;h',cr,0

desResources	dc.b 'xxxxR displays a list of all the specified application''s open resource',cr
	dc.b 'file IDs and their GS/OS reference numbers and pathnames.  0r displays the',cr
	dc.b 'current resource application''s files.',cr,0

desBackslash	dc.b '\ introduces a multi-character command name',cr,cr,0

desCtlN	DC.B 'Ctrl-N sets x and m to 0 for 16-bit disassemblies; see x, m, >.',cr,0

desCtlE	DC.B 'Ctrl-E or Ctrl-R sets x and m to 1 for 8-bit disassemblies; see x, m, >.',cr,0

desSaveConfig	dc.b 'Save parameter settings to NList.Settings file.  (See > and P.)',cr,0

desEvalExpr	dc.b 'Evaluate an expression and display result.  Valid expressions are:',cr
	dc.b '   Hex numbers (0, FF69, E10000)',cr
	dc.b '   Decimal numbers (#0, #65385)',cr
	dc.b '   Constant identifiers (#NewHandle, #rIcon, #GS/OS:Open)',cr
	dc.b '   Toolbox call (_QDVersion, _NewHandle(#100,1001,C015,0), _GrafOn)',cr
	dc.b '   Negation of an expression (-1, -#151)',cr
	dc.b '   Quoted string ("hello")',cr
	dc.b '   Bracketed list of exprs ([1 2 3], [_TLVersion _MMVersion], [3 "abc"])',cr
	dc.b 0

desUnderscore	dc.b '_xxx evaluates a toolbox-call expression and displays the result (see `).',cr
	dc.b 'Example:  _NewHandle(_multiply(10,#5),_MMStartUp,C000,0)',cr,0

desColon	dc.b 'addr:expressions stores values into memory at addr (see ` for expr syntax).',cr,0

desComment	dc.b 'Everything on a line after a "!" is ignored.',cr,0

	EndP


	END
